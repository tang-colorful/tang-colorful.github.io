<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="The Journey Is the Reward">
<meta property="og:type" content="website">
<meta property="og:title" content="TT&#39;Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="TT&#39;Blog">
<meta property="og:description" content="The Journey Is the Reward">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="TT">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>TT'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TT'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/19/classifier/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="TT">
      <meta itemprop="description" content="The Journey Is the Reward">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/19/classifier/" class="post-title-link" itemprop="url">60分钟入门PyTorch——训练一个图片分类器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-19 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-19T00:00:00+08:00">2022-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 19:51:24" itemprop="dateModified" datetime="2023-09-13T19:51:24+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A-PyTorch/" itemprop="url" rel="index"><span itemprop="name">深度学习： PyTorch</span></a>
                </span>
            </span>

          
            <span id="/2022/07/19/classifier/" class="post-meta-item leancloud_visitors" data-flag-title="60分钟入门PyTorch——训练一个图片分类器" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/19/classifier/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/19/classifier/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="训练一个分类器"><a href="#训练一个分类器" class="headerlink" title="训练一个分类器"></a>训练一个分类器</h1><p><a target="_blank" rel="noopener" href="https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html#sphx-glr-beginner-blitz-cifar10-tutorial-py">原文链接</a></p>
<h2 id="1-数据"><a href="#1-数据" class="headerlink" title="1. 数据"></a>1. 数据</h2><p>通常来说，当你处理图像、文本、音频和视频数据时，可以使用标准的Python包将数据加载为numpy array形式，然后将数组转换成<code>torch.*Tensor</code></p>
<ul>
<li>图像数据：Pillow、Opencv</li>
<li>音频数据：scipy、librosa</li>
<li>文本数据：原始Python或Cpython来加载，或者使用NLTK、SpaCy</li>
</ul>
<p>视觉数据有一些特殊，有一个包<code>torchvision</code>，可以加载常见数据集，比如ImageNet、CIFAR10、MINIST等，也包括图像转换器，即<code>torchvision.datasets</code>和<code>torch.utils.data.DataLoader</code></p>
<p>这给我们提供了极大的便利，同时避免样板代码（boilerplate code）</p>
<p>在本教程中，使用CIFAR10数据集。它包含类： ‘airplane’, ‘automobile’, ‘bird’, ‘cat’, ‘deer’, ‘dog’, ‘frog’, ‘horse’, ‘ship’, ‘truck’。CIFAR10的图像大小为3×32×32，即3个颜色通道，像素大小32×32.</p>
<p><img src="https://pytorch.org/tutorials/_images/cifar10.png" alt="cifar10"></p>
<hr>
<h2 id="2-训练一个图片分类器"><a href="#2-训练一个图片分类器" class="headerlink" title="2. 训练一个图片分类器"></a>2. 训练一个图片分类器</h2><p>按序执行如下步骤</p>
<ul>
<li>使用<code>torchvision</code>加载并标准化CIFAR10的训练集和测试集</li>
<li>定义一个卷积神经网络</li>
<li>定义一个损失函数</li>
<li>在训练数据上训练网络</li>
<li>在测试数据上测试网络</li>
</ul>
<h3 id="（1）加载和标准化CIFAR10"><a href="#（1）加载和标准化CIFAR10" class="headerlink" title="（1）加载和标准化CIFAR10"></a>（1）加载和标准化CIFAR10</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br></pre></td></tr></table></figure>

<p><code>torchvision</code>数据集的输出是[0,1]的PILImage图像，将它们转换成Tensor类型，并标准化在[-1,1]范围内</p>
<blockquote>
<p>如果在Windows上运行出现了BrokenPipeError，尝试将<code>torch.utils.data.DataLoader()</code>的num_worker设置为0</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">transform = transforms.Compose(</span><br><span class="line">    [transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize((<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>),(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>))]</span><br><span class="line">)</span><br><span class="line">batch_size = <span class="number">4</span></span><br><span class="line">trainset = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./data&#x27;</span>,train=<span class="literal">True</span>,download=<span class="literal">True</span>,transform=transform)</span><br><span class="line">trainloader = torch.utils.data.DataLoader(trainset,batch_size=batch_size,shuffle=<span class="literal">True</span>,num_workers=<span class="number">2</span>)</span><br><span class="line">testset = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./data&#x27;</span>,train=<span class="literal">False</span>,download=<span class="literal">True</span>,transform=transform)</span><br><span class="line">testloader = torch.utils.data.DataLoader(testset,batch_size=batch_size,shuffle=<span class="literal">False</span>,num_workers=<span class="number">2</span>)</span><br><span class="line">classes = (<span class="string">&#x27;plane&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;deer&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;frog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;ship&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Downloading https://www.cs.toronto.edu/~kriz/cifar-<span class="number">10</span>-python.tar.gz to ./data/cifar-<span class="number">10</span>-python.tar.gz</span><br><span class="line">Extracting ./data/cifar-<span class="number">10</span>-python.tar.gz to ./data</span><br><span class="line">Files already downloaded <span class="keyword">and</span> verified</span><br></pre></td></tr></table></figure>

<p>展示一些有趣的训练图像</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">imshow</span>(<span class="params">img</span>):</span><br><span class="line">    img = img/<span class="number">2</span> + <span class="number">0.5</span>  <span class="comment"># 未标准化</span></span><br><span class="line">    npimg = img.numpy()</span><br><span class="line">    <span class="comment"># 将数组的值以图片的形式展示出来</span></span><br><span class="line">    plt.imshow(np.transpose(npimg,(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>)))</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到一些随机的训练图片</span></span><br><span class="line">dataiter = <span class="built_in">iter</span>(trainloader)</span><br><span class="line">images,labels = dataiter.<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示图片</span></span><br><span class="line">imshow(torchvision.utils.make_grid(images))</span><br><span class="line"><span class="comment"># 输出标签</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="string">f&#x27;<span class="subst">&#123;classes[labels[j]]:5s&#125;</span>&#x27;</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(batch_size)))</span><br></pre></td></tr></table></figure>

<p><img src="https://pytorch.org/tutorials/_images/sphx_glr_cifar10_tutorial_001.png" alt="../../_images/sphx_glr_cifar10_tutorial_001.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">car   bird  cat   cat</span><br></pre></td></tr></table></figure>

<h3 id="（2）定义一个卷积神经网络"><a href="#（2）定义一个卷积神经网络" class="headerlink" title="（2）定义一个卷积神经网络"></a>（2）定义一个卷积神经网络</h3><p>复制神经网络教程的神经网络代码，并将它修改成适用于3个channel图片的形式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">        self.pool = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.pool(F.relu(self.conv1(x)))</span><br><span class="line">        x = self.pool(F.relu(self.conv2(x)))</span><br><span class="line">        x = torch.flatten(x, <span class="number">1</span>) <span class="comment"># flatten all dimensions except batch</span></span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net = Net()</span><br></pre></td></tr></table></figure>

<h3 id="（3）定义损失函数和优化器"><a href="#（3）定义损失函数和优化器" class="headerlink" title="（3）定义损失函数和优化器"></a>（3）定义损失函数和优化器</h3><p>使用交叉熵损失分类，含有momentum的SGD优化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(net.parameters(),lr=<span class="number">0.001</span>,momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure>

<h3 id="（4）训练网络"><a href="#（4）训练网络" class="headerlink" title="（4）训练网络"></a>（4）训练网络</h3><p>这时候开始变得有趣，我们只需简单地在迭代数据上循环，并将输入数据输送到网络并优化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):  <span class="comment"># 循环数据集多次</span></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i , data <span class="keyword">in</span> <span class="built_in">enumerate</span>(trainloader,<span class="number">0</span>):</span><br><span class="line">        <span class="comment"># 得到输入数据，数据是[inputs,labels]形式的列表</span></span><br><span class="line">        inputs,labels =data</span><br><span class="line">        <span class="comment"># 参数梯度置为0</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 前向传播 + 后向传播 + 优化</span></span><br><span class="line">        outputs = net(inputs)</span><br><span class="line">        loss = criterion(outputs,labels)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#输出统计数据</span></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2000</span> == <span class="number">1999</span>: <span class="comment"># 每2000个mini-batchs输出一次</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span>,<span class="subst">&#123;i+<span class="number">1</span>:5d&#125;</span>] loss:<span class="subst">&#123;running_loss/<span class="number">2000</span>:<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;完成训练&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,  <span class="number">2000</span>] loss: <span class="number">2.144</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">4000</span>] loss: <span class="number">1.828</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">6000</span>] loss: <span class="number">1.659</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">8000</span>] loss: <span class="number">1.579</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">10000</span>] loss: <span class="number">1.530</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">12000</span>] loss: <span class="number">1.491</span></span><br><span class="line">[<span class="number">2</span>,  <span class="number">2000</span>] loss: <span class="number">1.405</span></span><br><span class="line">[<span class="number">2</span>,  <span class="number">4000</span>] loss: <span class="number">1.379</span></span><br><span class="line">[<span class="number">2</span>,  <span class="number">6000</span>] loss: <span class="number">1.359</span></span><br><span class="line">[<span class="number">2</span>,  <span class="number">8000</span>] loss: <span class="number">1.329</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">10000</span>] loss: <span class="number">1.309</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">12000</span>] loss: <span class="number">1.299</span></span><br><span class="line">Finished Training</span><br></pre></td></tr></table></figure>

<p>快速保存好我们训练的模型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PATH = <span class="string">&#x27;./cifar_net.pth&#x27;</span></span><br><span class="line">torch.save(net.state_dict(),PATH)</span><br></pre></td></tr></table></figure>

<h3 id="（5）在测试集上测试网络"><a href="#（5）在测试集上测试网络" class="headerlink" title="（5）在测试集上测试网络"></a>（5）在测试集上测试网络</h3><p>我们已经在训练集上训练了2次网络，但是我们需要检查网络有没有学到东西</p>
<p>网络的输出作为预测的类标签，检查它和真实值之间的差距，如果预测正确，我们将样本添加到正确预测的列表中</p>
<p>第一步，展示测试集的图片熟悉下内容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dataiter = <span class="built_in">iter</span>(testloader)</span><br><span class="line">images,labels = dataiter.<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出图片</span></span><br><span class="line">imshow(torchvision.utils.make_grid(images))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;GroundTruth: &#x27;</span>, <span class="string">&#x27; &#x27;</span>.join(<span class="string">f&#x27;<span class="subst">&#123;classes[labels[j]]:5s&#125;</span>&#x27;</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GroundTruth:  cat   ship  ship  plane</span><br></pre></td></tr></table></figure>

<p><img src="https://pytorch.org/tutorials/_images/sphx_glr_cifar10_tutorial_002.png" alt="../../_images/sphx_glr_cifar10_tutorial_002.png"></p>
<p>接下来，加载回存储过的模型（注意：存储并且再加载模型不是必要的步骤，这里这是说明如何做）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net = Net()</span><br><span class="line">net.load_state_dict(torch.load(PATH))</span><br></pre></td></tr></table></figure>

<p>现在，让我们来看看神经网络认为以上图片是什么</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputs = net(images)</span><br></pre></td></tr></table></figure>

<p>输出10个标签的概率，一个类别的概率越大，神经网络越认为它是这个类别，所以我们得到最高概率的标签</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_, predicted = torch.<span class="built_in">max</span>(outputs, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Predicted: &#x27;</span>, <span class="string">&#x27; &#x27;</span>.join(<span class="string">f&#x27;<span class="subst">&#123;classes[predicted[j]]:5s&#125;</span>&#x27;</span></span><br><span class="line">                              <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicted:  cat   car   car   plane</span><br></pre></td></tr></table></figure>

<p>结果看起来不错</p>
<p>让我们看看在整个数据集上网络的表现效果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网络在整个数据集上的表现效果</span></span><br><span class="line">correct = <span class="number">0</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="comment"># 不训练，就不需要计算输出的梯度</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    images,labels = data</span><br><span class="line">    <span class="comment"># 将图片传进网络计算输出</span></span><br><span class="line">    outputs = net(images)</span><br><span class="line">    <span class="comment"># 在哪个类别上概率最高，就是预测的类别结果</span></span><br><span class="line">    _,predicted = torch.<span class="built_in">max</span>(outputs.data,<span class="number">1</span>)</span><br><span class="line">    total += labels.size(<span class="number">0</span>)</span><br><span class="line">    correct = (predicted==labels).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;神经网络在10000条测试图像上的准确率为：<span class="subst">&#123;<span class="number">100</span> * correct // total&#125;</span>%&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accuracy of the network on the <span class="number">10000</span> test images: <span class="number">54</span> %</span><br></pre></td></tr></table></figure>

<p>结果看起来比随机猜测效果要好，因为随机猜测的准确率是10%，网络似乎学到了一些东西</p>
<p>在哪些类上的预测效果比较好，哪些不好呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prepare to count predictions for each class</span></span><br><span class="line">correct_pred = &#123;classname: <span class="number">0</span> <span class="keyword">for</span> classname <span class="keyword">in</span> classes&#125;</span><br><span class="line">total_pred = &#123;classname: <span class="number">0</span> <span class="keyword">for</span> classname <span class="keyword">in</span> classes&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># again no gradients needed</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> testloader:</span><br><span class="line">        images, labels = data</span><br><span class="line">        outputs = net(images)</span><br><span class="line">        _, predictions = torch.<span class="built_in">max</span>(outputs, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># collect the correct predictions for each class</span></span><br><span class="line">        <span class="keyword">for</span> label, prediction <span class="keyword">in</span> <span class="built_in">zip</span>(labels, predictions):</span><br><span class="line">            <span class="keyword">if</span> label == prediction:</span><br><span class="line">                correct_pred[classes[label]] += <span class="number">1</span></span><br><span class="line">            total_pred[classes[label]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print accuracy for each class</span></span><br><span class="line"><span class="keyword">for</span> classname, correct_count <span class="keyword">in</span> correct_pred.items():</span><br><span class="line">    accuracy = <span class="number">100</span> * <span class="built_in">float</span>(correct_count) / total_pred[classname]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Accuracy for class: <span class="subst">&#123;classname:5s&#125;</span> is <span class="subst">&#123;accuracy:<span class="number">.1</span>f&#125;</span> %&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: plane <span class="keyword">is</span> <span class="number">54.2</span> %</span><br><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: car   <span class="keyword">is</span> <span class="number">85.1</span> %</span><br><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: bird  <span class="keyword">is</span> <span class="number">41.1</span> %</span><br><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: cat   <span class="keyword">is</span> <span class="number">33.9</span> %</span><br><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: deer  <span class="keyword">is</span> <span class="number">38.7</span> %</span><br><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: dog   <span class="keyword">is</span> <span class="number">55.8</span> %</span><br><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: frog  <span class="keyword">is</span> <span class="number">66.7</span> %</span><br><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: horse <span class="keyword">is</span> <span class="number">70.5</span> %</span><br><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: ship  <span class="keyword">is</span> <span class="number">55.3</span> %</span><br><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: truck <span class="keyword">is</span> <span class="number">44.6</span> %</span><br></pre></td></tr></table></figure>

<p>如何在GPU上训练神经网络呢？</p>
<h2 id="3-在GPU上训练"><a href="#3-在GPU上训练" class="headerlink" title="3. 在GPU上训练"></a>3. 在GPU上训练</h2><p>就像是如何把一个tensor转换到GPU上，也同样把神经网络转换到GPU上</p>
<p>如果我们有可用的CUDA，首先将我们的设备定义为一个可用的CUDA设备</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">device = torch.device(<span class="string">&#x27;cuda:0&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"><span class="comment"># 假设我们在CUDA机器上，应该打印一个CUDA设备</span></span><br><span class="line"><span class="built_in">print</span>(device)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cuda:<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>下面的<code>device</code>就是一个CUDA设备</p>
<p>然后，这些方法将递归遍历所有模块，并且将它们的参数和缓冲区转换成CUDA tensor</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.to(device)</span><br><span class="line"><span class="comment"># 必须在每个步骤中将输入和目标发送到GPU</span></span><br><span class="line">inputs,labels = data[<span class="number">0</span>].to(device),data[<span class="number">1</span>].to(device)</span><br></pre></td></tr></table></figure>

<p>为什么没注意到和CPU相比要较大的速度提升呢？因为模型太小了。</p>
<p><strong>实践练习</strong>：</p>
<p>尝试提升网络的宽度（第一个<code>nn.Conv2d</code>的第二个参数，第二个<code>nn.Conv2d</code>的第一个参数，它们应该是相同的数字），看看你得到了什么样的加速</p>
<p><strong>已实现目标</strong>：</p>
<ul>
<li>深入了解PyTorch的Tensor库和神经网络</li>
<li>训练一个小的网络去分类图片</li>
</ul>
<hr>
<h2 id="4-在多个GPU上训练"><a href="#4-在多个GPU上训练" class="headerlink" title="4. 在多个GPU上训练"></a>4. 在多个GPU上训练</h2><p>如果你希望使用所有的GPU来获得更大的加快速度，请看选读：<a target="_blank" rel="noopener" href="https://pytorch.org/tutorials/beginner/blitz/data_parallel_tutorial.html">数据并行</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/18/Neural%20Nwtworks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="TT">
      <meta itemprop="description" content="The Journey Is the Reward">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/18/Neural%20Nwtworks/" class="post-title-link" itemprop="url">60分钟入门PyTorch——神经网络（用PyTorch构建一个神经网络）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-18 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-18T00:00:00+08:00">2022-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 19:51:01" itemprop="dateModified" datetime="2023-09-13T19:51:01+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A-PyTorch/" itemprop="url" rel="index"><span itemprop="name">深度学习： PyTorch</span></a>
                </span>
            </span>

          
            <span id="/2022/07/18/Neural%20Nwtworks/" class="post-meta-item leancloud_visitors" data-flag-title="60分钟入门PyTorch——神经网络（用PyTorch构建一个神经网络）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/18/Neural%20Nwtworks/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/18/Neural%20Nwtworks/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Neural-Networks"><a href="#Neural-Networks" class="headerlink" title="Neural Networks"></a>Neural Networks</h1><h2 id="1-神经网络"><a href="#1-神经网络" class="headerlink" title="1. 神经网络"></a>1. 神经网络</h2><p><code>torch.nn</code>包可以用来构建神经网络，<code>nn</code>包依赖于<code>autograd</code>包去定义模型并对其进行求导</p>
<p>一个<code>nn.Module</code>包含很多层，和一个以<code>input</code>作为输入的前向方法<code>forward</code>，并返回输出<code>output</code></p>
<p>下面是一个分类数字图像的网络</p>
<p><img src="https://pytorch.org/tutorials/_images/mnist.png" alt="convnet"></p>
<h3 id="卷积网络"><a href="#卷积网络" class="headerlink" title="卷积网络"></a>卷积网络</h3><p>这是一个简单的前馈神经网络，网络接受输入数据，一层接着一层的传输输入数据，最后给出输出结果。</p>
<p>一个神经网络的典型训练过程如下：</p>
<ul>
<li>定义包括可学习参数（或权重）的网络，</li>
<li>用数据集做迭代</li>
<li>计算损失（输出值和真实值之间的差异）</li>
<li>将梯度反向传播进网络的参数</li>
<li>更新网络的参数，经典的一个简单的更新规则：$weight &#x3D; weight - learning_rate *gradient$</li>
</ul>
<hr>
<h2 id="2-定义网络"><a href="#2-定义网络" class="headerlink" title="2. 定义网络"></a>2. 定义网络</h2><p>定义网络</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net,self).__init__()</span><br><span class="line">        <span class="comment"># 输入通道：1，输出通道：6，卷积核：3*3</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>,<span class="number">6</span>,<span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>,<span class="number">16</span>,<span class="number">5</span>)</span><br><span class="line">        <span class="comment"># y = Wx + b</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span>*<span class="number">5</span>*<span class="number">5</span>,<span class="number">120</span>) </span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>,<span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        <span class="comment"># 最大池化层(2,2)</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv1(x)),<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 如果是方形，可以使用单个数字定义</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv2(x)),<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 除batch维度外，展开所有维度</span></span><br><span class="line">        x = torch.flatten(x,<span class="number">1</span>)</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line"><span class="built_in">print</span>(net)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Net(</span><br><span class="line">  (conv1): Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">  (conv2): Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">  (fc1): Linear(in_features=<span class="number">400</span>, out_features=<span class="number">120</span>, bias=<span class="literal">True</span>)</span><br><span class="line">  (fc2): Linear(in_features=<span class="number">120</span>, out_features=<span class="number">84</span>, bias=<span class="literal">True</span>)</span><br><span class="line">  (fc3): Linear(in_features=<span class="number">84</span>, out_features=<span class="number">10</span>, bias=<span class="literal">True</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>必须要定义<code>forward</code>函数，计算梯度的<code>backward</code>函数会使用<code>autograd</code>自动定义，在<code>forward</code>函数中可以使用任何针对Tensor的操作</p>
<p><code>net.parameters()</code>返回一个模型需要学习的参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">params = <span class="built_in">list</span>(net.parameters())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(params))</span><br><span class="line"><span class="built_in">print</span>(params[<span class="number">0</span>].size()) <span class="comment"># conv1的权重</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">torch.Size([6, 1, 5, 5])</span><br></pre></td></tr></table></figure>

<p>随机构造32×32大小的输入数据，这个网络结构（LeNet）期待的输入数据是32×32。如果要在MINIST数据集上使用这个网络，需要把数据集中的图像调整到32×32</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">input</span> = torch.randn(<span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line">out = net(<span class="built_in">input</span>)</span><br><span class="line"><span class="built_in">print</span>(out)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ 0.0242, -0.0113, -0.1382, -0.1108,  0.1062,  0.0663,  0.0473,  0.0761, 0.1049, -0.0412]], grad_fn=&lt;AddmmBackward0&gt;)</span><br></pre></td></tr></table></figure>

<p>将所有参数的梯度缓存清零，然后进行随机梯度的反向传播</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.zero_grad()</span><br><span class="line">out.backward(torch.randn(<span class="number">1</span>,<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>torch.nn</code>只支持小批量输入，整个<code>torch.nn</code>包都只支持小样本的输入，而不是单个样本</p>
<p>例如：<code>nn.Conv2d</code>将接受一个四维的张量：nSamples×nChannels×Height×Width</p>
<p>如果有单个样本，使用<code>input.unsqueeze(0)</code>来添加一个假batch维度</p>
</blockquote>
<p>回归一下到目前为止见过的所有类</p>
<ul>
<li><code>torch.Tensor</code>：支持autograd操作（比如<code>backward()</code>）的多维数组，同时保存梯度（tensor形式）</li>
<li><code>nn.Module</code>：神经网络模块，方便封装参数，帮助移到到GPU上运行、导出和加载等</li>
<li><code>nn.Parameter</code>：一种张量，当把它赋值给Module的属性时，会自动注册为参数</li>
<li><code>autograd.Function</code>：实现autograd操作的前向和后向定义，每个<code>Tensor</code>操作会创造至少一个<code>Function</code>节点，这个节点连接到创建<code>tensor</code>并对其历史进行编码的函数</li>
</ul>
<p>现在，我们已覆盖如下内容</p>
<ul>
<li>定义一个神经网络</li>
<li>处理输入，调用反向传播函数</li>
</ul>
<p>还剩下：</p>
<ul>
<li>计算损失</li>
<li>更新网络的权重参数</li>
</ul>
<hr>
<h2 id="3-损失函数"><a href="#3-损失函数" class="headerlink" title="3. 损失函数"></a>3. 损失函数</h2><p>损失函数接受（output，target）作为输入（output为网络的输出,target为实际值），计算值来评估output和target的误差</p>
<p>在<code>nn</code>包下有几种不同的损失函数，一个简单的损失是：<code>nn.MSELoss</code>，计算output和target之间的均方误差</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output = net(<span class="built_in">input</span>)</span><br><span class="line">target = torch.randn(<span class="number">10</span>)</span><br><span class="line">target = target.view(<span class="number">1</span>,-<span class="number">1</span>) <span class="comment"># 保持和output输出形状相同</span></span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line"></span><br><span class="line">loss = criterion(output,target)</span><br><span class="line"><span class="built_in">print</span>(loss)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor(<span class="number">0.3965</span>, grad_fn=&lt;MseLossBackward0&gt;)</span><br></pre></td></tr></table></figure>

<p>现在，如果你反向跟踪loss，使用<code>.grad_fn</code>属性，将会看到下面这样的计算图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span> -&gt; conv2d -&gt; relu -&gt; maxpool2d -&gt; conv2d -&gt; relu -&gt; maxpool2d</span><br><span class="line">      -&gt; flatten -&gt; linear -&gt; relu -&gt; linear -&gt; relu -&gt; linear</span><br><span class="line">      -&gt; MSELoss</span><br><span class="line">      -&gt; loss</span><br></pre></td></tr></table></figure>

<p>所以，当调用<code>loss.backward()</code>的时候，整个图被分为神经网络参数和图中设置<code>requires_grad=True</code>的所有tensor，帮助<code>.grad</code>张量的梯度积累</p>
<p>为了说明情况，我们向回追踪几步：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(loss.grad_fn)  <span class="comment"># MSELoss</span></span><br><span class="line"><span class="built_in">print</span>(loss.grad_fn.next_functions[<span class="number">0</span>][<span class="number">0</span>]) <span class="comment"># Linear</span></span><br><span class="line"><span class="built_in">print</span>(loss.grad_fn.next_functions[<span class="number">0</span>][<span class="number">0</span>].next_functions[<span class="number">0</span>][<span class="number">0</span>]) <span class="comment"># ReLU</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MseLossBackward0 <span class="built_in">object</span> at <span class="number">0x0000019DABCB18B0</span>&gt;</span><br><span class="line">&lt;AddmmBackward0 <span class="built_in">object</span> at <span class="number">0x0000019DABCB1250</span>&gt;</span><br><span class="line">&lt;AccumulateGrad <span class="built_in">object</span> at <span class="number">0x0000019DABCB18B0</span>&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-反向传播"><a href="#4-反向传播" class="headerlink" title="4. 反向传播"></a>4. 反向传播</h2><p>为了反向传播误差，要调用<code>loss.backward()</code>，你需要清除已经存在的梯度，不然梯度就会被累加到已经存在的梯度</p>
<p>现在调用<code>loss.backward()</code>，看看conv1在反向传播前后的偏置梯度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">net.zero_grad()     <span class="comment"># zeroes the gradient buffers of all parameters</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;conv1.bias.grad before backward&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(net.conv1.bias.grad)</span><br><span class="line"></span><br><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;conv1.bias.grad after backward&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(net.conv1.bias.grad)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conv1.bias.grad before backward</span><br><span class="line">tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])</span><br><span class="line">conv1.bias.grad after backward</span><br><span class="line">tensor([-<span class="number">0.0079</span>,  <span class="number">0.0134</span>,  <span class="number">0.0143</span>,  <span class="number">0.0054</span>,  <span class="number">0.0081</span>, -<span class="number">0.0033</span>])</span><br></pre></td></tr></table></figure>

<p>现在，我们已经知道如何使用损失函数</p>
<p>接下来最后一件要学习的是：更新网络权重</p>
<h2 id="5-更新权重"><a href="#5-更新权重" class="headerlink" title="5. 更新权重"></a>5. 更新权重</h2><p>在实践中最简单的更新规则是<strong>随机梯度下降</strong>(SGD)</p>
<p>$$weight&#x3D;weight−learning_rate∗gradient$$</p>
<p>使用Python代码简单实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> net.parameters():</span><br><span class="line">    f.data.sub_(f.grad.data * learning_rate)</span><br></pre></td></tr></table></figure>

<p><code>torch.optim</code>包里面有各种更新方法的实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建优化器</span></span><br><span class="line">optimizer = optim.SGD(net.parameters(),lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练循环中</span></span><br><span class="line">optimizer.zero_grad()</span><br><span class="line">output = net(<span class="built_in">input</span>)</span><br><span class="line">loss = criterion(output,target)</span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step()  <span class="comment"># 更新参数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>梯度是可以累积的，所以要使用<code>optimizer.zero_grad()</code>手动将梯度缓冲区设置为零</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/17/autograd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="TT">
      <meta itemprop="description" content="The Journey Is the Reward">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/17/autograd/" class="post-title-link" itemprop="url">60分钟入门PyTorch——自动求导autograd</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-17 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-17T00:00:00+08:00">2022-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 19:49:49" itemprop="dateModified" datetime="2023-09-13T19:49:49+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A-PyTorch/" itemprop="url" rel="index"><span itemprop="name">深度学习： PyTorch</span></a>
                </span>
            </span>

          
            <span id="/2022/07/17/autograd/" class="post-meta-item leancloud_visitors" data-flag-title="60分钟入门PyTorch——自动求导autograd" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/17/autograd/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/17/autograd/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="torch-autograd"><a href="#torch-autograd" class="headerlink" title="torch.autograd"></a>torch.autograd</h1><p><code>torch.autograd</code>是PyTorch自动求导的工具，求导支撑着神经网络的训练。</p>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>神经网络（NN）是作用在<strong>输入数据</strong>上的一系列嵌套函数的集合，这些函数由参数（weights和biases）定义，被存储在PyTorch的tensor中。</p>
<p>训练神经网络的两个步骤</p>
<ul>
<li><strong>前向传播</strong>：在前向传播中，NN尽最大努力猜测正确的输出结果。如何猜测呢？将输入数据送入到NN中的每一个函数进行处理。</li>
<li><strong>反向传播</strong>：在反向传播中，NN根据上一步骤猜测的误差来相应地调整参数。如何调整的？它通过从输出结果向回遍历，收集有关函数参数（梯度）的误差的导数，并使用梯度下降来优化参数。更多的细节可以参照3Blue1Brown的讲解视频。</li>
</ul>
<hr>
<h2 id="2-在PyTorch中的应用"><a href="#2-在PyTorch中的应用" class="headerlink" title="2. 在PyTorch中的应用"></a>2. 在PyTorch中的应用</h2><p>下面看一个示例的训练步骤，从torchvision中加载一个预训练的<strong>resnet18</strong></p>
<p><strong>模型</strong>。</p>
<p>使用随机数创建tensor去表示一张图片：有3个通道，高和宽均为64，相应的标签也用随机数初始化，形状为（1,1000）。</p>
<blockquote>
<p>该示例的工作运行在CPU上，而不是GPU（即使tensor被移动到CUDA上）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch,torchvision</span><br><span class="line"></span><br><span class="line">model = torchvision.models.resnet18(pretrained=<span class="literal">True</span>) <span class="comment"># 加载模型</span></span><br><span class="line">data = torch.rand(<span class="number">1</span>,<span class="number">3</span>,<span class="number">64</span>,<span class="number">64</span>) <span class="comment"># 创建输入数据</span></span><br><span class="line">labels = torch.rand(<span class="number">1</span>,<span class="number">1000</span>) <span class="comment"># 随机初始化标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将输入数据通过模型的每一层来进行预测，所谓前向传播</span></span><br><span class="line">prediction = model(data)</span><br><span class="line"><span class="comment"># 用模型预测值和标签计算误差（损失）</span></span><br><span class="line">loss = (prediction-labels).<span class="built_in">sum</span>()</span><br><span class="line"><span class="comment"># 使用损失，反向传播通过神经网络</span></span><br><span class="line"><span class="comment"># 在误差的tensor上使用.backward()，它会自动计算模型每一个参数的的梯度并存储在参数的.grad属性中</span></span><br><span class="line">loss.backward()</span><br><span class="line"><span class="comment"># 加载优化器:随机梯度下降</span></span><br><span class="line">optim = torch.optim.SGD(model.parameters(), lr=<span class="number">1e-2</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line"><span class="comment"># 使用.step()梯度下降，优化器会根据存储在.grad中的梯度值调整每一个参数</span></span><br><span class="line">optim.step()</span><br></pre></td></tr></table></figure>

<p>以上是训练一个神经网络的步骤，下面是autograd工作的一些细节——可以随意跳过它们</p>
<hr>
<h2 id="3-autograd中的求导"><a href="#3-autograd中的求导" class="headerlink" title="3. autograd中的求导"></a>3. autograd中的求导</h2><h3 id="autograd如何收集梯度呢？"><a href="#autograd如何收集梯度呢？" class="headerlink" title="autograd如何收集梯度呢？"></a>autograd如何收集梯度呢？</h3><p>创建两个tensor：a和b，<code>requires_grad=True</code>，这表明<code>autograd</code>会追踪a和b上的每一个操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">a = torch.tensor([<span class="number">2.</span>, <span class="number">3.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.tensor([<span class="number">6.</span>, <span class="number">4.</span>], requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>使用a和b创建另一个张量Q<br>$$<br>Q &#x3D; 3a^3 - b^2<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q = 3*a**3 - b**2</span><br></pre></td></tr></table></figure>

<p>假设a和b是神经网络的参数，Q是损失，在训练网络时，需要计算损失的参数的梯度<br>$$<br>\frac{\partial Q}{\partial a} &#x3D; 9a^2 \<br>\frac{\partial Q}{\partial b} &#x3D; -2b<br>$$<br>执行Q.backward()，会自动计算这些梯度，同时在相应的tensor.grad属性中存储。</p>
<p>我们需要在执行<code>Q.backward()</code>时显式传递<code>gradient</code>属性，因为这里的gradient是一个<strong>向量</strong>，和Q形状相同，它表示Q的梯度<br>$$<br>\frac{dQ}{dQ}&#x3D;1<br>$$<br>同样地，可以把Q聚合成标量，然后隐式地反向传播：<code>Q.sum().backward()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">external_grad = torch.tensor([<span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line">Q.backward(gradient=external_grad)</span><br></pre></td></tr></table></figure>

<p>现在梯度被保存在<code>a.grad</code>和<code>b.grad</code>中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查收集到的梯度是否正确</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">9</span>*a**<span class="number">2</span> == a.grad)</span><br><span class="line"><span class="built_in">print</span>(-<span class="number">2</span>*b == b.grad</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([<span class="literal">True</span>, <span class="literal">True</span>])</span><br><span class="line">tensor([<span class="literal">True</span>, <span class="literal">True</span>])</span><br></pre></td></tr></table></figure>



<h3 id="选读：用autograd进行向量计算"><a href="#选读：用autograd进行向量计算" class="headerlink" title="选读：用autograd进行向量计算"></a>选读：用autograd进行向量计算</h3><p>在数学上，如果有一个向量值函数：$\vec y &#x3D; f(\vec x)$，用$\vec x$表示的梯度$\vec y$是雅克比矩阵(Jacobian matrix)$J$<br>$$<br>J &#x3D; (\frac{\partial y}{\partial x_1}…\frac{\partial y}{\partial x_n})&#x3D;<br>\begin{pmatrix}<br>\frac{\partial y_1}{\partial x_1} &amp; … &amp; \frac{\partial y_1}{\partial x_n} \<br>.&amp;&amp;.\.&amp;.&amp;.\.&amp;&amp;.\<br>\frac{\partial y_m}{\partial x_1} &amp; … &amp; \frac{\partial y_m}{\partial x_n}<br>\end{pmatrix}<br>$$<br>通常来说，<code>torch.autograd</code>是计算向量雅克比乘积的工具，也就是，给定一个向量$\vec v$，计算乘积$J^T<em>\vec v$。如果$\vec v$是标量函数$l&#x3D;g(\vec y)$的梯度:<br>$$<br>\vec v &#x3D; (\frac{\partial l}{\partial y_1}…\frac{\partial l}{\partial y_m})^T<br>$$<br>根据链式法则，用$\vec x$来表示$l$的梯度，即为*<em>向量-雅克比矩阵 乘积</em></em>&#x3D;&#x3D;图片未上传成功&#x3D;&#x3D;</p>
<p><img src="C:/Users/TSY/Desktop/Snipaste_2022-07-17_21-23-00.png" alt="Snipaste00"></p>
<p>向量雅可比积的这种特性使得将外部梯度馈送到具有非标量输出的模型中非常方便，也是在我们上面的例子中使用的，<code>external_grad</code>代表$\vec v$。</p>
<hr>
<h2 id="4-计算图-Computational-Graph"><a href="#4-计算图-Computational-Graph" class="headerlink" title="4. 计算图(Computational Graph)"></a>4. 计算图(Computational Graph)</h2><p>从概念上讲，<code>autograd</code>在由函数对象组成的<strong>有向无环图(DAG)<strong>中保存数据(tensor)和所有执行的操作（以及由操作产生的新tensor）。在这个DAG中，叶子节点是输入tensors，根节点是输出tensors。从根节点到叶子节点来追踪这个图，可以使用</strong>链式法则</strong>来自动计算梯度。</p>
<p>在前向传播中，autograd同时做两件事情：</p>
<ul>
<li>运行所请求的操作来计算<strong>输出tensor</strong></li>
<li>在DAG中保存操作的梯度</li>
</ul>
<p>当在DAG根节点上调用<code>.backward()</code>时，反向传播开始启动，<code>autograd</code>会做一系列操作：</p>
<ul>
<li>计算每一个<code>.grad_fn</code>的梯度</li>
<li>将它们累加到各自tensor的<code>.grad</code>属性中</li>
<li>使用链式法则，一直传播到叶子节点的tensors</li>
</ul>
<p>下图是我们示例的DAG可视化表示。在图中，箭头表示前向传播的方向，节点表示在前向传播中的每个操作的向后函数，蓝色的叶子节点表示张量a和b。</p>
<p><img src="https://pytorch.org/tutorials/_images/dag_autograd.png" alt="../../_images/dag_autograd.png"></p>
<blockquote>
<p>DAG在PyTorch中是动态的，在每一次调用.backward()之后，计算图是重新开始创建的，autograd会重新填充一个新的图，这就是允许在模型中使用控制流语句的原因。</p>
<p>可以根据需求在每次迭代时更改形状、大小和操作。</p>
</blockquote>
<h3 id="从DAG中删除-Exclusion-from-the-DAG"><a href="#从DAG中删除-Exclusion-from-the-DAG" class="headerlink" title="从DAG中删除(Exclusion from the DAG)"></a>从DAG中删除(Exclusion from the DAG)</h3><p>如果<code>requires_grad</code>设置为True，<code>torch.autograd</code>就可以追踪对tensor的相关操作。如果不需要tensor的梯度，把属性设置成False就可以从DAG的梯度计算中排除。</p>
<p>即使只有一个简单的输入tensor的<code>requires_grad=True</code>，输出tensors也需要梯度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = torch.rand(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">y = torch.rand(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">z = torch.rand((<span class="number">5</span>, <span class="number">5</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">a = x + y</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Does `a` require gradients? : <span class="subst">&#123;a.requires_grad&#125;</span>&quot;</span>)</span><br><span class="line">b = x + z</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Does `b` require gradients?: <span class="subst">&#123;b.requires_grad&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Does `a` require gradients? : <span class="literal">False</span></span><br><span class="line">Does `b` require gradients?: <span class="literal">True</span></span><br></pre></td></tr></table></figure>



<p>在一个网络结构中，通常把不需要计算梯度的参数称为冻结参数（<strong>frozen parameters</strong>）。如果提前知道哪些参数不需要计算梯度，模型的冻结功能非常有用，还可以通过减少梯度计算来提升性能受益。</p>
<p>另一个从DAG中删除的应用是<strong>微调一个预训练的模型</strong></p>
<p>在微调的过程中，会冻结模型中的大部分，通常只修改分类层来预测新的标签。让我们通过一个小例子来说明，向以前一样，我们加载预训练模型resnet18，并且冻结所有参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn,optim</span><br><span class="line">model = torchvision.models.resnet18(pretrained=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 冻结网络中的所有参数</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> model.parameters():</span><br><span class="line">    param.requires_grad = <span class="literal">False</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">目的：在有10个标签的新数据集上微调模型</span></span><br><span class="line"><span class="string">resnet最后一层的线性分类器为：model.fc</span></span><br><span class="line"><span class="string">我们可以简单的使用一个新的线性层（默认未冻结）来代替它作为分类器</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">model.fc = nn.Linear(<span class="number">512</span>,<span class="number">10</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">现在除了model.fc的参数，模型的所有参数被冻结了</span></span><br><span class="line"><span class="string">只有model.fc的weights和bias来参与梯度计算</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">1e-2</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure>

<p>【注意】尽管我们在优化器中注册了所有参数，只有分类器的weights和bias计算梯度并使用梯度下降更新，<code>torch.no_grad()</code>也有同样的功能</p>
<hr>
<h2 id="5-拓展阅读"><a href="#5-拓展阅读" class="headerlink" title="5. 拓展阅读"></a>5. 拓展阅读</h2><p><strong><a target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/notes/autograd.html">in-place操作&amp;多线程autograd</a></strong></p>
<p><strong><a target="_blank" rel="noopener" href="https://colab.research.google.com/drive/1VpeE6UvEPRz9HmsHh1KS0XxXjYu533EC">反向模式autodiff的例子</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/17/tensor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="TT">
      <meta itemprop="description" content="The Journey Is the Reward">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/17/tensor/" class="post-title-link" itemprop="url">60分钟入门PyTorch——Tensor</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-17 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-17T00:00:00+08:00">2022-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 19:56:12" itemprop="dateModified" datetime="2023-09-13T19:56:12+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A-PyTorch/" itemprop="url" rel="index"><span itemprop="name">深度学习： PyTorch</span></a>
                </span>
            </span>

          
            <span id="/2022/07/17/tensor/" class="post-meta-item leancloud_visitors" data-flag-title="60分钟入门PyTorch——Tensor" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/17/tensor/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/17/tensor/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Tensor"><a href="#Tensor" class="headerlink" title="Tensor"></a>Tensor</h1><p>tensor被翻译为<strong>张量</strong>，是一种与NumPy数据和矩阵十分相似的特殊数据结构</p>
<p>在PyTorch中，我们使用tensor给模型的输入输出以及参数进行编码</p>
<p>除了可以在GPUs和其他可以加速运算的硬件上运行这一特点之外，tensors和NumPy数组非常相似</p>
<h2 id="1-初始化tensor"><a href="#1-初始化tensor" class="headerlink" title="1. 初始化tensor"></a>1. 初始化tensor</h2><h3 id="使用数据直接初始化"><a href="#使用数据直接初始化" class="headerlink" title="使用数据直接初始化"></a>使用数据直接初始化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">data = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">x_data = torch.tensor(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">tensor([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="使用NumPy-arrays初始化"><a href="#使用NumPy-arrays初始化" class="headerlink" title="使用NumPy arrays初始化"></a>使用NumPy arrays初始化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">np_array = np.array(data)</span><br><span class="line">x_np = torch.from_numpy(np_array)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">tensor([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>]], dtype=torch.int32)</span><br></pre></td></tr></table></figure>

<h3 id="使用另一个tensor创建"><a href="#使用另一个tensor创建" class="headerlink" title="使用另一个tensor创建"></a>使用另一个tensor创建</h3><p>新的tensor保留了参数tensor的一些属性（形状，数据类型），除非显式覆盖</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x_ones = torch.ones_like(x_data) <span class="comment"># 保留了x_data的属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Ones Tensor: \n <span class="subst">&#123;x_ones&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="comment"># 显示覆盖x_data的数据类型</span></span><br><span class="line">x_rand = torch.rand_like(x_data,dtype=torch.<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Random Tensor: \n <span class="subst">&#123;x_rand&#125;</span> \n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Ones Tensor: </span><br><span class="line"> tensor([[<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>]]) </span><br><span class="line"></span><br><span class="line">Random Tensor: </span><br><span class="line"> tensor([[<span class="number">0.5502</span>, <span class="number">0.3189</span>],</span><br><span class="line">        [<span class="number">0.0911</span>, <span class="number">0.7488</span>]]) </span><br></pre></td></tr></table></figure>

<h3 id="使用随机数或者常数创建tensor"><a href="#使用随机数或者常数创建tensor" class="headerlink" title="使用随机数或者常数创建tensor"></a>使用随机数或者常数创建tensor</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shape是关于tensor维度的元组，它决定输出tensor的维度</span></span><br><span class="line">shape = (<span class="number">2</span>,<span class="number">3</span>,)</span><br><span class="line"></span><br><span class="line">rand_tensor = torch.rand(shape)</span><br><span class="line">ones_tensor = torch.ones(shape)</span><br><span class="line">zeros_tensor = torch.zeros(shape)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Random Tensor: \n <span class="subst">&#123;rand_tensor&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Ones Tensor: \n <span class="subst">&#123;ones_tensor&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Zeros Tensor: \n <span class="subst">&#123;zeros_tensor&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Random Tensor:</span><br><span class="line"> tensor([[<span class="number">0.8012</span>, <span class="number">0.4547</span>, <span class="number">0.4156</span>],</span><br><span class="line">        [<span class="number">0.6645</span>, <span class="number">0.1763</span>, <span class="number">0.3860</span>]])</span><br><span class="line"></span><br><span class="line">Ones Tensor:</span><br><span class="line"> tensor([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line">Zeros Tensor:</span><br><span class="line"> tensor([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>

<h2 id="2-tensor属性"><a href="#2-tensor属性" class="headerlink" title="2. tensor属性"></a>2. tensor属性</h2><p>Tensor的属性包括形状，数据类型以及存储的设备</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tensor = torch.rand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Shape of tensor: <span class="subst">&#123;tensor.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Datatype of tensor: <span class="subst">&#123;tensor.dtype&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Device tensor is stored on: <span class="subst">&#123;tensor.device&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Shape of tensor: torch.Size([<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">Datatype of tensor: torch.float32</span><br><span class="line">Device tensor <span class="keyword">is</span> stored on: cpu</span><br></pre></td></tr></table></figure>

<h2 id="3-tensor操作"><a href="#3-tensor操作" class="headerlink" title="3. tensor操作"></a>3. tensor操作</h2><p>tensor有超过100种操作，包括转置（transposing）, 索引（indexing）,切片（ slicing）, 数学运算（mathematical operations）, 线性代数（linear algebra）,随机操作（ random sampling）等等。</p>
<p>它们都可以在GPU上运行（速度通常比CPU快），如果你使用的是Colab，通过编辑&gt;笔记本设置来分配一个GPU</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将tensor移到GPU上</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    tensor = tensor.to(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Device tensor is stored on: <span class="subst">&#123;tensor.device&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出 ：Device tensor is stored on: cuda:0</span></span><br></pre></td></tr></table></figure>

<p>尝试一些操作</p>
<h3 id="像NumPy一样标准的索引和切片"><a href="#像NumPy一样标准的索引和切片" class="headerlink" title="像NumPy一样标准的索引和切片"></a>像NumPy一样标准的索引和切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tensor = torch.ones(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">tensor[:,<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(tensor)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="连接tensor-Joining-tensors"><a href="#连接tensor-Joining-tensors" class="headerlink" title="连接tensor(Joining tensors)"></a>连接tensor(<strong>Joining tensors</strong>)</h3><p>使用torch.cat可以沿着给定的维度合并一系列tensor</p>
<p>torch.stack是另一个连接tensor的操作，和torch.cat有些许不同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t1 = torch.cat([tensor, tensor, tensor], dim=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(t1)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="tensor相乘"><a href="#tensor相乘" class="headerlink" title="tensor相乘"></a>tensor相乘</h3><p>元素层面的乘法操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tensor在元素层面的乘法操作</span></span><br><span class="line">tensor.mul(tensor)</span><br><span class="line"><span class="comment"># 和上面等价的写法</span></span><br><span class="line">tensor * tensor</span><br><span class="line"><span class="comment"># 输出 </span></span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>

<p>两个tensor之间的矩阵乘法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tensor.matmul(tensor.T)</span><br><span class="line"><span class="comment"># 等价写法</span></span><br><span class="line">tensor @ tensor.T</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">tensor([[<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="In-place操作"><a href="#In-place操作" class="headerlink" title="In-place操作"></a>In-place操作</h3><p>带有后缀<code>_</code>的操作是in_place操作，例如：<code>x.copy_(y)</code>，<code>x.t_()</code>将改变x</p>
<blockquote>
<p>in_place操作虽然会节省很多内存空间，但是会因为即刻清除历史记录在计算导数的时候可能出现问题，所以不鼓励使用这种操作方式</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(tensor, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">tensor.add_(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(tensor)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>]]) </span><br><span class="line"></span><br><span class="line">tensor([[<span class="number">6.</span>, <span class="number">5.</span>, <span class="number">6.</span>, <span class="number">6.</span>],</span><br><span class="line">        [<span class="number">6.</span>, <span class="number">5.</span>, <span class="number">6.</span>, <span class="number">6.</span>],</span><br><span class="line">        [<span class="number">6.</span>, <span class="number">5.</span>, <span class="number">6.</span>, <span class="number">6.</span>],</span><br><span class="line">        [<span class="number">6.</span>, <span class="number">5.</span>, <span class="number">6.</span>, <span class="number">6.</span>]])</span><br></pre></td></tr></table></figure>

<h2 id="4-使用Numpy作为桥梁"><a href="#4-使用Numpy作为桥梁" class="headerlink" title="4. 使用Numpy作为桥梁"></a>4. 使用Numpy作为桥梁</h2><p>在cpu上的tensor和NumPy数组可以共享基本的内存位置，<strong>改变一个就会改变另一个</strong></p>
<h3 id="tnsor转变成Numpy数组"><a href="#tnsor转变成Numpy数组" class="headerlink" title="tnsor转变成Numpy数组"></a>tnsor转变成Numpy数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t = torch.ones(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line">n = t.numpy()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">t: tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line">n: [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br></pre></td></tr></table></figure>

<p>tensor中的改变会影响到NumPy数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t.add_(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t: tensor([<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>])</span><br><span class="line">n: [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br></pre></td></tr></table></figure>

<h3 id="NumPy数组转变成tensor"><a href="#NumPy数组转变成tensor" class="headerlink" title="NumPy数组转变成tensor"></a>NumPy数组转变成tensor</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = np.ones(<span class="number">5</span>)</span><br><span class="line">t = torch.from_numpy(n)</span><br><span class="line"><span class="comment"># 在NumPy数组中的改变会影响到tensor</span></span><br><span class="line">np.add(n, <span class="number">1</span>, out=n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t: tensor([<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>], dtype=torch.float64)</span><br><span class="line">n: [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br></pre></td></tr></table></figure>

<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/23/%E5%AE%89%E8%A3%85R%E8%AF%AD%E8%A8%80%E5%92%8C%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="TT">
      <meta itemprop="description" content="The Journey Is the Reward">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/23/%E5%AE%89%E8%A3%85R%E8%AF%AD%E8%A8%80%E5%92%8C%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%8C%85/" class="post-title-link" itemprop="url">安装R语言环境和生物信息学包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-23 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-23T00:00:00+08:00">2022-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 19:56:02" itemprop="dateModified" datetime="2023-09-13T19:56:02+08:00">2023-09-13</time>
              </span>

          
            <span id="/2022/04/23/%E5%AE%89%E8%A3%85R%E8%AF%AD%E8%A8%80%E5%92%8C%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%8C%85/" class="post-meta-item leancloud_visitors" data-flag-title="安装R语言环境和生物信息学包" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/04/23/%E5%AE%89%E8%A3%85R%E8%AF%AD%E8%A8%80%E5%92%8C%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%8C%85/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/04/23/%E5%AE%89%E8%A3%85R%E8%AF%AD%E8%A8%80%E5%92%8C%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%8C%85/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>进入R语言官网：<a target="_blank" rel="noopener" href="https://www.r-project.org/">R: The R Project for Statistical Computing (r-project.org)</a></p>
<p>点击download R</p>
<img src="https://cdn.jsdelivr.net/gh/tang-colorful/Images/Images/image-20220423094715316.png" alt="image-20220423094715316" style="zoom:50%;" />
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/04/23/%E5%AE%89%E8%A3%85R%E8%AF%AD%E8%A8%80%E5%92%8C%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%8C%85/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/04/%E4%B9%9D%E3%80%81%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="TT">
      <meta itemprop="description" content="The Journey Is the Reward">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/04/%E4%B9%9D%E3%80%81%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" class="post-title-link" itemprop="url">九、绘图与可视化——《利用Python进行数据分析》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-04 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-04T00:00:00+08:00">2022-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 19:32:18" itemprop="dateModified" datetime="2023-09-13T19:32:18+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">机器学习： 数据分析</span></a>
                </span>
            </span>

          
            <span id="/2022/04/04/%E4%B9%9D%E3%80%81%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" class="post-meta-item leancloud_visitors" data-flag-title="九、绘图与可视化——《利用Python进行数据分析》" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/04/04/%E4%B9%9D%E3%80%81%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/04/04/%E4%B9%9D%E3%80%81%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第九章-绘图与可视化"><a href="#第九章-绘图与可视化" class="headerlink" title="第九章 绘图与可视化"></a>第九章 绘图与可视化</h1><blockquote>
<p>关注matplotlib和以它为基础的库</p>
<p>seaborn底层绘图</p>
</blockquote>
<p>在Jupyter notebook中使用交互式绘图，执行以下语句</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib notebook</span><br></pre></td></tr></table></figure>

<h2 id="9-1-简明matplotlib-API入门"><a href="#9-1-简明matplotlib-API入门" class="headerlink" title="9.1 简明matplotlib API入门"></a>9.1 简明matplotlib API入门</h2><ul>
<li><p>导入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
</li>
<li><p>matplotlib的<strong>可视化作品库</strong>和<strong>文档</strong>是学习高级功能的最佳资源</p>
</li>
</ul>
<h3 id="图片与子图"><a href="#图片与子图" class="headerlink" title="图片与子图"></a>图片与子图</h3><ul>
<li><p>绘制的图位于图片（Figure）对象中，plt.figure生成一个新的图片</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br></pre></td></tr></table></figure>
</li>
<li><p>add_subplot创建一个或多个子图（subplot），返回Axes Subplot对象；可以使用这些对象进行画图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图片摆放是2*2的，这是选择四个图形中的第一个</span></span><br><span class="line">ax1 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 使用对象画图</span></span><br><span class="line">_ = ax1.hist(np.random.randn(<span class="number">100</span>), bins=<span class="number">20</span>, color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.3</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><blockquote>
<p>复杂的图表操作放在单个的notebook单元格中，因为每个单元格运行后，图表被重置</p>
</blockquote>
</li>
<li><p>使用子网格图创建图片：plt.subplots</p>
<ul>
<li><p>返回包含子图对象的NumPy数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">axes</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[&lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;],</span></span><br><span class="line"><span class="string">       [&lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;]], dtype=object)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组axes可以像二维数组一样方便地进行索引，axes[0,1]</p>
</li>
<li><p>pyplot.subplots选项</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_114" alt="epub_22739904_114" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<p><strong>调整子图周围的间距</strong></p>
<ul>
<li><p>使用图对象上的<strong>subplots_adjust</strong>方法更改间距，也可以用作顶层函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wspace控制图片宽度比</span></span><br><span class="line"><span class="comment"># hspace控制图片高度比</span></span><br><span class="line">subplots_adjust(left=<span class="literal">None</span>, bottom=<span class="literal">None</span>, right=<span class="literal">None</span>,top=<span class="literal">None</span>, wspace=<span class="literal">None</span>, hspace=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>颜色、标记和线类型</strong></p>
<ul>
<li><p>matplotlib的主函数plot接收带有x和y轴的数组以及一些可选的字符串缩写参数来指明颜色和线类型，也可用<strong>十六进制颜色代码</strong>来指定颜色</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用绿色破折号绘制x对y的线</span></span><br><span class="line">ax.plot(x, y, linestyle=<span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"><span class="comment"># 简化版</span></span><br><span class="line">ax.plot(x, y, <span class="string">&#x27;g--&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>折线图用标记凸显实际数据点</p>
<ul>
<li><p>标记可以是样式字符串的一部分</p>
</li>
<li><p>线类型、标记类型必须跟在颜色后面</p>
</li>
<li><p>折线图举例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</span><br><span class="line">plt.plot(randn(<span class="number">30</span>).cumsum(), <span class="string">&#x27;ko--&#x27;</span>)</span><br><span class="line"><span class="comment"># 分开写</span></span><br><span class="line"><span class="comment"># plot(randn(30).cumsum(), color=&#x27;k&#x27;,linestyle=&#x27;dashed&#x27;, marker=&#x27;o&#x27;)</span></span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/output.png" alt="output" style="zoom:50%;" />
</li>
<li><p>使用drawstyle改变内插新式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(data, <span class="string">&#x27;k-&#x27;</span>, drawstyle=<span class="string">&#x27;steps-post&#x27;</span>,label=<span class="string">&#x27;steps-post&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_117" alt="img" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>使用<strong>plt.legend</strong>为每条线生成一个用于区分的图例</p>
<blockquote>
<p>无论你在用数据绘图时是否传递了lebel选项，你都必须调用plt.legend （如果你有轴的引用，也可以用ax.legend）来生成图例</p>
</blockquote>
</li>
</ul>
<h3 id="刻度、标签和图例"><a href="#刻度、标签和图例" class="headerlink" title="刻度、标签和图例"></a>刻度、标签和图例</h3><ul>
<li><p>两种修饰图表的方式</p>
<ul>
<li><p>程序性的matplotlib.pyplot接口</p>
<ul>
<li><p>包含了像xlim（绘图范围）、xticks（刻度位置）和xticklabels（刻度标签）等</p>
</li>
<li><p>使用方法</p>
<ul>
<li><strong>没有函数参数</strong>调用：返回当前的参数值（例如plt.xlim()返回当前的x轴绘图范围）</li>
<li><strong>传入函数参数</strong>调用，并<strong>设置参数值</strong>：（例如plt.xlim（[0, 10]）会将x轴的范围设置为0到10）</li>
</ul>
<blockquote>
<p>会在最近的AxesSubplot上生效</p>
<p>xlim对应子图自身两个方法：ax.get_lim和ax.set_lim</p>
<p>可以更显式地使用subplot子图方法</p>
</blockquote>
</li>
</ul>
</li>
<li><p>面向对象的原生matplotlib API</p>
</li>
</ul>
</li>
</ul>
<p><strong>设置标题、轴标签、刻度和刻度标签</strong></p>
<ul>
<li><p>改变轴刻度</p>
<ul>
<li><p>set_xticks：在数据范围内设定刻度的位置，默认刻度有标签</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ticks = ax.set_xticks([<span class="number">0</span>, <span class="number">250</span>, <span class="number">500</span>, <span class="number">750</span>, <span class="number">1000</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>set_xticklabels：为标签赋值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">labels = ax.set_xticklabels([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>],rotation=<span class="number">30</span>, fontsize=<span class="string">&#x27;small&#x27;</span>)</span><br><span class="line"><span class="comment"># rotation将x轴的刻度标签旋转30度</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>设置轴名称：<code>set_xlabel()</code></p>
</li>
<li><p>设置子图标题：<code>set_title()</code></p>
</li>
<li><p>批量设置绘图属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">props = &#123;</span><br><span class="line">    <span class="string">&#x27;title&#x27;</span>:<span class="string">&#x27;my first matplotlib plot&#x27;</span></span><br><span class="line">    <span class="string">&#x27;xlabel&#x27;</span>:<span class="string">&#x27;Stages&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">ax.<span class="built_in">set</span>(**props)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>添加图例</strong></p>
<ul>
<li><p>添加每个图表时传递label参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</span><br><span class="line">fig = plt.figure(); ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k&#x27;</span>, label=<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k--&#x27;</span>, label=<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k.&#x27;</span>, label=<span class="string">&#x27;three&#x27;</span>)</span><br><span class="line"><span class="comment"># 调用ax.legend()或plt.legend自动生成图例</span></span><br><span class="line"><span class="comment"># loc参数告诉matplotlib在哪里放置图表</span></span><br><span class="line">ax.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/le.png" alt="le" style="zoom:50%;" />
</li>
<li><p>取消图例：不要传入label参数或者传入<code>label=&#39;_nolegend_&#39;</code></p>
</li>
</ul>
<h3 id="注释与子图加工"><a href="#注释与子图加工" class="headerlink" title="注释与子图加工"></a>注释与子图加工</h3><ul>
<li><p>使用text、arrow和annote方法来添加注释和文本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在给定坐标(x,y)上绘制文本</span></span><br><span class="line">ax.text(x, y, <span class="string">&#x27;Hello world!&#x27;</span>,family=<span class="string">&#x27;monospace&#x27;</span>, fontsize=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>ax.annotate方法可以在指定的x和y坐标上绘制标签</p>
</li>
<li><p>matplotlib的<strong>图形全集位于matplotlib.patches</strong>，但是一些常见图形可在matplotlib.pyplot中找到。</p>
</li>
<li><p>在图表中添加图形</p>
<ul>
<li><p>生成patch（补丁）对象shp</p>
</li>
<li><p>调用<code>ax.add_patch （shp）</code>将它加入到子图中</p>
</li>
<li><p>示例代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>)); ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">rect = plt.Rectangle((<span class="number">0.2</span>, <span class="number">0.75</span>), <span class="number">0.4</span>, <span class="number">0.15</span>, color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">circ = plt.Circle((<span class="number">0.7</span>, <span class="number">0.2</span>), <span class="number">0.15</span>, color=<span class="string">&#x27;b&#x27;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">pgon = plt.Polygon([[<span class="number">0.15</span>, <span class="number">0.15</span>], [<span class="number">0.35</span>, <span class="number">0.4</span>], [<span class="number">0.2</span>, <span class="number">0.6</span>]],</span><br><span class="line">                   color=<span class="string">&#x27;g&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">ax.add_patch(rect)</span><br><span class="line">ax.add_patch(circ)</span><br><span class="line">ax.add_patch(pgon)</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果展示</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/tutu.png" alt="tutu" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<h3 id="将图片保存到文件"><a href="#将图片保存到文件" class="headerlink" title="将图片保存到文件"></a>将图片保存到文件</h3><ul>
<li><p>使用plt.savefig将图片保存到文件，文件类型根据扩展名推断</p>
<ul>
<li><p>.pdf：PDF文件</p>
</li>
<li><p>.dpi：控制每英寸点数的分辨率</p>
</li>
<li><p>bbox_inches：修剪实际图形的空白</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PNG图片，拥有最小的空白</span></span><br><span class="line">plt.savefig(<span class="string">&#x27;figpath.png&#x27;</span>, dpi=<span class="number">400</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>figure.savefig选项</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_124" alt="img" style="zoom: 50%;" /></li>
</ul>
</li>
<li><p>savefig可以写到所有文件对象中，如BytesIO()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">buffer = BytesIO()</span><br><span class="line">plt.savefig(buffer)</span><br><span class="line">plot_data = buffer.getvalue()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="matplotlib设置"><a href="#matplotlib设置" class="headerlink" title="matplotlib设置"></a>matplotlib设置</h3><blockquote>
<p>matplotlib中的配色方案和默认设置可以通过广泛的全局参数来定制</p>
</blockquote>
<ul>
<li><p>使用<strong>rc方法</strong>修改Python编程配置</p>
<ul>
<li><p>第一个参数为想要自定义的组件，比如’figure’、’axes’、’xtick’、’ytick’、’grid’、’legend’等等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.rc(<span class="string">&#x27;figure&#x27;</span>, figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用字典按照关键字参数的序列指定新参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">font_options = &#123;<span class="string">&#x27;family&#x27;</span> : <span class="string">&#x27;monospace&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;weight&#x27;</span> : <span class="string">&#x27;bold&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;size&#x27;</span>   : <span class="string">&#x27;small&#x27;</span>&#125;</span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>, **font_options)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>更深入的定制和参看全量选项</p>
<ul>
<li>参考matplotlib的设置文件matplotlibrc，该文件位于matplotlib&#x2F;mpl-data路径</li>
<li>定制文件后放在home路径下并且将文件命名为．matplotlibrc，则每次你使用matplotlib时都会读取该文件。</li>
</ul>
</li>
</ul>
<h2 id="9-2-使用pandas和seaborn绘图"><a href="#9-2-使用pandas和seaborn绘图" class="headerlink" title="9.2 使用pandas和seaborn绘图"></a>9.2 使用pandas和seaborn绘图</h2><blockquote>
<p>seaborn简化了常用可视化类型，会修改默认的matplotlib配色方案和绘图样式，提高可读性和美观性</p>
</blockquote>
<h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><ul>
<li><p>Series和DataFrame都有一个<strong>plot属性</strong>，用于绘制基本图形，默认是折线图</p>
<ul>
<li>Series的索引会作为x轴，可以传入<code>use_index=False</code>来禁用这个功能</li>
<li>DataFrame的plot方法在同一个子图中将<strong>每一列</strong>绘制为不同的折线，并自动生成图例</li>
<li>plot属性包含了不同绘图类型的方法族。例如，<code>df.plot()</code>等价于<code>df.plot.line()</code></li>
</ul>
</li>
<li><p>Series.plot方法参数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_129" alt="img" style="zoom:50%;" />
</li>
<li><p>DataFrame的plot参数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_130" alt="img" style="zoom:50%;" /></li>
</ul>
<h3 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h3><ul>
<li><p>plot.bar():垂直柱状图；plot.barh()：水平柱状图</p>
<ul>
<li><p>Series或DataFrame的索引将会被用作x轴刻度（bar）或y轴刻度（barh）</p>
</li>
<li><p>示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">data = pd.Series(np.random.rand(<span class="number">16</span>), index=<span class="built_in">list</span>(<span class="string">&#x27;abcdefghijklmnop&#x27;</span>))</span><br><span class="line">data.plot.bar(ax=axes[<span class="number">0</span>], color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line">data.plot.barh(ax=axes[<span class="number">1</span>], color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.7</span>)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/bar.png" alt="bar" style="zoom: 67%;" /></li>
</ul>
</li>
<li><p>在DataFrame中，柱状图将每一行中的值分组到并排的柱子中的一组</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220404173916617.png" alt="image-20220404173916617" style="zoom: 50%;" />
</li>
<li><p>堆积柱状图：传递<code>stacked=True</code></p>
</li>
</ul>
<blockquote>
<p>使用value_counts: s.value_counts().plot.bar()可以有效地对Series值频率进行可视化</p>
</blockquote>
<ul>
<li><p>使用seaborn绘制需要聚合和汇总的数据会更简单：seaborn.barplot</p>
<ul>
<li>data参数：可以是pandas的DataFrame</li>
<li>hue参数：通过一个额外的分类值将数据分离</li>
</ul>
</li>
<li><p>设置seaborn外观：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.<span class="built_in">set</span>(style=<span class="string">&quot;whitegrid&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="直方图和密度图"><a href="#直方图和密度图" class="headerlink" title="直方图和密度图"></a>直方图和密度图</h3><p><strong>直方图</strong></p>
<ul>
<li>定义：直方图是一种条形图，用于给出值频率的离散显示。数据点被分成离散的，均匀间隔的箱，并且绘制每个箱中数据点的数量。</li>
<li>使用Series的plot.hist方法可以绘制直方图</li>
</ul>
<p><strong>密度图</strong></p>
<ul>
<li><p>定义：通过计算可能产生观测数据的连续概率分布估计而产生，密度图也被称为内核密度估计图（KDE）。</p>
</li>
<li><p>plot.kde使用传统法定混合法估计绘制密度图</p>
</li>
<li><p>distplot方法可以绘制直方图和连续密度估计</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">comp1 = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, size=<span class="number">200</span>)</span><br><span class="line">comp2 = np.random.normal(<span class="number">10</span>, <span class="number">2</span>, size=<span class="number">200</span>)</span><br><span class="line">values = pd.Series(np.concatenate([comp1, comp2]))</span><br><span class="line">sns.distplot(values, bins=<span class="number">100</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/nn.png" alt="nn" style="zoom:50%;" /></li>
</ul>
<h3 id="散点图或点图"><a href="#散点图或点图" class="headerlink" title="散点图或点图"></a>散点图或点图</h3><blockquote>
<p>点图或散点图可以用于检验两个一维数据序列之间的关系</p>
</blockquote>
<ul>
<li><p>seaborn的regplot方法 绘制散点图并拟合一条线性回归线</p>
</li>
<li><p>seaborn的pairplot方法：支持在对角线上放置每个变量的直方图和密度估计值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plot_kws参数能够将配置选项传递给非对角元素上的各个绘图调用</span></span><br><span class="line">sns.pairplot(trans_data, diag_kind=<span class="string">&#x27;kde&#x27;</span>, plot_kws=&#123;<span class="string">&#x27;alpha&#x27;</span>: <span class="number">0.2</span>&#125;)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_143" alt="epub_22739904_143" style="zoom: 33%;" /></li>
</ul>
<h3 id="分面网格和分类数据"><a href="#分面网格和分类数据" class="headerlink" title="分面网格和分类数据"></a>分面网格和分类数据</h3><blockquote>
<p>使用分面网格是利用多种分组变量对数据进行可视化的方式</p>
</blockquote>
<ul>
<li><p>sns.factorplot()：可以简化多种分面绘图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.factorplot(x=<span class="string">&#x27;day&#x27;</span>, y=<span class="string">&#x27;tip_pct&#x27;</span>, hue=<span class="string">&#x27;time&#x27;</span>, col=<span class="string">&#x27;smoker&#x27;</span>,kind=<span class="string">&#x27;bar&#x27;</span>, data=tips[tips.tip_pct &lt; <span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_144" alt="epub_22739904_144" style="zoom:50%;" />
</li>
<li><p>可以使用seaborn.FaceGrid创建自己的分面网格图</p>
</li>
</ul>
<h2 id="9-3-其他Python可视化工具"><a href="#9-3-其他Python可视化工具" class="headerlink" title="9.3 其他Python可视化工具"></a>9.3 其他Python可视化工具</h2><ul>
<li>创建web交互式<ul>
<li>Bokeh（<a target="_blank" rel="noopener" href="http://bokeh.pydata.org/%EF%BC%89">http://bokeh.pydata.org/）</a></li>
<li>Plotly（<a target="_blank" rel="noopener" href="https://github.com/plotly/plotly.py%EF%BC%89">https://github.com/plotly/plotly.py）</a></li>
</ul>
</li>
<li>印刷或静态网页<ul>
<li>matplotlib</li>
<li>pandas</li>
<li>seaborn</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/03/%E5%85%AB%E3%80%81%E6%95%B0%E6%8D%AE%E8%A7%84%E6%95%B4%EF%BC%9A%E8%BF%9E%E6%8E%A5%E3%80%81%E8%81%94%E5%90%88%E4%B8%8E%E9%87%8D%E5%A1%91%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="TT">
      <meta itemprop="description" content="The Journey Is the Reward">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/03/%E5%85%AB%E3%80%81%E6%95%B0%E6%8D%AE%E8%A7%84%E6%95%B4%EF%BC%9A%E8%BF%9E%E6%8E%A5%E3%80%81%E8%81%94%E5%90%88%E4%B8%8E%E9%87%8D%E5%A1%91%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" class="post-title-link" itemprop="url">八、数据规整：连接、联合与重塑——《利用Python进行数据分析》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-03 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-03T00:00:00+08:00">2022-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 19:31:22" itemprop="dateModified" datetime="2023-09-13T19:31:22+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">机器学习： 数据分析</span></a>
                </span>
            </span>

          
            <span id="/2022/04/03/%E5%85%AB%E3%80%81%E6%95%B0%E6%8D%AE%E8%A7%84%E6%95%B4%EF%BC%9A%E8%BF%9E%E6%8E%A5%E3%80%81%E8%81%94%E5%90%88%E4%B8%8E%E9%87%8D%E5%A1%91%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" class="post-meta-item leancloud_visitors" data-flag-title="八、数据规整：连接、联合与重塑——《利用Python进行数据分析》" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/04/03/%E5%85%AB%E3%80%81%E6%95%B0%E6%8D%AE%E8%A7%84%E6%95%B4%EF%BC%9A%E8%BF%9E%E6%8E%A5%E3%80%81%E8%81%94%E5%90%88%E4%B8%8E%E9%87%8D%E5%A1%91%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/04/03/%E5%85%AB%E3%80%81%E6%95%B0%E6%8D%AE%E8%A7%84%E6%95%B4%EF%BC%9A%E8%BF%9E%E6%8E%A5%E3%80%81%E8%81%94%E5%90%88%E4%B8%8E%E9%87%8D%E5%A1%91%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第八章-数据规整：连接、联合与重塑"><a href="#第八章-数据规整：连接、联合与重塑" class="headerlink" title="第八章 数据规整：连接、联合与重塑"></a>第八章 数据规整：连接、联合与重塑</h1><h2 id="8-1-分层索引"><a href="#8-1-分层索引" class="headerlink" title="8.1 分层索引"></a>8.1 分层索引</h2><blockquote>
<p>分层索引允许在一个轴向上拥有多个（两个或两个以上）索引层级</p>
</blockquote>
<p><strong>Series分层索引</strong></p>
<ul>
<li><p>创建</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data = pd.Series(np.random.randn(<span class="number">9</span>),</span><br><span class="line">                 index=[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">                        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="string">&quot;&quot;&quot;输出</span></span><br><span class="line"><span class="string">a  1   -0.204708</span></span><br><span class="line"><span class="string">   2    0.478943</span></span><br><span class="line"><span class="string">   3   -0.519439</span></span><br><span class="line"><span class="string">b  1   -0.555730</span></span><br><span class="line"><span class="string">   3    1.965781</span></span><br><span class="line"><span class="string">c  1    1.393406</span></span><br><span class="line"><span class="string">   2    0.092908</span></span><br><span class="line"><span class="string">d  2    0.281746</span></span><br><span class="line"><span class="string">   3    0.769023</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>各种索引方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以MultiIndex作为索引的Series的美化视图</span></span><br><span class="line">data.index</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">MultiIndex([(&#x27;a&#x27;, 1),</span></span><br><span class="line"><span class="string">            (&#x27;a&#x27;, 2),</span></span><br><span class="line"><span class="string">            (&#x27;a&#x27;, 3),</span></span><br><span class="line"><span class="string">            (&#x27;b&#x27;, 1),</span></span><br><span class="line"><span class="string">            (&#x27;b&#x27;, 3),</span></span><br><span class="line"><span class="string">            (&#x27;c&#x27;, 1),</span></span><br><span class="line"><span class="string">            (&#x27;c&#x27;, 2),</span></span><br><span class="line"><span class="string">            (&#x27;d&#x27;, 2),</span></span><br><span class="line"><span class="string">            (&#x27;d&#x27;, 3)],</span></span><br><span class="line"><span class="string">           )</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 分层索引</span></span><br><span class="line">data[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">data[<span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">data.loc[[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b  1   -0.555730</span></span><br><span class="line"><span class="string">   3    1.965781</span></span><br><span class="line"><span class="string">d  2    0.281746</span></span><br><span class="line"><span class="string">   3    0.769023</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 在“内部”层级中进行选择</span></span><br><span class="line">data.loc[:, <span class="number">2</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    0.478943</span></span><br><span class="line"><span class="string">c    0.092908</span></span><br><span class="line"><span class="string">d    0.281746</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>DataFrame分层索引</strong></p>
<ul>
<li><p>unstack重新排列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data.unstack() <span class="comment"># 将数据在DataFrame中重新排列</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1	2	3</span></span><br><span class="line"><span class="string">a	-0.204708	0.478943	-0.519439</span></span><br><span class="line"><span class="string">b	-0.555730	NaN	1.965781</span></span><br><span class="line"><span class="string">c	1.393406	0.092908	NaN</span></span><br><span class="line"><span class="string">d	NaN	0.281746	0.769023</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">data.unstack().stack()  <span class="comment"># unstack反操作</span></span><br><span class="line"><span class="comment"># 输出结果为原来模样</span></span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403103053939.png" alt="image-20220403103053939" style="zoom:50%;" />
</li>
<li><p><em>在DataFrame中每一层都可以拥有分层索引</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),</span><br><span class="line">                     index=[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]],</span><br><span class="line">                     columns=[[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>],</span><br><span class="line">                              [<span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Red&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>]])</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403100304726.png" alt="image-20220403100304726" style="zoom:50%;" /></li>
</ul>
<p><strong>分层索引名称</strong></p>
<ul>
<li><p><em>分层的层级可以有名称（字符串或Python对象）</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">frame.index.names = [<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>]</span><br><span class="line">frame.columns.names = [<span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;color&#x27;</span>]</span><br><span class="line"></span><br><span class="line">frame[<span class="string">&#x27;Ohio&#x27;</span>]</span><br></pre></td></tr></table></figure>



<p><img src="C:/Users/TSY/Desktop/无标题.png" alt="无标题"></p>
</li>
<li><p>MultiIndex对象可以使用其<strong>自身的构造函数</strong>创建并复用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pd.MultiIndex.from_arrays([[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>], [<span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Red&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>]],</span><br><span class="line">                       names=[<span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;color&#x27;</span>])</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">MultiIndex([(    &#x27;Ohio&#x27;, &#x27;Green&#x27;),</span></span><br><span class="line"><span class="string">            (    &#x27;Ohio&#x27;,   &#x27;Red&#x27;),</span></span><br><span class="line"><span class="string">            (&#x27;Colorado&#x27;, &#x27;Green&#x27;)],</span></span><br><span class="line"><span class="string">           names=[&#x27;state&#x27;, &#x27;color&#x27;])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="重排序和层级排序"><a href="#重排序和层级排序" class="headerlink" title="重排序和层级排序"></a>重排序和层级排序</h3><blockquote>
<p>重新排列轴上的层级顺序</p>
<p>按照特定层级的值对数据进行排序</p>
</blockquote>
<ul>
<li><p>swaplevel接收两个<strong>层级序号</strong>或<strong>层级名称</strong>，返回进行层级变更的<strong>新对象</strong>（但是数据是不变的）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.swaplevel(<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403102450286.png" alt="image-20220403102450286" style="zoom:50%;" />
</li>
<li><p>sort_index只能在<strong>单一层级</strong>上进行排序，在层级变换时，可以按照层级进行<strong>字典排序</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frame.sort_index(level=<span class="number">1</span>)</span><br><span class="line">frame.swaplevel(<span class="number">0</span>, <span class="number">1</span>).sort_index(level=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/1.png" alt="1" style="zoom:50%;" />

<blockquote>
<p>按照字典最外层开始排序数据选择效果更好，调用sort_index(level&#x3D;0)或sort_index可以实现</p>
</blockquote>
</li>
</ul>
<h3 id="按层级进行汇总统计"><a href="#按层级进行汇总统计" class="headerlink" title="按层级进行汇总统计"></a>按层级进行汇总统计</h3><ul>
<li><p>在描述性和汇总性统计中使用<strong>level选项</strong>实现在特定轴上进行聚合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># level要被弃用，使用group代替</span></span><br><span class="line">frame.<span class="built_in">sum</span>(level=<span class="string">&#x27;key2&#x27;</span>)</span><br><span class="line"><span class="comment"># frame.groupby(level=&#x27;key2&#x27;).sum()</span></span><br><span class="line">frame.<span class="built_in">sum</span>(level=<span class="string">&#x27;color&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># frame.groupby(level=&#x27;color&#x27;,axis=1).sum()</span></span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/22.png" alt="22" style="zoom:50%;" /></li>
</ul>
<h3 id="使用DataFrame的列进行索引"><a href="#使用DataFrame的列进行索引" class="headerlink" title="使用DataFrame的列进行索引"></a>使用DataFrame的列进行索引</h3><ul>
<li><p>DataFrame数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>), <span class="string">&#x27;b&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>, <span class="number">0</span>, -<span class="number">1</span>),</span><br><span class="line">                      <span class="string">&#x27;c&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">                      <span class="string">&#x27;d&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403105650872.png" alt="image-20220403105650872" style="zoom:50%;" />
</li>
<li><p>DataFrame的<strong>set_index</strong>函数和<strong>reset_index</strong>函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">frame2 = frame.set_index([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">frame2</span><br><span class="line"></span><br><span class="line"><span class="comment"># set_index函数会生成一个新的DataFrame，新的DataFrame使用一个或多个列作为索引</span></span><br><span class="line"><span class="comment"># 默认这些列会从DataFrame中移除</span></span><br><span class="line">frame.set_index([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], drop=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># reset_index是set_index的反操作，分层索引的索引层级会被移动到列中</span></span><br><span class="line">frame2.reset_index()</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/re_set.png" alt="re_set" style="zoom:50%;" /></li>
</ul>
<h2 id="8-2-联合与合并数据集"><a href="#8-2-联合与合并数据集" class="headerlink" title="8.2 联合与合并数据集"></a>8.2 联合与合并数据集</h2><p><strong>pandas数据联合方式</strong></p>
<ul>
<li>pandas.merge根据一个或多个键将行进行连接，数据库的连接操作</li>
<li>pandas.concat使对象在轴向上进行黏合或“堆叠”</li>
<li>combine_first实例方法允许将重叠的数据拼接在一起，以使用一个对象中的值填充另一个对象中的缺失值</li>
</ul>
<h3 id="数据库风格的DataFrame连接"><a href="#数据库风格的DataFrame连接" class="headerlink" title="数据库风格的DataFrame连接"></a>数据库风格的DataFrame连接</h3><ul>
<li><p><strong>pandas.merge</strong>函数：将各种join操作运用在数据上</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">                    <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>)&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">                    <span class="string">&#x27;data2&#x27;</span>: <span class="built_in">range</span>(<span class="number">3</span>)&#125;)</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  key  data1</span></span><br><span class="line"><span class="string">0   b      0</span></span><br><span class="line"><span class="string">1   b      1</span></span><br><span class="line"><span class="string">2   a      2</span></span><br><span class="line"><span class="string">3   c      3</span></span><br><span class="line"><span class="string">4   a      4</span></span><br><span class="line"><span class="string">5   a      5</span></span><br><span class="line"><span class="string">6   b      6</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(df2)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  key  data2</span></span><br><span class="line"><span class="string">0   a      0</span></span><br><span class="line"><span class="string">1   b      1</span></span><br><span class="line"><span class="string">2   d      2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用merge进行多对一连接</p>
<ul>
<li><p>简单示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># merge会自动将重叠列名作为连接的键</span></span><br><span class="line">pd.merge(df1, df2)</span><br><span class="line"></span><br><span class="line">pd.merge(df1, df2, on=<span class="string">&#x27;key&#x27;</span>) <span class="comment"># 显示指定键</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">key	data1	data2</span></span><br><span class="line"><span class="string">0	b	0	1</span></span><br><span class="line"><span class="string">1	b	1	1</span></span><br><span class="line"><span class="string">2	b	6	1</span></span><br><span class="line"><span class="string">3	a	2	0</span></span><br><span class="line"><span class="string">4	a	4	0</span></span><br><span class="line"><span class="string">5	a	5	0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>merge默认内连接，只出现表的交集；有可选项’left’、’right’和’outer’（外连接是键的并集）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df3 = pd.DataFrame(&#123;<span class="string">&#x27;lkey&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">                    <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>)&#125;)</span><br><span class="line">df4 = pd.DataFrame(&#123;<span class="string">&#x27;rkey&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">                    <span class="string">&#x27;data2&#x27;</span>: <span class="built_in">range</span>(<span class="number">3</span>)&#125;)</span><br><span class="line"><span class="built_in">print</span>(df3)</span><br><span class="line"><span class="built_in">print</span>(df4)</span><br><span class="line"><span class="comment"># 指定列名</span></span><br><span class="line">pd.merge(df3, df4, left_on=<span class="string">&#x27;lkey&#x27;</span>, right_on=<span class="string">&#x27;rkey&#x27;</span>) <span class="comment"># 内连接</span></span><br><span class="line"></span><br><span class="line">pd.merge(df1, df2, how=<span class="string">&#x27;outer&#x27;</span>) <span class="comment"># 外连接</span></span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/%E5%86%85%E5%A4%96.png" alt="内外" style="zoom:50%;" />
</li>
<li><p>how参数的不同连接类型</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_103" alt="epub_22739904_103" style="zoom:67%;" /></li>
</ul>
</li>
<li><p>使用merge进行多对多连接</p>
<ul>
<li><p>多对多连接是行的笛卡尔积</p>
</li>
<li><p>使用多个键进行合并时，传入一个列名的列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(left, right, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>], how=<span class="string">&#x27;outer&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p>当你在进行列-列连接时，传递的DataFrame索引对象会被丢弃</p>
</blockquote>
<ul>
<li><p><strong>重叠列名</strong></p>
<ul>
<li><p>手动重命名轴标签</p>
</li>
<li><p><strong>merge的suffixes</strong>后缀选项：在左右两边有重叠列名时指定需要添加的字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(left, right, on=<span class="string">&#x27;key1&#x27;</span>, suffixes=(<span class="string">&#x27;_left&#x27;</span>, <span class="string">&#x27;_right&#x27;</span>))</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403114948604.png" alt="image-20220403114948604" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>merge函数参数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_105" alt="img" style="zoom: 40%;" /></li>
</ul>
<h3 id="根据索引合并"><a href="#根据索引合并" class="headerlink" title="根据索引合并"></a>根据索引合并</h3><ul>
<li><p>合并的键是它的索引，可以传递left_index&#x3D;True或right_index&#x3D;True（或者都传）来表示索引需要用来作为合并的键。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">left1 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">                      <span class="string">&#x27;value&#x27;</span>: <span class="built_in">range</span>(<span class="number">6</span>)&#125;)</span><br><span class="line">right1 = pd.DataFrame(&#123;<span class="string">&#x27;group_val&#x27;</span>: [<span class="number">3.5</span>, <span class="number">7</span>]&#125;, index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">left1</span><br><span class="line">right1</span><br><span class="line"><span class="comment"># 默认：连键相交</span></span><br><span class="line">pd.merge(left1, right1, left_on=<span class="string">&#x27;key&#x27;</span>,right_index=<span class="literal">True</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	key	value	group_val</span></span><br><span class="line"><span class="string">0	a	0	3.5</span></span><br><span class="line"><span class="string">2	a	2	3.5</span></span><br><span class="line"><span class="string">3	a	3	3.5</span></span><br><span class="line"><span class="string">1	b	1	7.0</span></span><br><span class="line"><span class="string">4	b	4	7.0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用外键进行合并</span></span><br><span class="line">pd.merge(left1, right1, left_on=<span class="string">&#x27;key&#x27;</span>, right_index=<span class="literal">True</span>, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">key	value	group_val</span></span><br><span class="line"><span class="string">0	a	0	3.5</span></span><br><span class="line"><span class="string">2	a	2	3.5</span></span><br><span class="line"><span class="string">3	a	3	3.5</span></span><br><span class="line"><span class="string">1	b	1	7.0</span></span><br><span class="line"><span class="string">4	b	4	7.0</span></span><br><span class="line"><span class="string">5	c	5	NaN</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多层索引数据：隐式的多键合并</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 必须以列表的方式指明合并所需多个列（请注意使用how=&#x27;outer’处理重复的索引值）</span></span><br><span class="line"><span class="comment"># 在多层索引数据的情况下，在索引上连接是一个隐式的多键合并</span></span><br><span class="line">pd.merge(lefth, righth, left_on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>], right_index=<span class="literal">True</span>)</span><br><span class="line">pd.merge(lefth, righth, left_on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>],</span><br><span class="line">        right_index=<span class="literal">True</span>, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line"><span class="comment"># 使用两边的索引进行合并</span></span><br><span class="line">pd.merge(left2, right2, how=<span class="string">&#x27;outer&#x27;</span>, left_index=<span class="literal">True</span>, right_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/333.png" alt="333" style="zoom:50%;" />

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/444.png" alt="444" style="zoom:50%;" />
</li>
<li><p>DataFrame的<strong>join</strong>方法：用于按照索引合并，也可用于合并<strong>多个索引相同或相似但没有重叠列</strong>的DataFrame对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">left2.join(right2, how=<span class="string">&#x27;outer&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>join方法进行<strong>左连接</strong>，完全保留左边DataFrame的行索引；支持在连接上<strong>传递索引</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">left1.koin(right1,one=<span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引-索引，向join方法传入DataFrame列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># concat方法更为通用</span></span><br><span class="line">left2.join([right2, another], how=<span class="string">&#x27;outer&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="沿轴向连接"><a href="#沿轴向连接" class="headerlink" title="沿轴向连接"></a>沿轴向连接</h3><ul>
<li><p>NumPy的concatenate函数在NumPy数组上实现拼接、绑定或堆叠</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">arr</span><br><span class="line">np.concatenate([arr, arr], axis=<span class="number">1</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[ 0,  1,  2,  3,  0,  1,  2,  3],</span></span><br><span class="line"><span class="string">       [ 4,  5,  6,  7,  4,  5,  6,  7],</span></span><br><span class="line"><span class="string">       [ 8,  9, 10, 11,  8,  9, 10, 11]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>pandas的concat函数</p>
<ul>
<li><p>假设存在三个索引不存在重叠的Series</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s1 = pd.Series([<span class="number">0</span>, <span class="number">1</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">s2 = pd.Series([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">s3 = pd.Series([<span class="number">5</span>, <span class="number">6</span>], index=[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>])</span><br><span class="line"><span class="comment"># 使用concat连接 ，默认沿着axis=0的轴向生效的</span></span><br><span class="line">pd.concat([s1, s2, s3])</span><br><span class="line"><span class="comment"># 传递axis=1，返回的结果则是一个DataFrame（axis=1时是列）</span></span><br><span class="line">pd.concat([s1, s2, s3], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/heb.png" alt="heb" style="zoom:50%;" />
</li>
<li><p>有重叠轴</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s4 = pd.concat([s1, s3])</span><br><span class="line">pd.concat([s1, s4], axis=<span class="number">1</span>)</span><br><span class="line">pd.concat([s1, s4], axis=<span class="number">1</span>, join=<span class="string">&#x27;inner&#x27;</span>) <span class="comment"># 标签f和g消失</span></span><br><span class="line">s4</span><br><span class="line"><span class="string">&quot;&quot;&quot;s4</span></span><br><span class="line"><span class="string">a    0</span></span><br><span class="line"><span class="string">b    1</span></span><br><span class="line"><span class="string">f    5</span></span><br><span class="line"><span class="string">g    6</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在连接轴上建立<strong>多层索引</strong>，使用参数<strong>keys</strong>来实现：区分连接前的各部分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">result = pd.concat([s1, s1, s3], keys=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])</span><br><span class="line">result</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">one    a    0</span></span><br><span class="line"><span class="string">       b    1</span></span><br><span class="line"><span class="string">two    a    0</span></span><br><span class="line"><span class="string">       b    1</span></span><br><span class="line"><span class="string">three  f    5</span></span><br><span class="line"><span class="string">       g    6</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>沿着轴向axis&#x3D;1连接Series的时候，keys则成为DataFrame的列头</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat([s1, s2, s3], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403140431340.png" alt="image-20220403140431340" style="zoom:50%;" />
</li>
<li><p>Series扩展到DataFrame对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>, <span class="number">2</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">                   columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame(<span class="number">5</span> + np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>, <span class="number">2</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">                   columns=[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">pd.concat([df1, df2], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;level1&#x27;</span>, <span class="string">&#x27;level2&#x27;</span>])</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403140557533.png" alt="image-20220403140557533" style="zoom:50%;" />
</li>
<li><p>如果传递字典，字典的键会用于keys选项</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat(&#123;<span class="string">&#x27;level1&#x27;</span>: df1, <span class="string">&#x27;level2&#x27;</span>: df2&#125;, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用names参数生成轴层级</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat([df1, df2], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;level1&#x27;</span>, <span class="string">&#x27;level2&#x27;</span>],names=[<span class="string">&#x27;upper&#x27;</span>, <span class="string">&#x27;lower&#x27;</span>])</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403140811873.png" alt="image-20220403140811873" style="zoom:50%;" />
</li>
<li><p>行索引中不包含任何相关数据的DataFrame，传入<code>ignore_index = True</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>concat函数的参数（join_axes好像已经弃用）</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_106" alt="img" style="zoom:50%;" /></li>
</ul>
<h3 id="联合重叠数据"><a href="#联合重叠数据" class="headerlink" title="联合重叠数据"></a>联合重叠数据</h3><p>展示几种数据有重叠部分的情况</p>
<ul>
<li><p>NumPy的where函数，面向数组的if-else等价操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = pd.Series([np.nan, <span class="number">2.5</span>, np.nan, <span class="number">3.5</span>, <span class="number">4.5</span>, np.nan],</span><br><span class="line">              index=[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">b = pd.Series(np.arange(<span class="built_in">len</span>(a), dtype=np.float64),</span><br><span class="line">              index=[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">b[-<span class="number">1</span>] = np.nan</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">np.where(pd.isnull(a), b, a)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403142053075.png" alt="image-20220403142053075" style="zoom:50%;" />
</li>
<li><p>Series的<strong>combine_first</strong>方法，类似于pandas常见的数据对齐逻辑的轴向操作；针对DataFrame逐列做相同的操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.combine_first(a)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-3-重塑和透视"><a href="#8-3-重塑和透视" class="headerlink" title="8.3 重塑和透视"></a>8.3 重塑和透视</h2><blockquote>
<p>重排列表格型数据的操作被称为重塑或透视</p>
</blockquote>
<h3 id="使用多层索引进行重塑"><a href="#使用多层索引进行重塑" class="headerlink" title="使用多层索引进行重塑"></a>使用多层索引进行重塑</h3><p><strong>两个基础操作</strong></p>
<ul>
<li>**stack(堆叠)**：该操作会“旋转”或将列中的数据透视到行</li>
<li>**unstack(拆堆)**：该操作会将行中的数据透视到列</li>
</ul>
<p><strong>例子说明</strong></p>
<ul>
<li><p>效果演示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(np.arange(<span class="number">6</span>).reshape((<span class="number">2</span>, <span class="number">3</span>)),</span><br><span class="line">                    index=pd.Index([<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>], name=<span class="string">&#x27;state&#x27;</span>),</span><br><span class="line">                    columns=pd.Index([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">                    name=<span class="string">&#x27;number&#x27;</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">number	one	two	three</span></span><br><span class="line"><span class="string">state			</span></span><br><span class="line"><span class="string">Ohio	0	1	2</span></span><br><span class="line"><span class="string">Colorado	3	4	5</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 用stack方法会将列透视到行，产生一个新的Series</span></span><br><span class="line">result = data.stack()</span><br><span class="line">result</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">state     number</span></span><br><span class="line"><span class="string">Ohio      one       0</span></span><br><span class="line"><span class="string">          two       1</span></span><br><span class="line"><span class="string">          three     2</span></span><br><span class="line"><span class="string">Colorado  one       3</span></span><br><span class="line"><span class="string">          two       4</span></span><br><span class="line"><span class="string">          three     5</span></span><br><span class="line"><span class="string">dtype: int32</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 使用unstack方法将数据重排列后放入一个DataFrame中</span></span><br><span class="line">result.unstack() <span class="comment"># 还原</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>默认最内层是已拆堆的，可以传入<strong>层级序号或名称</strong>来拆分一个不同的层级</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result.unstack(<span class="number">0</span>) <span class="comment"># 传入序号来拆分不同的层级</span></span><br><span class="line">result.unstack(<span class="string">&#x27;state&#x27;</span>) <span class="comment"># 传入名称来拆分不同的层级</span></span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403174621301.png" alt="image-20220403174621301" style="zoom:50%;" />
</li>
<li><p>拆堆可能会引入缺失值，堆叠会过滤出缺失值，两个操作可逆</p>
</li>
<li><p>在DataFrame中拆堆时，被拆堆的层级会变为结果中最低的层级</p>
</li>
<li><p>在调用stack方法时，我们可以指明需要堆叠的轴向名称</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.unstack(<span class="string">&#x27;state&#x27;</span>).stack(<span class="string">&#x27;side&#x27;</span>)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403175303626.png" alt="image-20220403175303626" style="zoom:50%;" /></li>
</ul>
<h3 id="将“长”透视为“宽”"><a href="#将“长”透视为“宽”" class="headerlink" title="将“长”透视为“宽”"></a>将“长”透视为“宽”</h3><blockquote>
<p>在数据库和CSV中存储多时间序列的方式就是所谓的长格式或堆叠格式</p>
</blockquote>
<ul>
<li><p>使用PeriodIndex将数据处理后形成Idata</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403183953595.png" alt="image-20220403183953595" style="zoom:50%;" />

<p>多时间序列的长格式，或具有两个或更多个键的数据（键date和item）</p>
</li>
<li><p>使用DataFrame的<strong>pivot方法</strong>将数据处理为按date列时间戳进行索引且每个不同的item独立为一列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前两个值是分别用作行和列索引的列</span></span><br><span class="line"><span class="comment"># 然后是可选的数值列以填充DataFrame</span></span><br><span class="line">pivoted = ldata.pivot(<span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;item&#x27;</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">pivoted</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403184419500.png" alt="image-20220403184419500" style="zoom:50%;" />
</li>
<li><p>同时重塑两个数值列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldata[<span class="string">&#x27;value2&#x27;</span>] = np.random.randn(<span class="built_in">len</span>(ldata))</span><br><span class="line">ldata[:<span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403184717460.png" alt="image-20220403184717460" style="zoom:50%;" />

<p>遗漏最后一个参数，你会得到一个含有多层列的DataFrame</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pivoted = ldata.pivot(<span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;item&#x27;</span>)</span><br><span class="line">pivoted[:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403184906941.png" alt="image-20220403184906941" style="zoom:50%;" />
</li>
<li><p>pivot方法等价于使用set_index创建分层索引，然后调用unstack</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unstacked = ldata.set_index([<span class="string">&#x27;date&#x27;</span>,<span class="string">&#x27;item&#x27;</span>]).unstack(<span class="string">&#x27;item&#x27;</span>)</span><br><span class="line">unstacked[:<span class="number">7</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="将“宽”透视为“长”"><a href="#将“宽”透视为“长”" class="headerlink" title="将“宽”透视为“长”"></a>将“宽”透视为“长”</h3><blockquote>
<p>DataFrame的pivot方法的反操作：pandas.melt，将多列合并成一列，产生一个新的DataFrame</p>
</blockquote>
<ul>
<li><p>数据<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403190157927.png" alt="image-20220403190157927" style="zoom:50%;" /></p>
</li>
<li><p>‘key’列可以作为分组指标，其他列均为数据值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">melted = pd.melt(df, [<span class="string">&#x27;key&#x27;</span>])</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403190300797.png" alt="image-20220403190300797" style="zoom:50%;" />
</li>
<li><p>使用pivot方法可以重回原来布局</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reshaped = melted.pivot(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;variable&#x27;</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line"><span class="comment"># pivot的结果根据作为行标签的列生成了索引</span></span><br><span class="line"><span class="comment"># 使用reset_index来将数据回移一列</span></span><br><span class="line">reshaped.reset_index()</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/1111.png" alt="1111" style="zoom:50%;" />
</li>
<li><p>可以指定列的子集作为值列，也可以无须任何分组指标</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定列的子集作为值列</span></span><br><span class="line">pd.melt(df, id_vars=[<span class="string">&#x27;key&#x27;</span>], value_vars=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line"><span class="comment"># 无须任何分组指标直接使用</span></span><br><span class="line">pd.melt(df, value_vars=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>])</span><br><span class="line">pd.melt(df, value_vars=[<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/29/%E4%B8%83%E3%80%81%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E5%87%86%E5%A4%87%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="TT">
      <meta itemprop="description" content="The Journey Is the Reward">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/29/%E4%B8%83%E3%80%81%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E5%87%86%E5%A4%87%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" class="post-title-link" itemprop="url">七、数据清洗与准备——《利用Python进行数据分析》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-29 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-29T00:00:00+08:00">2022-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 19:33:02" itemprop="dateModified" datetime="2023-09-13T19:33:02+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">机器学习： 数据分析</span></a>
                </span>
            </span>

          
            <span id="/2022/03/29/%E4%B8%83%E3%80%81%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E5%87%86%E5%A4%87%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" class="post-meta-item leancloud_visitors" data-flag-title="七、数据清洗与准备——《利用Python进行数据分析》" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/29/%E4%B8%83%E3%80%81%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E5%87%86%E5%A4%87%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/29/%E4%B8%83%E3%80%81%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E5%87%86%E5%A4%87%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第七章-数据清洗与准备"><a href="#第七章-数据清洗与准备" class="headerlink" title="第七章 数据清洗与准备"></a>第七章 数据清洗与准备</h1><blockquote>
<p>讨论用于缺失值、重复值、字符串操作和其他分析数据转换的工具</p>
</blockquote>
<h2 id="7-1-处理缺失值"><a href="#7-1-处理缺失值" class="headerlink" title="7.1  处理缺失值"></a>7.1  处理缺失值</h2><blockquote>
<p>pandas对象的所有描述性统计信息默认情况下是排除缺失值的</p>
</blockquote>
<ul>
<li><p>对于数值型数据，pandas使用浮点值NaN（Not a Number来表示缺失值）</p>
<ul>
<li>NA（not available，不可用）</li>
<li>Python内建的None值在对象数组中也被当作NA处理</li>
</ul>
</li>
<li><p>NA处理方法</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_91" alt="epub_22739904_91" style="zoom:50%;" /></li>
</ul>
<h3 id="过滤缺失值"><a href="#过滤缺失值" class="headerlink" title="过滤缺失值"></a>过滤缺失值</h3><ul>
<li><p>过滤缺失值方法</p>
<ul>
<li><p>使用pandas.isnull和布尔值索引</p>
</li>
<li><p>使用dropna</p>
<ul>
<li><p>在Series上使用，会返回Series中所有的非空数据及其索引值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> nan <span class="keyword">as</span> NA</span><br><span class="line">data = pd.Series([<span class="number">1</span>,NA,<span class="number">3.5</span>,NA,<span class="number">7</span>])</span><br><span class="line">data.dropna()</span><br></pre></td></tr></table></figure>

<p>等价表示：<code>data[data.notnull()]</code></p>
</li>
<li><p>处理DataFrame对象时，dropna默认删除包含缺失值的<strong>行</strong></p>
<ul>
<li><p>传入how&#x3D;’all’时，将删除所有值均为NA的行</p>
</li>
<li><p>删除列，传入参数axis&#x3D;1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.dropna(axis=<span class="number">1</span>,how=<span class="string">&#x27;all&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用thresh参数保留一定数量的观察值的行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.dropna(thresh=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="补全缺失值"><a href="#补全缺失值" class="headerlink" title="补全缺失值"></a>补全缺失值</h3><ul>
<li><p>使用fillna方法来补全缺失值</p>
<ul>
<li>可以使用一个常数来代替缺失值：<code>df.fillna(0)</code></li>
<li>调用时使用<strong>字典</strong>来为不同<strong>列</strong>设定不同的填充值：<code>df.fillna(&#123;1:0,2:0&#125;)</code></li>
<li>fillna返回一个新对象，也可以修改意见存在的对象：<code>df.fillna(0,inplace=True)</code></li>
<li>用于重建索引的相同的插值方法也可以用于fillna：<code>df.fillna(method=‘ffill’,limit=2)</code></li>
<li>使用fillna完成创造性填充：<code>data.fillna(data.mean())</code></li>
</ul>
</li>
<li><p>fillna函数参数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_92" alt="img" style="zoom:50%;" /></li>
</ul>
<h2 id="7-2-数据转换"><a href="#7-2-数据转换" class="headerlink" title="7.2 数据转换"></a>7.2 数据转换</h2><h3 id="删除重复值"><a href="#删除重复值" class="headerlink" title="删除重复值"></a>删除重复值</h3><ul>
<li><p>有些数据会出现<strong>重复行</strong></p>
<ul>
<li><p>DataFrame的duplicated方法返回一个布尔值的Series，反映每一行是否与之前出现过相同的行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(&#123;<span class="string">&#x27;k1&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>] * <span class="number">3</span> + [<span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">                     <span class="string">&#x27;k2&#x27;</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]&#125;)</span><br><span class="line">data</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	k1	k2</span></span><br><span class="line"><span class="string">0	one	1</span></span><br><span class="line"><span class="string">1	two	1</span></span><br><span class="line"><span class="string">2	one	2</span></span><br><span class="line"><span class="string">3	two	3</span></span><br><span class="line"><span class="string">4	one	3</span></span><br><span class="line"><span class="string">5	two	4</span></span><br><span class="line"><span class="string">6	two	4</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">data.duplicated()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0    False</span></span><br><span class="line"><span class="string">1    False</span></span><br><span class="line"><span class="string">2    False</span></span><br><span class="line"><span class="string">3    False</span></span><br><span class="line"><span class="string">4    False</span></span><br><span class="line"><span class="string">5    False</span></span><br><span class="line"><span class="string">6     True</span></span><br><span class="line"><span class="string">dtype: bool</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>drop_duplicates返回duplicated返回数组中为False的部分，格式为DataFrame</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data.drop_duplicates()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	k1	k2</span></span><br><span class="line"><span class="string">0	one	1</span></span><br><span class="line"><span class="string">1	two	1</span></span><br><span class="line"><span class="string">2	one	2</span></span><br><span class="line"><span class="string">3	two	3</span></span><br><span class="line"><span class="string">4	one	3</span></span><br><span class="line"><span class="string">5	two	4</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法默认针对<strong>列</strong>，可以指定数据的子集来检测是否有重复</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设有一个额外的列，并想基于’k1’列去除重复值</span></span><br><span class="line">data[<span class="string">&#x27;v1&#x27;</span>] = <span class="built_in">range</span>(<span class="number">7</span>)</span><br><span class="line">data.drop_duplicates([<span class="string">&#x27;k1&#x27;</span>])</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">k1	k2	v1</span></span><br><span class="line"><span class="string">0	one	1	0</span></span><br><span class="line"><span class="string">1	two	1	1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>【注意】</strong>：uplicated和drop_duplicates默认都是保留第一个观测到的值。传入参数keep&#x3D;’last’将会返回最后一个</p>
</li>
</ul>
</li>
</ul>
<h3 id="使用函数或映射进行数据转换"><a href="#使用函数或映射进行数据转换" class="headerlink" title="使用函数或映射进行数据转换"></a>使用函数或映射进行数据转换</h3><blockquote>
<p>基于DataFrame中的数组、列或列中的数值进行一些转换</p>
<p>map是一种可以便捷执行按元素转换及其他清洗相关操作的方法</p>
</blockquote>
<p>收集到的基于肉类的假设数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(&#123;<span class="string">&#x27;food&#x27;</span>: [<span class="string">&#x27;bacon&#x27;</span>, <span class="string">&#x27;pulled pork&#x27;</span>, <span class="string">&#x27;bacon&#x27;</span>,</span><br><span class="line">                              <span class="string">&#x27;Pastrami&#x27;</span>, <span class="string">&#x27;corned beef&#x27;</span>, <span class="string">&#x27;Bacon&#x27;</span>,</span><br><span class="line">                              <span class="string">&#x27;pastrami&#x27;</span>, <span class="string">&#x27;honey ham&#x27;</span>, <span class="string">&#x27;nova lox&#x27;</span>],</span><br><span class="line">                     <span class="string">&#x27;ounces&#x27;</span>: [<span class="number">4</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329161532043.png" alt="image-20220329161532043" style="zoom: 50%;" />

<ul>
<li><p>添加一列用于表明每种食物的动物肉类型，先写下一个食物和肉类的映射</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">meat_to_animal = &#123;</span><br><span class="line">  <span class="string">&#x27;bacon&#x27;</span>: <span class="string">&#x27;pig&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pulled pork&#x27;</span>: <span class="string">&#x27;pig&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pastrami&#x27;</span>: <span class="string">&#x27;cow&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;corned beef&#x27;</span>: <span class="string">&#x27;cow&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;honey ham&#x27;</span>: <span class="string">&#x27;pig&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;nova lox&#x27;</span>: <span class="string">&#x27;salmon&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Series的str.lower方法将每个值都转换为小写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lowercased = data[<span class="string">&#x27;food&#x27;</span>].<span class="built_in">str</span>.lower()</span><br></pre></td></tr></table></figure>
</li>
<li><p>Series的map方法接收<strong>一个函数</strong>或<strong>一个包含映射关系</strong>的<strong>字典型对象</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">&#x27;animal&#x27;</span>] = lowercased.<span class="built_in">map</span>(meat_to_animal)</span><br><span class="line">data</span><br></pre></td></tr></table></figure></li>
</ul>
<p>总结：传入一个能够完成所有工作的函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">&#x27;food&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: meat_to_animal[x.lower()])</span><br></pre></td></tr></table></figure>

<h3 id="替代值"><a href="#替代值" class="headerlink" title="替代值"></a>替代值</h3><ul>
<li>使用replace方法更灵活地替代缺失值：<code>data.replace(-999,np.nan)</code></li>
<li>一次替代多个值，传入一个列表和一个替代值：<code>data.replace([-999,-1000],np.nan)</code></li>
<li>将不同的值替换为不同的值，可以传入替代值的列表:<code>data.replace([-999, -1000], [np.nan, 0])</code>；也可通过字典传递：<code>data.replace(&#123;-999: np.nan, -1000: 0&#125;)</code></li>
</ul>
<blockquote>
<p>data.replace方法与data.str.replace方法是不同的</p>
<p>data.str. replace是对字符串进行按元素替代的</p>
</blockquote>
<h3 id="重命名轴索引"><a href="#重命名轴索引" class="headerlink" title="重命名轴索引"></a>重命名轴索引</h3><p>数据</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329163415871.png" alt="image-20220329163415871" style="zoom:50%;" />

<ul>
<li><p>修改轴</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transform = <span class="keyword">lambda</span> x : x[:<span class="number">4</span>].upper() </span><br><span class="line">data.index.<span class="built_in">map</span>(transform)</span><br><span class="line"><span class="comment"># Index([&#x27;OHIO&#x27;, &#x27;COLO&#x27;, &#x27;NEW &#x27;], dtype=&#x27;object&#x27;)</span></span><br><span class="line"><span class="comment"># 赋值给index，修改DataFrame</span></span><br><span class="line">data.index = data.index.<span class="built_in">map</span>(transform)</span><br><span class="line">data</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329163828079.png" alt="image-20220329163828079" style="zoom:50%;" />
</li>
<li><p><strong>rename</strong>：创建数据集转换后的版本，并且不修改原有的数据集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data.rename(index=<span class="built_in">str</span>.title,columns=<span class="built_in">str</span>.upper)</span><br><span class="line"><span class="comment"># rename可以结合字典型对象使用，为轴标签的子集提供新的值</span></span><br><span class="line">data.rename(index=&#123;<span class="string">&#x27;OHIO&#x27;</span>:<span class="string">&#x27;INDIANA&#x27;</span>&#125;,</span><br><span class="line">            columns=&#123;<span class="string">&#x27;three&#x27;</span>:<span class="string">&#x27;peekaboo&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>想要修改原有的数据，传入<code>inplace=True</code></p>
</li>
</ul>
<h3 id="离散化和分箱"><a href="#离散化和分箱" class="headerlink" title="离散化和分箱"></a>离散化和分箱</h3><blockquote>
<p>连续值经常需要离散化，或者分离成”箱子“进行分析</p>
</blockquote>
<p>假设研究一组人群的数据，将他们进行分组，放入离散的年龄框中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages = [<span class="number">20</span>, <span class="number">22</span>, <span class="number">25</span>, <span class="number">27</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">37</span>, <span class="number">31</span>, <span class="number">61</span>, <span class="number">45</span>, <span class="number">41</span>, <span class="number">32</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用<strong>pandas中的cut</strong>将这些年龄分为18～25、26～35、36～60以及61及以上等若干组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bins = [<span class="number">18</span>,<span class="number">25</span>,<span class="number">35</span>,<span class="number">60</span>,<span class="number">100</span>]</span><br><span class="line">cats = pd.cut(ages,bins)</span><br><span class="line">cats <span class="comment"># 特殊的Categorical对象</span></span><br></pre></td></tr></table></figure>

<p>返回值：一个特殊的Categorical对象，可当作表示箱名字的字符串数组，在内部包含一个categories（类别）数组，指定了不同的类别名称以及codes属性的ages（年龄）数据标签</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cats.codes</span><br><span class="line"><span class="comment"># array([0, 0, 0, 1, 0, 0, 2, 1, 3, 2, 2, 1], dtype=int8)</span></span><br><span class="line">cats.categories</span><br><span class="line"><span class="comment"># IntervalIndex([(18, 25], (25, 35], (35, 60], (60, 100]], dtype=&#x27;interval[int64, right]&#x27;)</span></span><br><span class="line">pd.value_counts(cats) <span class="comment"># 对pandas.cut的结果中的箱数量的计数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>小括号表示边开放，中括号表示封闭；通过传递right&#x3D;False来改变哪一边是封闭的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.cut(ages,[<span class="number">18</span>,<span class="number">26</span>,<span class="number">36</span>,<span class="number">61</span>,<span class="number">100</span>],right=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>向labels选项传递一个列表或数组来传入自定义的箱名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">group_names = [<span class="string">&#x27;Youth&#x27;</span>, <span class="string">&#x27;YoungAdult&#x27;</span>, <span class="string">&#x27;MiddleAged&#x27;</span>, <span class="string">&#x27;Senior&#x27;</span>]</span><br><span class="line">pd.cut(ages, bins, labels=group_names)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[18, 26), [18, 26), [18, 26), [26, 36), [18, 26), ..., [26, 36), [61, 100), [36, 61), [36, 61), [26, 36)]</span></span><br><span class="line"><span class="string">Length: 12</span></span><br><span class="line"><span class="string">Categories (4, interval[int64, left]): [[18, 26) &lt; [26, 36) &lt; [36, 61) &lt; [61, 100)]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传给cut整数个的箱来代替显示的箱边，自动根据数据最值计算等长的箱</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 均匀分布的数据被切成四份</span></span><br><span class="line">data = np.random.rand(<span class="number">20</span>)</span><br><span class="line">pd.cut(data,<span class="number">4</span>,precision=<span class="number">2</span>) <span class="comment"># precision=2将十进制精度限制在两位</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>qcut基于样本分位数进行分箱，可以使用qcut获得等长的箱</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.randn(<span class="number">1000</span>)  <span class="comment"># Normally distributed</span></span><br><span class="line">cats = pd.qcut(data, <span class="number">4</span>)  <span class="comment"># Cut into quartiles</span></span><br><span class="line">cats</span><br><span class="line">pd.value_counts(cats) <span class="comment"># 每个箱数量都是250</span></span><br></pre></td></tr></table></figure>

<p>可以传入自定义的分位数（0和1之间的数据，包括边）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.qcut(data, [<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">0.9</span>, <span class="number">1.</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="检测和过滤异常值"><a href="#检测和过滤异常值" class="headerlink" title="检测和过滤异常值"></a>检测和过滤异常值</h3><ul>
<li><p>举例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 具有正态分布数据的DataFrame</span></span><br><span class="line">data = pd.DataFrame(np.random.randn(<span class="number">1000</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment"># 假设你想要找出一列中绝对值大于三的值</span></span><br><span class="line">col = data[<span class="number">2</span>]</span><br><span class="line">col[np.<span class="built_in">abs</span>(col) &gt; <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 选出所有值大于3或小于-3的行，对布尔值DataFrame使用any方法</span></span><br><span class="line">data[(np.<span class="built_in">abs</span>(data)&gt;<span class="number">3</span>).<span class="built_in">any</span>(<span class="number">1</span>)]</span><br><span class="line"><span class="comment"># 限制-3到3之间的数值</span></span><br><span class="line">data[np.<span class="built_in">abs</span>(data)&gt;<span class="number">3</span>] = np.sign(data) * <span class="number">3</span></span><br><span class="line">data.describe()</span><br></pre></td></tr></table></figure>
</li>
<li><p>np.sign(data)根据数据中的值的正负分别生成1和-1的数值：<code>np.sign(data).head()</code></p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329185902275.png" alt="image-20220329185902275" style="zoom:50%;" /></li>
</ul>
<h3 id="置换和随机抽样"><a href="#置换和随机抽样" class="headerlink" title="置换和随机抽样"></a>置换和随机抽样</h3><blockquote>
<p>使用numpy.random.permutation对DataFrame中的Series或行进行置换（随机重排序）是非常方便的</p>
</blockquote>
<ul>
<li><p>调用permutation时可根据轴长度产生一个新顺序的整数数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.arange(<span class="number">5</span>*<span class="number">4</span>).reshape((<span class="number">5</span>,<span class="number">4</span>)))</span><br><span class="line">sampler = np.random.permutation(<span class="number">5</span>)</span><br><span class="line">sampler <span class="comment"># array([1, 4, 3, 2, 0])</span></span><br><span class="line"><span class="comment"># 整数数组可以用在基于iloc的索引或等价的take函数中</span></span><br><span class="line">df.take(sampler)</span><br></pre></td></tr></table></figure>
</li>
<li><p>选出不含有替代值的随机子集，可以使用sample方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df.sample(n=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 生成带有替代值的样本（允许有重复选择），将replace=True传入sample方法</span></span><br><span class="line">choices = pd.Series([<span class="number">5</span>,<span class="number">7</span>,-<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>])</span><br><span class="line">draws = choices.sample(n=<span class="number">10</span>,replace=<span class="literal">True</span>)</span><br><span class="line">draws</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="计算指标、虚拟变量"><a href="#计算指标、虚拟变量" class="headerlink" title="计算指标、虚拟变量"></a>计算指标、虚拟变量</h3><blockquote>
<p>将分类变量转换为“虚拟”或“指标”矩阵</p>
</blockquote>
<ul>
<li><p>如果DataFrame中的一列有k个不同的值，则可以衍生一个k列的值为1和0的矩阵或DataFrame（pandas有一个<strong>get_dummies函数</strong>用于实现该功能）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">6</span>)&#125;)</span><br><span class="line">pd.get_dummies(df[<span class="string">&#x27;key&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在指标DataFrame的列上加入前缀，然后与其他数据合并</span></span><br><span class="line">dummies = pd.get_dummies(df[<span class="string">&#x27;key&#x27;</span>], prefix=<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">df_with_dummy = df[[<span class="string">&#x27;data1&#x27;</span>]].join(dummies)</span><br><span class="line">df_with_dummy</span><br></pre></td></tr></table></figure>

<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329194222196.png" alt="image-20220329194222196" style="zoom:50%;" /><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329194345505.png" alt="image-20220329194345505" style="zoom:50%;" /></p>
</li>
<li><p>多成员构建指标变量</p>
<ul>
<li><p>DataFrame中的一行属于多个类别，则情况略为复杂</p>
<ul>
<li><p>每个电影流派添加指标变量</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329202000815.png" alt="image-20220329202000815" style="zoom:50%;" />
</li>
<li><p>取出所有不同的流派的列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">all_genres = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> movies.genres:</span><br><span class="line">    all_genres.extend(x.split(<span class="string">&#x27;|&#x27;</span>))</span><br><span class="line">genres = pd.unique(all_genres)</span><br><span class="line">genres</span><br></pre></td></tr></table></figure>
</li>
<li><p>用全0的DataFrame构建指标</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">zero_matrix = np.zeros((<span class="built_in">len</span>(movies),<span class="built_in">len</span>(genres)))</span><br><span class="line">dummies = pd.DataFrame(zero_matrix,columns=genres)</span><br><span class="line"><span class="comment"># 遍历每一部电影，将dummies每一行的条目设置为1</span></span><br><span class="line"><span class="comment"># 使用dummies.columns来计算每一个流派的列指标</span></span><br><span class="line">gen = movies.genres[<span class="number">0</span>]</span><br><span class="line">gen.split(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">dummies.columns.get_indexer(gen.split(<span class="string">&#x27;|&#x27;</span>))</span><br><span class="line"><span class="comment"># array([0, 1, 2], dtype=int64)</span></span><br><span class="line"><span class="keyword">for</span> i,gen <span class="keyword">in</span> <span class="built_in">enumerate</span>(movies.genres):</span><br><span class="line">    indices = dummies.columns.get_indexer(gen.split(<span class="string">&#x27;|&#x27;</span>))</span><br><span class="line">    dummies.iloc[i,indices] = <span class="number">1</span></span><br><span class="line"><span class="comment"># 将结果与movies进行联合</span></span><br><span class="line">movies_windic = movies.join(dummies.add_prefix(<span class="string">&#x27;Genre_&#x27;</span>))</span><br><span class="line">movies_windic.iloc[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329203834522.png" alt="image-20220329203834522" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>对于大数据的快速方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接将数据写为NumPy数组的底层函数，然后将结果封装进DataFrame</span></span><br><span class="line"><span class="comment"># get_dummies与cut等离散化函数结合使用</span></span><br><span class="line">np.random.seed(<span class="number">12345</span>) <span class="comment"># 置随机种子以确保示例的确定性</span></span><br><span class="line">values = np.random.rand(<span class="number">10</span>)</span><br><span class="line">values</span><br><span class="line"><span class="comment"># array([0.92961609, 0.31637555, 0.18391881, 0.20456028, 0.56772503,</span></span><br><span class="line"><span class="comment">#       0.5955447 , 0.96451452, 0.6531771 , 0.74890664, 0.65356987])</span></span><br><span class="line">bins = [<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1</span>]</span><br><span class="line">pd.get_dummies(pd.cut(values, bins))</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329195456052.png" alt="image-20220329195456052" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<h2 id="7-3-字符串操作"><a href="#7-3-字符串操作" class="headerlink" title="7.3 字符串操作"></a>7.3 字符串操作</h2><blockquote>
<p>pandas允许你将字符串和正则表达式简洁地应用到整个数组上</p>
<p>还能处理缺失值带来的困扰</p>
</blockquote>
<h3 id="字符串对象方法"><a href="#字符串对象方法" class="headerlink" title="字符串对象方法"></a>字符串对象方法</h3><ul>
<li><p>一个逗号分隔的字符串可以使用split方法拆分成多块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val = <span class="string">&#x27;a,b, guido&#x27;</span></span><br><span class="line">val.split(<span class="string">&#x27;,&#x27;</span>) <span class="comment">#val = &#x27;a,b, guido&#x27;a</span></span><br></pre></td></tr></table></figure>

<p>split常和strip一起使用，用于清除空格（包括换行）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val = <span class="string">&#x27;a,b, guido&#x27;</span></span><br><span class="line">val.split(<span class="string">&#x27;,&#x27;</span>) <span class="comment">#val = &#x27;a,b, guido&#x27;a</span></span><br><span class="line">pieces = [x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> val.split(<span class="string">&#x27;,&#x27;</span>)]</span><br><span class="line">pieces <span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;guido&#x27;]</span></span><br><span class="line"><span class="comment"># 子字符串可以使用加法与两个冒号分隔符连接在一起</span></span><br><span class="line">first ,second , third=pieces</span><br><span class="line">first+<span class="string">&#x27;::&#x27;</span>+second+<span class="string">&#x27;::&#x27;</span>+third <span class="comment"># &#x27;a::b::guido&#x27;</span></span><br><span class="line"><span class="comment"># 更通用方法</span></span><br><span class="line"><span class="string">&#x27;::&#x27;</span>.join(pieces)</span><br></pre></td></tr></table></figure>
</li>
<li><p>尽管index和find也可，Python的in关键字是检测子字符串的最佳方法</p>
<blockquote>
<p>index在字符串没有找到时会抛出一个异常（而find是返回-1）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;guido&#x27;</span> <span class="keyword">in</span> val <span class="comment"># True</span></span><br><span class="line">val.index(<span class="string">&#x27;,&#x27;</span>) <span class="comment"># 1</span></span><br><span class="line">val.find(<span class="string">&#x27;:&#x27;</span>) <span class="comment"># -1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>count返回子字符串出现的次数：<code>val.count(‘,’)</code></p>
</li>
<li><p>replace将用一种模式替代另一种模式。它通常也用于传入空字符串来<strong>删除某个模式</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val.replace(<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;::&#x27;</span>) <span class="comment"># &#x27;a::b:: guido&#x27;</span></span><br><span class="line">val.replace(<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27; &#x27;</span>)  <span class="comment"># &#x27;a b  guido&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Python内建字符串方法</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_95" alt="img" style="zoom:50%;" /></li>
</ul>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><blockquote>
<p>一种在文本中灵活查找或匹配（通常更为复杂的）字符串模式的方法。单个表达式通常被称为regex，是根据正则表达式语言形成的字符串.</p>
</blockquote>
<ul>
<li><p>Python的re模块是将正则表达式应用到字符串上的库</p>
<ul>
<li><p>re模块的三个主题</p>
<ul>
<li>模式匹配</li>
<li>替代</li>
<li>拆分</li>
</ul>
</li>
<li><p>描述<strong>一个或多个空白字符</strong>的正则表达式是<strong>\s+</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # 将含有多种空白字符（制表符、空格、换行符）的字符串拆分开</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">&quot;foo    bar\t baz  \tqux&quot;</span></span><br><span class="line">re.split(<span class="string">&#x27;\s+&#x27;</span>, text) <span class="comment"># [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;, &#x27;qux&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用<strong>re.compile</strong>自行编译，形成一个<strong>可复用</strong>的正则表达式对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">regex = re.<span class="built_in">compile</span>(<span class="string">&#x27;\s+&#x27;</span>)</span><br><span class="line">regex.split(text) <span class="comment"># [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;, &#x27;qux&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<strong>findall</strong>获得所有匹配正则表达式模式的列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">regex.findall(text)</span><br><span class="line"><span class="comment"># [&#x27;    &#x27;, &#x27;\t &#x27;, &#x27;  \t&#x27;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在正则表达式中避免转义符\的影响，可以使用原生字符串语法，比如<code>r&#39;C:\x&#39;</code>或者用等价的<code>’C:\\x&#39;</code></p>
</li>
<li><p>使用re.compile创建一个正则表达式对象，可以将相同的表达式应用到多个字符串上，这样有利于节约CPU周期</p>
</li>
<li><p>match、search、findall</p>
<ul>
<li><p>findall返回字符串中所有匹配项</p>
</li>
<li><p>search仅返回第一个匹配项</p>
</li>
<li><p>match更为严格，只在字符串的起始位置进行匹配</p>
</li>
<li><p>例子：识别大部分电子邮件地址的正则表达式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">&quot;&quot;&quot;Dave dave@google.com</span></span><br><span class="line"><span class="string">Steve steve@gmail.com</span></span><br><span class="line"><span class="string">Rob rob@gmail.com</span></span><br><span class="line"><span class="string">Ryan ryan@yahoo.com</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">pattern = <span class="string">r&#x27;[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]&#123;2,4&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># re.IGNORECASE makes the regex case-insensitive</span></span><br><span class="line">regex = re.<span class="built_in">compile</span>(pattern, flags=re.IGNORECASE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用findall会生成一个电子邮件地址的列表</span></span><br><span class="line">regex.findall(text)</span><br><span class="line"><span class="comment"># [&#x27;dave@google.com&#x27;, &#x27;steve@gmail.com&#x27;, &#x27;rob@gmail.com&#x27;, &#x27;ryan@yahoo.com&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># search返回第一个匹配到的电子邮件地址</span></span><br><span class="line">m =regex.search(text)</span><br><span class="line">m <span class="comment"># &lt;re.Match object; span=(5, 20), match=&#x27;dave@google.com&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 匹配对象只能告诉我们模式在字符串中起始和结束的位置</span></span><br><span class="line">text[m.start():m.end()] <span class="comment"># &#x27;dave@google.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># regex.match只在模式出现于字符串起始位置时进行匹配，如果没有匹配到，返回None</span></span><br><span class="line"><span class="built_in">print</span>(regex.match(text)) <span class="comment"># None</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>sub会返回一个新的字符串，原字符串会被新的字符串替代</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(regex.sub(<span class="string">&#x27;REDACTED&#x27;</span>,text))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Dave REDACTED</span></span><br><span class="line"><span class="string">Steve REDACTED</span></span><br><span class="line"><span class="string">Rob REDACTED</span></span><br><span class="line"><span class="string">Ryan REDACTED</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将电子邮件地址分为三个部分：用户名、域名和域名后缀，可以用<strong>括号</strong>将模式包起来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&#x27;([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\.([A-Z]&#123;2,4&#125;)&#x27;</span></span><br><span class="line">regex = re.<span class="built_in">compile</span>(pattern, flags=re.IGNORECASE)</span><br><span class="line"><span class="comment"># 使用修改后的对象的groups方法，返回的是模式组件的元组</span></span><br><span class="line">m = regex.match(<span class="string">&#x27;wesm@bright.net&#x27;</span>)</span><br><span class="line">m.groups() <span class="comment"># (&#x27;wesm&#x27;, &#x27;bright&#x27;, &#x27;net&#x27;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>模式可以分组时，findall返回的是包含元组的列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">regex.findall(text)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[(&#x27;dave&#x27;, &#x27;google&#x27;, &#x27;com&#x27;),</span></span><br><span class="line"><span class="string"> (&#x27;steve&#x27;, &#x27;gmail&#x27;, &#x27;com&#x27;),</span></span><br><span class="line"><span class="string"> (&#x27;rob&#x27;, &#x27;gmail&#x27;, &#x27;com&#x27;),</span></span><br><span class="line"><span class="string"> (&#x27;ryan&#x27;, &#x27;yahoo&#x27;, &#x27;com&#x27;)]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>sub也可以使用特殊符号，如\1和\2，访问每个匹配对象中的分组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(regex.sub(<span class="string">r&#x27;Username: \1,Domain: \2,Suffix: \3&#x27;</span>,text))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Dave Username: dave,Domain: google,Suffix: com</span></span><br><span class="line"><span class="string">Steve Username: steve,Domain: gmail,Suffix: com</span></span><br><span class="line"><span class="string">Rob Username: rob,Domain: gmail,Suffix: com</span></span><br><span class="line"><span class="string">Ryan Username: ryan,Domain: yahoo,Suffix: com</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>正则表达式方法</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329225833993.png" alt="image-20220329225833993" style="zoom:67%;" /></li>
</ul>
<h3 id="pandas中的向量化字符串函数"><a href="#pandas中的向量化字符串函数" class="headerlink" title="pandas中的向量化字符串函数"></a>pandas中的向量化字符串函数</h3><ul>
<li><p>包含字符串的列有时会含有缺失数据</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329224259419.png" alt="image-20220329224259419" style="zoom:67%;" />

<p>可以使用<strong>data.map</strong>将字符串和有效的正则表达式方法（以lambda或其他函数的方式传递）应用到每个值上，但是<strong>在NA（null）值上会失败</strong></p>
</li>
<li><p>Series有面向数组的方法用于跳过NA值的字符串操作。这些方法通过Series的str属性进行调用</p>
<ul>
<li>str.contains来检查每个电子邮件地址是否含有’gmail’：<code>data.str.contains(‘gmail’)</code></li>
</ul>
</li>
<li><p>正则表达式也可以结合任意的re模块选项使用，例如IGNORECASE</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pattern</span><br><span class="line">data.<span class="built_in">str</span>.findall(pattern, flags=re.IGNORECASE)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Dave     [(dave, google, com)]</span></span><br><span class="line"><span class="string">Steve    [(steve, gmail, com)]</span></span><br><span class="line"><span class="string">Rob        [(rob, gmail, com)]</span></span><br><span class="line"><span class="string">Wes                        NaN</span></span><br><span class="line"><span class="string">dtype: object</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>进行向量化元素检查</p>
<ul>
<li><p>使用str.get或在str属性内部索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matches = data.<span class="built_in">str</span>.match(pattern,flags=re.IGNORECASE)</span><br></pre></td></tr></table></figure>
</li>
<li><p>要访问嵌入式列表中的元素,将索引传递给这些函数中的任意一个</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matches.<span class="built_in">str</span>.get(<span class="number">1</span>)</span><br><span class="line">matches.<span class="built_in">str</span>[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用字符串切片的类似语法进行向量化切片</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data.<span class="built_in">str</span>[<span class="number">5</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Dave     dave@</span></span><br><span class="line"><span class="string">Steve    steve</span></span><br><span class="line"><span class="string">Rob      rob@g</span></span><br><span class="line"><span class="string">Wes        NaN</span></span><br><span class="line"><span class="string">dtype: object</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>部分向量化字符串方法列表</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_99" alt="img" style="zoom:50%;" /></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/29/%E5%85%AD%E3%80%81%E6%95%B0%E6%8D%AE%E8%BD%BD%E5%85%A5%E3%80%81%E5%AD%98%E5%82%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="TT">
      <meta itemprop="description" content="The Journey Is the Reward">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/29/%E5%85%AD%E3%80%81%E6%95%B0%E6%8D%AE%E8%BD%BD%E5%85%A5%E3%80%81%E5%AD%98%E5%82%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" class="post-title-link" itemprop="url">六、数据载入、存储及文件格式《利用Python进行数据分析》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-29 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-29T00:00:00+08:00">2022-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 19:32:41" itemprop="dateModified" datetime="2023-09-13T19:32:41+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">机器学习： 数据分析</span></a>
                </span>
            </span>

          
            <span id="/2022/03/29/%E5%85%AD%E3%80%81%E6%95%B0%E6%8D%AE%E8%BD%BD%E5%85%A5%E3%80%81%E5%AD%98%E5%82%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" class="post-meta-item leancloud_visitors" data-flag-title="六、数据载入、存储及文件格式《利用Python进行数据分析》" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/29/%E5%85%AD%E3%80%81%E6%95%B0%E6%8D%AE%E8%BD%BD%E5%85%A5%E3%80%81%E5%AD%98%E5%82%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/29/%E5%85%AD%E3%80%81%E6%95%B0%E6%8D%AE%E8%BD%BD%E5%85%A5%E3%80%81%E5%AD%98%E5%82%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第六章-数据载入、存储及文件格式"><a href="#第六章-数据载入、存储及文件格式" class="headerlink" title="第六章 数据载入、存储及文件格式"></a>第六章 数据载入、存储及文件格式</h1><h2 id="6-1-文本格式数据的读写"><a href="#6-1-文本格式数据的读写" class="headerlink" title="6.1 文本格式数据的读写"></a>6.1 文本格式数据的读写</h2><ul>
<li><p>将表格型数据读取为DataFrame对象：read_csv()和read_table()</p>
</li>
<li><p>Pandas的解析函数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_82" alt="img" style="zoom:50%;" />

<ul>
<li><p>可选参数</p>
<ul>
<li>索引：可以将<strong>一或多个列</strong>作为返回的DataFrame</li>
<li>类型推断和数据转换：包括用户自定义的值转换和自定义的缺失值符号列表。</li>
<li>日期时间解析：包括组合功能，包括将分散在多个列上的日期和时间信息组合成结果中的单个列</li>
<li>迭代：对大型文件的分块迭代</li>
<li>未清洗数据问题：跳过行、页脚、注释以及其他次要数据，比如使用逗号分隔千位的数字。</li>
</ul>
</li>
<li><p>一些数据载入函数（如pandas.read_csv等）会进行<strong>类型推断</strong>，因为列的数据类型并不是数据格式的一部分，不必指定那一列是数值、整数、布尔值或字符串。</p>
<ul>
<li><p>处理<strong>日期</strong>和<strong>自定义类型</strong>数据需要其他努力</p>
<ul>
<li><p>pandas默认分配列名，也可以自己指定列名：<code>pd.read_csv(‘examples/ex2.csv’,names=[‘a’,’b’,’c’,’d’,’message’])</code></p>
</li>
<li><p>将message列成为DataFrame索引，可以指定位置4的列为索引，或将‘message’传给参数index_col</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;message&#x27;</span>]</span><br><span class="line">pd.read_csv(<span class="string">&#x27;examples/ex2.csv&#x27;</span>, names=names, index_col=<span class="string">&#x27;message&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>从多个列形成分层索引：传入一个包含列序号或列名的列表：<code>pd.read_csv(‘examples/csv_mindex.cav’,index_col=[‘key1’,’key2’])</code></p>
</li>
</ul>
</li>
<li><p>表的分隔符不固定，使用空白或其他方式来分隔字段</p>
<ul>
<li><p>向read_table传入一个<strong>正则表达式</strong>作为分隔符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = pd.read_table(<span class="string">&#x27;examples/ex3.txt&#x27;</span>,sep=<span class="string">&#x27;\s+&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用skiprows来跳过某些行（例：第一行、第三行和第四行）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.read_csv(<span class="string">&#x27;examples/ex4.csv&#x27;</span>,skiprows=[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>缺失值处理</p>
<ul>
<li><p>缺失值<strong>不显示（空字符串）</strong>或用<strong>标识值</strong>显示（NA和Null等）</p>
</li>
<li><p><strong>na_values</strong>选项可以传入<strong>一个列表</strong>或<strong>一组字符串</strong>来处理缺失值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.read_csv(<span class="string">&#x27;examples/ex5.csv&#x27;</span>,na_values=[<span class="string">&#x27;NULL&#x27;</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>在字典中，每列可以指定不同的缺失值标识</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentinels = &#123;<span class="string">&#x27;message&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;NA&#x27;</span>], <span class="string">&#x27;something&#x27;</span>:[<span class="string">&#x27;two&#x27;</span>]&#125;</span><br><span class="line">pd.read_csv(<span class="string">&#x27;examples/ex5.csv&#x27;</span>, na_values=sentinels)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>一些read_csv&#x2F;read_table函数常用参数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_84" alt="img" style="zoom:50%;" /></li>
</ul>
<h3 id="分块读入文本文件"><a href="#分块读入文本文件" class="headerlink" title="分块读入文本文件"></a>分块读入文本文件</h3><p>处理大型文件时，常需要读入文件的一个小片段或者按小块遍历文件</p>
<ul>
<li><p>在尝试大文件前，可先对pandas的显示设置进行调整，使之更为紧凑</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pd.options.display.max_rows = <span class="number">10</span></span><br><span class="line"><span class="comment"># 只读取文件的前五行</span></span><br><span class="line">result = pd.read_csv(<span class="string">&#x27;examples/ex6.csv&#x27;</span>,nrows=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置<strong>chunksize</strong>指定每个分块的行数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunker = pd.read_csv(<span class="string">&#x27;examples/ex6.csv&#x27;</span>,chunksize=<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>read_csv返回TextParser对象，可根据chunksize遍历文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遍历ex6.csv，并对’key’列聚合获得计数值</span></span><br><span class="line">chunker = pd.read_csv(<span class="string">&#x27;examples/ex6.csv&#x27;</span>,chunksize=<span class="number">1000</span>)</span><br><span class="line">tot = pd.Series([])</span><br><span class="line"><span class="keyword">for</span> piece <span class="keyword">in</span> chunker:</span><br><span class="line">    tot = tot.add(piece[<span class="string">&#x27;key&#x27;</span>].value_counts(),fill_value=<span class="number">0</span>)</span><br><span class="line">tot = tot.sort_values(ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>TextParser还具有get_chunk方法，允许你按照任意大小读取数据块</p>
</li>
</ul>
<h3 id="将数据写入文本格式"><a href="#将数据写入文本格式" class="headerlink" title="将数据写入文本格式"></a>将数据写入文本格式</h3><ul>
<li>DataFrame的<strong>to_csv方法</strong>：将数据导出为逗号分隔的文件，可以通过<strong>sep</strong>设置其他分隔符<ul>
<li>缺失值在输出时以<strong>空字符串</strong>出现，也可以用其他标识符对缺失值进行标注：<code>data.to_csv(sys.stdout,na_rep=‘NULL’)</code></li>
<li>默认列和标签都会被写入，可以禁止二者写入：<code>data.to_csv(sys.stdout,index=False,header=False)</code></li>
<li>按照指定顺序写入列的子集：<code>data.to_csv(sys.stdout,index=False,columns=[‘a’,’b’,’c’])</code></li>
<li>Series也有to_csv方法</li>
</ul>
</li>
</ul>
<h3 id="使用分隔格式"><a href="#使用分隔格式" class="headerlink" title="使用分隔格式"></a>使用分隔格式</h3><ul>
<li><p>read_table无法接收一个带有一行或多行错误的文件</p>
</li>
<li><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220328231634813.png" alt="image-20220328231634813" style="zoom:50%;" />
</li>
<li><p>使用Python的<strong>csv模块</strong>处理带有单字符分隔符的文件，将打开的文件型对象传给<strong>csv.reader</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;examples/ex7.csv&#x27;</span>)</span><br><span class="line">reader = csv.reader(f)</span><br><span class="line"><span class="comment"># 像遍历文件一样，遍历reader会产生元组</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">    <span class="built_in">print</span>(line)  <span class="comment"># 元组的值为删除了引号的字符</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 将文件读取为行的列表</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;examples/ex7.csv&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = <span class="built_in">list</span>(csv.reader(f))</span><br><span class="line"><span class="comment"># 将数据拆分为列名行和数据行</span></span><br><span class="line">header,values = lines[<span class="number">0</span>],lines[<span class="number">1</span>:]</span><br><span class="line"><span class="comment"># 使用字典推导式和表达式zip(*values)生成一个包含数据列的字典，字典中行转置成列</span></span><br><span class="line">data_dict = &#123;h: v <span class="keyword">for</span> h,v <span class="keyword">in</span> <span class="built_in">zip</span>(header,<span class="built_in">zip</span>(*values))&#125;</span><br><span class="line">data_dict</span><br><span class="line"><span class="comment"># &#123;&#x27;a&#x27;: (&#x27;1&#x27;, &#x27;1&#x27;), &#x27;b&#x27;: (&#x27;2&#x27;, &#x27;2&#x27;), &#x27;c&#x27;: (&#x27;3&#x27;, &#x27;3&#x27;)&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<strong>csv.Dialect</strong>定义子类处理不同风格的文件，比如不同的分隔符、字符串引用约定或行终止符等</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">my_dialect</span>(csv.Dialect):</span><br><span class="line">    lineterminator = <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    delimiter = <span class="string">&#x27;;&#x27;</span></span><br><span class="line">    quotechar = <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    quoting = csv.QUOTE_MINIMAL</span><br><span class="line">reader = csv.reader(f,dialect=my_dialect)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不定义子类，直接将CSV方言参数传入csv.reader的关键字参数</span></span><br><span class="line">reader = csv.reader(f,delimiter=<span class="string">&#x27;|&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>csv.Dialect中的一些属性及其用途</p>
<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_85" alt="img"></p>
</li>
<li><blockquote>
<p>对于具有更复杂或固定的多字符分隔符的文件，你将无法使用csv模块.</p>
<p>使用字符串的split方法或正则表达式方法re.split进行拆分和其他清理工作</p>
</blockquote>
</li>
<li><p>使用csv.writer手动写入被分隔的文件</p>
<ul>
<li>接收 一个已打开可写入文件对象 和 csv.reader相同的CSV方言、格式选项</li>
<li><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220328233731729.png" alt="image-20220328233731729" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<h3 id="JSON数据"><a href="#JSON数据" class="headerlink" title="JSON数据"></a>JSON数据</h3><blockquote>
<p>JSON（JavaScript Object Notation的简写）已经成为Web浏览器和其他应用间通过HTTP请求发送数据的标准格式。</p>
</blockquote>
<ul>
<li><p>除空值null和一些细微差别（例如不允许列表末尾的逗号）之外，JSON非常接近Python。</p>
<ul>
<li>基本类型是对象（字典）、数组（列表）、字符串、数字、布尔值和空值</li>
<li>所有<strong>键</strong>都必须是<strong>字符串</strong></li>
</ul>
</li>
<li><p>JSON字符串和Python互相转换</p>
<ul>
<li><p>json.loads方法将JSON字符串转换为Python形式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">obj = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&quot;name&quot;: &quot;Wes&quot;,</span></span><br><span class="line"><span class="string"> &quot;places_lived&quot;: [&quot;United States&quot;, &quot;Spain&quot;, &quot;Germany&quot;],</span></span><br><span class="line"><span class="string"> &quot;pet&quot;: null,</span></span><br><span class="line"><span class="string"> &quot;siblings&quot;: [&#123;&quot;name&quot;: &quot;Scott&quot;, &quot;age&quot;: 30, &quot;pets&quot;: [&quot;Zeus&quot;, &quot;Zuko&quot;]&#125;,</span></span><br><span class="line"><span class="string">              &#123;&quot;name&quot;: &quot;Katie&quot;, &quot;age&quot;: 38,</span></span><br><span class="line"><span class="string">               &quot;pets&quot;: [&quot;Sixes&quot;, &quot;Stache&quot;, &quot;Cisco&quot;]&#125;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">result = json.loads(obj)</span><br><span class="line">result</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;name&#x27;: &#x27;Wes&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;places_lived&#x27;: [&#x27;United States&#x27;, &#x27;Spain&#x27;, &#x27;Germany&#x27;],</span></span><br><span class="line"><span class="string"> &#x27;pet&#x27;: None,</span></span><br><span class="line"><span class="string"> &#x27;siblings&#x27;: [&#123;&#x27;name&#x27;: &#x27;Scott&#x27;, &#x27;age&#x27;: 30, &#x27;pets&#x27;: [&#x27;Zeus&#x27;, &#x27;Zuko&#x27;]&#125;,</span></span><br><span class="line"><span class="string">  &#123;&#x27;name&#x27;: &#x27;Katie&#x27;, &#x27;age&#x27;: 38, &#x27;pets&#x27;: [&#x27;Sixes&#x27;, &#x27;Stache&#x27;, &#x27;Cisco&#x27;]&#125;]&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>json.dumps</strong>可以将Python对象转换回JSON：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asjson = json.dumps(result)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>将JSON转换成其他数据结构，方便的是将字典构成的列表（之前是JSON对象）传入DataFrame构造函数，并选出数据字段的子集</p>
<ul>
<li>&#96;&#96;&#96;python<br>import pandas as pd<br>siblings &#x3D; pd.DataFrame(result[‘siblings’], columns&#x3D;[‘name’, ‘age’])<br>siblings<br>“””<br>name    age<br>0    Scott    30<br>1    Katie    38<br>“””<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - pandas.read_json可以自动将JSON数据集按照指定次序转换为Series或DataFrame。</span><br><span class="line"></span><br><span class="line">    - pandas.read_json默认JSON数组中的每个对象是表里的一行</span><br><span class="line"></span><br><span class="line">- 从pandas中将数据导出为JSON，对Series和DataFrame使用to_json方法</span><br><span class="line"></span><br><span class="line">### XML和HTML：网络抓取</span><br><span class="line"></span><br><span class="line">&gt; Python有很多针对HTML和XML格式进行读取、写入数据的库</span><br><span class="line">&gt;</span><br><span class="line">&gt; lxml（http://lxml.de）、Beautiful Soup、html5lib</span><br><span class="line">&gt;</span><br><span class="line">&gt; lxml更快，其他库操作更多</span><br><span class="line"></span><br><span class="line">**html**</span><br><span class="line"></span><br><span class="line">- pandas的内建函数**read_html**可以使用lxml和BeautifulSoup等库将HTML中的表自动解析为DataFrame对象</span><br><span class="line"></span><br><span class="line">  - 安装</span><br><span class="line"></span><br></pre></td></tr></table></figure>
conda install lxml<br>pip install beautifulsoup4 html5lib<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- pandas.read_html函数存在很多选项，默认搜索并尝试解析所有包含在&lt;table&gt;标签中的表格型数据，返回的结果是DataFrame对象的列表</span><br><span class="line"></span><br><span class="line">- 举例：从美国FDIC政府机构下载了显示银行倒闭数据的HTML文件（在pandas文档中使用）</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  tables = pd.read_html(&#x27;examples/fdic_failed_bank_list.html&#x27;)</span><br><span class="line">  len(tables) # 1</span><br><span class="line">  failures = tables[0] </span><br><span class="line">  failures.head()</span><br><span class="line">  # failures有很多列，pandas在行内插入了换行符\</span><br><span class="line">  # 计算每年银行倒闭的数量</span><br><span class="line">  close_timestamps = pd.to_datetime(failures[&#x27;Closing Date&#x27;])</span><br><span class="line">  close_timestamps.dt.year.value_counts()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>使用lxml.objectify解析XML</strong></p>
<blockquote>
<p>XML（eXtensible Markup Language）是结构化数据格式，它使用元数据支持分层、嵌套数据。</p>
</blockquote>
<p><strong>示例背景</strong>：纽约大都会交通局（MTA）发布了一份关于其公交、火车服务（<a target="_blank" rel="noopener" href="http://www.mta.info/developers/down">http://www.mta.info/developers/down</a> loadhtml）的数据集。每个火车或公交服务都有一个不同的文件（例如Performance_MNR.xml代表地铁-北铁路），文件中以一系列XML记录的方式包含了按月的数据。</p>
<ul>
<li><p>使用<strong>lxml.objectify</strong>解析文件，用<strong>getroot</strong>获得XML文件根节点的引用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> objectify</span><br><span class="line">path = <span class="string">&#x27;datasets/mta_perf/Performance_MNR.xml&#x27;</span></span><br><span class="line">parsed = objectify.parse(<span class="built_in">open</span>(path))</span><br><span class="line">root= parsed.getroot()</span><br></pre></td></tr></table></figure>
</li>
<li><p>root.INDICATOR返回一个生成器，可以产生每一个<INDICATOR>XML元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># root.INDICATOR返回一个生成器，可以产生每一个&lt;INDICATOR&gt;XML元素（不包括几个标签）</span></span><br><span class="line">data = []</span><br><span class="line"></span><br><span class="line">skip_fields = [<span class="string">&#x27;PARENT_SEQ&#x27;</span>, <span class="string">&#x27;INDICATOR_SEQ&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;DESIRED_CHANGE&#x27;</span>, <span class="string">&#x27;DECIMAL_PLACES&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> elt <span class="keyword">in</span> root.INDICATOR:</span><br><span class="line">    el_data = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> elt.getchildren():</span><br><span class="line">        <span class="keyword">if</span> child.tag <span class="keyword">in</span> skip_fields:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        el_data[child.tag] = child.pyval</span><br><span class="line">    data.append(el_data)</span><br></pre></td></tr></table></figure>
</li>
<li><p>XML标签可以更复杂，每个标签可以包含元数据。一个HYML连接标签，也是有效的XML</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line">tag = <span class="string">&#x27;&lt;a href=&quot;http://www.google.com&quot;&gt;Google&lt;/a&gt;&#x27;</span></span><br><span class="line">root = objectify.parse(StringIO(tag)).getroot()</span><br><span class="line"><span class="comment"># 现在可以访问标签或链接文本中的任何字段（如href）</span></span><br><span class="line">root <span class="comment"># &lt;Element a at 0x7f6b15817748&gt;</span></span><br><span class="line">root.get(<span class="string">&#x27;href&#x27;</span>) <span class="comment"># &#x27;http://www.google.com&#x27;</span></span><br><span class="line">root.text <span class="comment"># &#x27;Google&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-2-二进制格式"><a href="#6-2-二进制格式" class="headerlink" title="6.2 二进制格式"></a>6.2 二进制格式</h2><p><strong>pickle</strong></p>
<ul>
<li><p>使用Python内建的<strong>pickle</strong>序列化模块进行<strong>二进制格式操作</strong></p>
<ul>
<li><p>pandas对象使用<strong>to_pickle</strong>方法将数据以pickle格式写入硬盘</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.read_csv(<span class="string">&#x27;examples/ex1.csv&#x27;</span>)</span><br><span class="line">frame.to_pickle(<span class="string">&#x27;examples/frame_pickle&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<strong>pandas.read_pickle</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.read_pickle(<span class="string">&#x27;examples/frame_pickle&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>pickle仅作为<strong>短期</strong>存储来使用，被pickle化的对象可能因为库版本更新而<strong>无法反序列化</strong></p>
</li>
</ul>
</li>
<li><p>Python支持的其他两个二进制格式：HDF5和MessagePack</p>
</li>
<li><p>pandas或NumPy其他存储格式</p>
<ul>
<li>bcolz（<a target="_blank" rel="noopener" href="http://bcolz.blosc.org/%EF%BC%89%EF%BC%9A%E5%9F%BA%E4%BA%8EBlosc%E5%8E%8B%E7%BC%A9%E5%BA%93%E7%9A%84%E5%8F%AF%E5%8E%8B%E7%BC%A9%E5%88%97%E5%BC%8F%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A0%BC%E5%BC%8F">http://bcolz.blosc.org/）：基于Blosc压缩库的可压缩列式二进制格式</a></li>
<li>基于Blosc压缩库的可压缩列式二进制格式</li>
<li>R编程社区的Hadley Wickham（<a target="_blank" rel="noopener" href="http://hadley.nz/%EF%BC%89%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%B7%A8%E8%AF%AD%E8%A8%80%E5%88%97%E5%BC%8F%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">http://hadley.nz/）设计的跨语言列式文件格式</a></li>
<li>Feather使用Apache箭头（<a target="_blank" rel="noopener" href="http://arrow.apache.org)列式存储器格式/">http://arrow.apache.org）列式存储器格式</a></li>
</ul>
</li>
</ul>
<p><strong>使用HDF5格式</strong></p>
<blockquote>
<p>存储大量的科学数组数据，以C库的形式提供，有很多其他语言接口</p>
<p>用于处理不适合在内存中存储的超大型数据，可以仅高效读写一小块</p>
</blockquote>
<ul>
<li><p>“HDF”代表分层数据格式，每个HDF5文件可以存储多个数据集并且支持元数据。</p>
</li>
<li><p>HDF5支持多种压缩模式的即时压缩，重复模式的数据可以更高效地存储</p>
</li>
<li><p>可使用PyTables或h5py等库直接访问HDF5文件，但pandas提供高阶接口：<strong>HDFStore类</strong>，可以像字典一样处理细节，简化Series和DataFrame的存储。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: np.random.randn(<span class="number">100</span>)&#125;)</span><br><span class="line">store = pd.HDFStore(<span class="string">&#x27;mydata.h5&#x27;</span>)</span><br><span class="line">store[<span class="string">&#x27;obj1&#x27;</span>] = frame</span><br><span class="line">store[<span class="string">&#x27;obj1_col&#x27;</span>] = frame[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">store</span><br></pre></td></tr></table></figure>

<ul>
<li><p>包含在HDF5文件中的对象可以用字典型API进行检索</p>
</li>
<li><p>HDFStore支持两种存储模式，’fixed’和’table’（后者更慢，但支持一种特殊语法的查询操作）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># put是store [&#x27;obj2&#x27;]=frame方法的显式版本，但允许我们设置其他选项，如存储格式</span></span><br><span class="line">store.put(<span class="string">&#x27;obj2&#x27;</span>, frame, <span class="built_in">format</span>=<span class="string">&#x27;table&#x27;</span>)</span><br><span class="line">store.select(<span class="string">&#x27;obj2&#x27;</span>, where=[<span class="string">&#x27;index &gt;= 10 and index &lt;= 15&#x27;</span>])</span><br><span class="line">store.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p>pandas.read_hdf函数可以用作快捷方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frame.to_hdf(<span class="string">&#x27;mydata.h5&#x27;</span>, <span class="string">&#x27;obj3&#x27;</span>, <span class="built_in">format</span>=<span class="string">&#x27;table&#x27;</span>)</span><br><span class="line">pd.read_hdf(<span class="string">&#x27;mydata.h5&#x27;</span>, <span class="string">&#x27;obj3&#x27;</span>, where=[<span class="string">&#x27;index &lt; 5&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>处理远程服务器上的数据时，使用专门为分布式存储而设计的二进制格式更为合适，比如Apache Parquet（<a target="_blank" rel="noopener" href="http://parquet.apache.org)./">http://parquet.apache.org）。</a></p>
</li>
<li><p>处理大量本地数据时，尝试使用PyTables和h5py。</p>
</li>
<li><p>很多数据分析的困难在于I&#x2F;O密集（而不是CPU密集），使用类似HDF5可以加速</p>
</li>
</ul>
<blockquote>
<p>HDF5并不是数据库，它是一种适合一次写入多次读取的数据集.</p>
<p>多个写入者持续写入，文件可能会损坏</p>
</blockquote>
<p><strong>读取Microsoft Excel文件</strong></p>
<blockquote>
<p>pandas也支持通过ExcelFile类或pandas.read_excel函数来读取存储在Excel表格型数据</p>
<p>使用附加包xlrd和openpyxl来分别读取XLS和XLSX文件的</p>
</blockquote>
<ul>
<li><p>通过将xls或xlsx的路径传入ExcelFile，生成一个实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xlsx = pd.ExcelFile(<span class="string">&#x27;examples/ex1.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>表格数据可以通过pandas.read_excel读取到DataFrame中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.read_excel(xlsx, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>含有多个表的文件，生成ExcelFile更快，但也可以更简便地将文件名传入pandas.read_excel</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.read_excel(<span class="string">&#x27;examples/ex1.xlsx&#x27;</span>, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line">frame</span><br></pre></td></tr></table></figure>
</li>
<li><p>将pandas数据写入到Excel格式中</p>
<ul>
<li>先生成一个ExcelWriter</li>
<li>使用pandas对象的to_excel方法将数据写入</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">writer = pd.ExcelWriter(<span class="string">&#x27;examples/ex2.xlsx&#x27;</span>)</span><br><span class="line">frame.to_excel(writer, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line">writer.save()</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以将文件路径传给to_excel，避免直接调用ExcelWriter</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.to_excel(<span class="string">&#x27;examples/ex2.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-3-与Web-API交互"><a href="#6-3-与Web-API交互" class="headerlink" title="6.3 与Web API交互"></a>6.3 与Web API交互</h2><blockquote>
<p>使用requests包（<a target="_blank" rel="noopener" href="http://docs.python-requests.orgt)与web/">http://docs.python-requests.orgt）与Web</a> API交互更简单</p>
</blockquote>
<p>获取GitHub上最新的30条关于pandas的问题</p>
<ul>
<li><p>用附加库requests发送一个HTTP GET请求</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&#x27;https://api.github.com/repos/pandas-dev/pandas/issues&#x27;</span></span><br><span class="line">resp = requests.get(url)</span><br><span class="line">resp</span><br></pre></td></tr></table></figure>
</li>
<li><p>Response（响应）对象的json方法将返回一个包含解析为本地Python对象的JSON的字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data中的每个元素都是一个包含GitHub问题页面上的所有数据的字典（注释除外）</span></span><br><span class="line">data = resp.json()</span><br><span class="line">data[<span class="number">0</span>][<span class="string">&#x27;title&#x27;</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>将data直接传给DataFrame，并提取感兴趣的字段</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">issues = pd.DataFrame(data, columns=[<span class="string">&#x27;number&#x27;</span>, <span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">                                     <span class="string">&#x27;labels&#x27;</span>, <span class="string">&#x27;state&#x27;</span>])</span><br><span class="line">issues</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-4-与数据库交互"><a href="#6-4-与数据库交互" class="headerlink" title="6.4 与数据库交互"></a>6.4 与数据库交互</h2><blockquote>
<p>业务场景中，基于SQL的关系型数据库（例如SQL Server、PostgreSQL和MySQL）使用广泛</p>
<p>pandas很多函数可以从SQL中将数据读取为DataFrame</p>
<p>SQLAlchemy项目（<a target="_blank" rel="noopener" href="http://www.sqlalchemy.org/%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B5%81%E8%A1%8C%E7%9A%84PythonSQL%E5%B7%A5%E5%85%B7%E5%8C%85%EF%BC%8C%E6%8A%BD%E8%B1%A1%E5%8E%BB%E9%99%A4%E4%BA%86SQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E9%97%B4%E7%9A%84%E8%AE%B8%E5%A4%9A%E5%B8%B8%E8%A7%81%E5%B7%AE%E5%BC%82%E3%80%82">http://www.sqlalchemy.org/）是一个流行的PythonSQL工具包，抽象去除了SQL数据库之间的许多常见差异。</a></p>
</blockquote>
<ul>
<li><p>使用Python内建的<strong>sqlite3</strong>驱动来生成一个<strong>SQLite数据库</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line">query = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">CREATE TABLE test</span></span><br><span class="line"><span class="string">(a VARCHAR(20), b VARCHAR(20),</span></span><br><span class="line"><span class="string"> c REAL,        d INTEGER</span></span><br><span class="line"><span class="string">);&quot;&quot;&quot;</span></span><br><span class="line">con = sqlite3.connect(<span class="string">&#x27;mydata.sqlite&#x27;</span>)</span><br><span class="line">con.execute(query)</span><br><span class="line">con.commit()</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入几行数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data = [(<span class="string">&#x27;Atlanta&#x27;</span>, <span class="string">&#x27;Georgia&#x27;</span>, <span class="number">1.25</span>, <span class="number">6</span>),</span><br><span class="line">        (<span class="string">&#x27;Tallahassee&#x27;</span>, <span class="string">&#x27;Florida&#x27;</span>, <span class="number">2.6</span>, <span class="number">3</span>),</span><br><span class="line">        (<span class="string">&#x27;Sacramento&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="number">1.7</span>, <span class="number">5</span>)]</span><br><span class="line">stmt = <span class="string">&quot;INSERT INTO test VALUES(?, ?, ?, ?)&quot;</span></span><br><span class="line">con.executemany(stmt, data)</span><br><span class="line">con.commit()</span><br></pre></td></tr></table></figure>
</li>
<li><p>大部分Python的SQL驱动（PyODBC、psycopg2、MySQLdb、pymssql等）返回的是元组的列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cursor = con.execute(<span class="string">&#x27;select * from test&#x27;</span>)</span><br><span class="line">rows = cursor.fetchall()</span><br><span class="line">rows</span><br></pre></td></tr></table></figure>
</li>
<li><p>将元组的列表传给DataFrame构造函数,要包含在游标的description属性中的列名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cursor.description</span><br><span class="line">pd.DataFrame(rows, columns=[x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> cursor.description])</span><br></pre></td></tr></table></figure>
</li>
<li><p>pandas中read_sql函数可以从通用的SQLAlchemy连接中轻松地读取数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用SQLAlchemy连接到相同的SQLite数据库，并从之前创建的表中读取数据</span></span><br><span class="line"><span class="keyword">import</span> sqlalchemy <span class="keyword">as</span> sqla</span><br><span class="line">db = sqla.create_engine(<span class="string">&#x27;sqlite:///mydata.sqlite&#x27;</span>)</span><br><span class="line">pd.read_sql(<span class="string">&#x27;select * from test&#x27;</span>, db)</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/28/%E4%B8%89%E3%80%81%E5%86%85%E5%BB%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%8A%E6%96%87%E4%BB%B6%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="TT">
      <meta itemprop="description" content="The Journey Is the Reward">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/28/%E4%B8%89%E3%80%81%E5%86%85%E5%BB%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%8A%E6%96%87%E4%BB%B6%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" class="post-title-link" itemprop="url">三、内建数据结构、函数及文件——《利用Python进行数据分析》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-28 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-28T00:00:00+08:00">2022-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 19:33:20" itemprop="dateModified" datetime="2023-09-13T19:33:20+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">机器学习： 数据分析</span></a>
                </span>
            </span>

          
            <span id="/2022/03/28/%E4%B8%89%E3%80%81%E5%86%85%E5%BB%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%8A%E6%96%87%E4%BB%B6%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" class="post-meta-item leancloud_visitors" data-flag-title="三、内建数据结构、函数及文件——《利用Python进行数据分析》" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/28/%E4%B8%89%E3%80%81%E5%86%85%E5%BB%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%8A%E6%96%87%E4%BB%B6%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/28/%E4%B8%89%E3%80%81%E5%86%85%E5%BB%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%8A%E6%96%87%E4%BB%B6%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第三章-内建数据结构、函数及文件"><a href="#第三章-内建数据结构、函数及文件" class="headerlink" title="第三章 内建数据结构、函数及文件"></a>第三章 内建数据结构、函数及文件</h1><h2 id="3-1-数据结构和序列"><a href="#3-1-数据结构和序列" class="headerlink" title="3.1 数据结构和序列"></a>3.1 数据结构和序列</h2><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><ul>
<li><p>固定长度，<strong>不可变</strong>的Python对象序列</p>
</li>
<li><p>创建元组</p>
<ul>
<li>最简单：用逗号分隔序列值</li>
<li>更复杂：用括号将值包起来，例如：生成元素是元组的元组</li>
<li>使用tuple函数将任意序列或迭代器转换为元组</li>
</ul>
</li>
<li><p>元组中存储的对象自身是可变的，但是元组一旦创建，各个位置上的对象是无法被修改的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">1</span>]:tup=<span class="built_in">tuple</span>([<span class="string">&#x27;foo&#x27;</span>,[<span class="number">1</span>,<span class="number">2</span>],<span class="literal">True</span>])</span><br><span class="line">In[<span class="number">2</span>]:tup[<span class="number">2</span>] = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 提示错误</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果元组中的一个对象是可变的，例如列表，你可以在它内部进行修改</p>
</blockquote>
</li>
<li><p>可以使用+号连接元组来生成更长的元组,将元组乘以整数，则会和列表一样，生成含有多份拷贝的元组.</p>
<blockquote>
<p>对象自身并没有复制，只是指向它们的引用进行了复制</p>
</blockquote>
</li>
</ul>
<p><strong>元组拆包</strong></p>
<ul>
<li><p>将元组型的表达式赋值给变量，Python会对等号右边的值进行拆包，<strong>即使是嵌套元组也可以拆包</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">1</span>]:tup=(<span class="number">4</span>,<span class="number">5</span>,(<span class="number">6</span>,<span class="number">7</span>))</span><br><span class="line">In[<span class="number">2</span>]:a,b,(c,d)=tup</span><br><span class="line">In[<span class="number">3</span>]:d</span><br><span class="line">Out[<span class="number">1</span>]:<span class="number">7</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在Python中，交换值可以采用如下方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a,b = <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">b,a = a,b</span><br><span class="line">a <span class="comment">#输出2</span></span><br><span class="line">b <span class="comment"># 输出1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>拆包常用场景：遍历元组或列表组成的序列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seq = [(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>)]</span><br><span class="line"><span class="keyword">for</span> a,b,c <span class="keyword">in</span> seq:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a=&#123;0&#125;,b=&#123;1&#125;,c=&#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(a,b,c))</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span></span><br><span class="line">a=<span class="number">4</span>,b=<span class="number">5</span>,c=<span class="number">6</span></span><br><span class="line">a=<span class="number">7</span>,b=<span class="number">8</span>,c=<span class="number">9</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用*rest在函数调用时获取任意长度的位置参数列表，有时候rest部分表示要丢弃的数据，很多编程者会使用下划线(_)来表示不想要的遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a,b,*_ = values</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>元组方法</strong></p>
<ul>
<li><p>用count计量每个数值在元组中出现的次数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line">a.count(<span class="number">2</span>)  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul>
<li>长度可变，包含的内容可以修改</li>
<li>可使用[]或者list类型函数来定义列表</li>
<li>list函数在数据处理中常用于<strong>将迭代器或者生成器转化为列表</strong></li>
</ul>
<p><strong>增加和移除元素</strong></p>
<ul>
<li><p>append方法：将元素添加到列表尾部</p>
</li>
<li><p>使用insert方法将元素插入到列表的指定位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b_list.insert(<span class="number">1</span>,<span class="string">&#x27;red&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>insert比append计算代价更高，因为内部序列移动需要时间</p>
<p>想要在序列头部和尾部都插入元素，应该探索下collections.deque，它是一个双端队列，可以满足头尾部都增加的要求。</p>
</blockquote>
</li>
<li><p>pop方法：insert的反向操作，将特定位置的元素移除并返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b_list.pop(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>remove方法可以移除：定位第一个符合要求的值并移除它</p>
</li>
<li><p>in关键字：查询一个值是否在列表中，not in表示不在</p>
</li>
</ul>
<blockquote>
<p>​    与字典和集合相比，检查列表是否包含一个值很缓慢，因为需要遍历，而字典和集合是基于哈希表同时查找的。</p>
</blockquote>
<p><strong>连接和联合列表</strong></p>
<ul>
<li>两个列表可以用+号连接</li>
<li>extend方法向列表中添加多个元素</li>
</ul>
<blockquote>
<p>​    extend方法比用添加内容来连接列表代价更高，因为连接过程涉及创建新列表、复制对象；使用extend将元素添加到已经存在的列表是更好的方式（尤其是大型链表）。</p>
</blockquote>
<p><strong>排序</strong></p>
<ul>
<li>使用sort方法进行列表内部排序</li>
</ul>
<p><strong>二分搜索和已排序列表的维护</strong></p>
<ul>
<li><p>内建的bisect模块实现了二分搜索和已排序列表的插值</p>
<ul>
<li><p>bisect.bisect会找到元素应当被插入的位置，并保持序列排序</p>
</li>
<li><p>bisect.bisect会找到元素应当被插入的位置，并保持序列排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line">c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line">bisect.bisect(c,<span class="number">5</span>) <span class="comment"># 输出6</span></span><br><span class="line">bisect.insort(c,<span class="number">6</span>)</span><br><span class="line">c <span class="comment"># 输出[1, 2, 2, 2, 3, 4, 6, 7]</span></span><br></pre></td></tr></table></figure>


</li>
<li><blockquote>
<p>因为代价问题，bisect模块的函数不会检查列表是否已经排序，对未排序列表使用bisect的函数虽然不会报错，但可能会导致不正确的结果。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>切片</strong></p>
<ul>
<li>使用切片可以选取子集，也可以用来赋值</li>
<li>切片包含起始位置start，不包含结尾stop，元素数量：stop-start</li>
<li>切片索引省略会默认传入起始位置或结束位置</li>
<li>负索引可以从序列的尾部进行索引</li>
<li>步进值step可以在第二个冒号后面使用，意思是每隔多少个数取一个值；对列表或元组进行翻转时，向步进传值-1</li>
</ul>
<h3 id="内建序列函数"><a href="#内建序列函数" class="headerlink" title="内建序列函数"></a>内建序列函数</h3><p><strong>enumerate</strong></p>
<ul>
<li><p>遍历序列时，同时追踪当前元素的索引，使用enumerate函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,value <span class="keyword">in</span> <span class="built_in">enumerate</span>(collection):</span><br><span class="line">    <span class="comment"># 使用值做点事</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对数据建立索引，使用enumerate构造字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">some_list = [<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>,<span class="string">&#x27;baz&#x27;</span>]</span><br><span class="line">mapping = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(some_list):</span><br><span class="line">    mapping[v] = i</span><br><span class="line">mapping <span class="comment"># 输出 &#123;&#x27;foo&#x27;: 0, &#x27;bar&#x27;: 1, &#x27;baz&#x27;: 2&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>sorted</strong></p>
<ul>
<li>sorted函数返回一个根据任意序列中的元素新建的已排序列表</li>
</ul>
<p><strong>zip</strong></p>
<ul>
<li><p>zip将列表、元组或其他序列的元素配对，新建一个元组构成的列表</p>
</li>
<li><p>zip将列表、元组或其他序列的元素配对，新建一个元组构成的列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">seq1 = [<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>,<span class="string">&#x27;baz&#x27;</span>]</span><br><span class="line">seq2 = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>]</span><br><span class="line">zipped = <span class="built_in">zip</span>(seq1,seq2)</span><br><span class="line"><span class="built_in">list</span>(zipped)</span><br><span class="line"><span class="comment"># 输出：[(&#x27;foo&#x27;, &#x27;one&#x27;), (&#x27;bar&#x27;, &#x27;two&#x27;), (&#x27;baz&#x27;, &#x27;three&#x27;)]</span></span><br><span class="line">seq3 = [<span class="literal">False</span>,<span class="literal">True</span>]</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">zip</span>(seq1,seq2,seq3))</span><br><span class="line"><span class="comment"># 输出：[(&#x27;foo&#x27;, &#x27;one&#x27;, False), (&#x27;bar&#x27;, &#x27;two&#x27;, True)]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>zip常用场景：<u>和enumerate同时使用同时遍历多个序列</u></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,(a,b) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(seq1,seq2)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>:<span class="subst">&#123;a&#125;</span>,<span class="subst">&#123;b&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0:foo,one</span></span><br><span class="line"><span class="string">1:bar,two</span></span><br><span class="line"><span class="string">2:baz,three</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>zip“拆分”已“配对”的序列，也就是将行的列表转换为列的列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pitchers = [(<span class="string">&#x27;Nolan&#x27;</span>,<span class="string">&#x27;Ryan&#x27;</span>),(<span class="string">&#x27;Roger&#x27;</span>,<span class="string">&#x27;Clemens&#x27;</span>),(<span class="string">&#x27;Schilling&#x27;</span>,<span class="string">&#x27;Curt&#x27;</span>)]</span><br><span class="line">first_names,last_names = <span class="built_in">zip</span>(*pitchers)</span><br><span class="line">first_names <span class="comment"># (&#x27;Nolan&#x27;, &#x27;Roger&#x27;, &#x27;Schilling&#x27;)</span></span><br><span class="line">last_names <span class="comment"># (&#x27;Ryan&#x27;, &#x27;Clemens&#x27;, &#x27;Curt&#x27;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>reversed</strong></p>
<ul>
<li>reversed函数可以将序列的元素倒序排列，它是一个生成器，在没有进行实例化的时候，它并不会产生一个倒序的列表</li>
</ul>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul>
<li><p>字典，也是哈希表和关联数组</p>
</li>
<li><p>用大括号{}创建字典，在字典中用逗号将键值对分隔</p>
</li>
<li><p>用del关键字或pop方法删除值，pop方法会在删除的同时返回被删的值，并删除键</p>
</li>
<li><p>keys方法和values方法可以提供字典键、值的迭代器</p>
</li>
<li><p>update方法将两个字典合并</p>
<blockquote>
<p>update方法改变了字典中元素位置，用del关键字或pop方法删除值，pop方法会在删除的同时返回被删的值，并删除键。</p>
</blockquote>
</li>
</ul>
<p><strong>从序列生成字典</strong></p>
<ul>
<li><p>字典本质上是2-元组（含有2个元素的元组）的集合，字典是可以接受一个2-元组的列表作为参数的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mapping = <span class="built_in">dict</span>(<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">5</span>),<span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">5</span>))))</span><br><span class="line">mapping</span><br><span class="line"><span class="comment"># 输出：&#123;0: 4, 1: 3, 2: 2, 3: 1, 4: 0&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>默认值</strong></p>
<ul>
<li><p>字典的get方法和pop方法可以返回一个默认值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = some_dict.get(key,default_value)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>带有默认值的get方法会在key参数不是字典的键时返回None，而pop会抛出异常</p>
</blockquote>
</li>
<li><p>常用场景：字典中的值集合通过设置成为另外一种值集合，例子：根据首字母分类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;bat&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>,<span class="string">&#x27;atom&#x27;</span>,<span class="string">&#x27;book&#x27;</span>]</span><br><span class="line">by_letter = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    letter = word[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> letter <span class="keyword">not</span> <span class="keyword">in</span> by_letter:</span><br><span class="line">        by_letter[letter] = [word]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        by_letter[letter].append(word)</span><br><span class="line"></span><br><span class="line">by_letter <span class="comment"># 输出：&#123;&#x27;a&#x27;: [&#x27;apple&#x27;, &#x27;atom&#x27;], &#x27;b&#x27;: [&#x27;bat&#x27;, &#x27;bar&#x27;, &#x27;book&#x27;]&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>字典的setdefault方法就是为了这个目的而生，上述循环可以改写成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line"> letter = word[<span class="number">0</span>]</span><br><span class="line"> by_letter.setdefault(letter,[]).append(word)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>defaultdict类</strong>：向字典中传入类型或能在各位置生成默认值的函数，生成符合要求的字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">by_letter = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    by_letter[word[<span class="number">0</span>]].append(word)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>有效的字典键类型</strong></p>
<ul>
<li>字典的值可以是任何Python对象，但是键必须是不可变对象，比如标量类型（整数、浮点数、字符串）或元组（且元组内对象也必须是不可变对象）</li>
<li>哈希化：通过hash函数可以检查一个对象是否可以哈希化（即是否可以用作字典的键）</li>
<li>为了将列表作为键，一种方式就是将其转换为元组，而元组只要它内部元素都可以哈希化，则它自己也可哈希化</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li><p>集合是一种无序且元素唯一的容器</p>
</li>
<li><p>创建方式</p>
<ul>
<li>set函数 set([2,2,2,1,3,3])</li>
<li>字面集与大括号的语法{2,2,2,1,3,3}</li>
</ul>
</li>
<li><p>集合支持数学上的集合操作：联合、交集、差集、对称差集。</p>
<ul>
<li><p>并集：a.union(b)，a|b</p>
</li>
<li><p>交集：a.intersection(b)，a&amp;b</p>
</li>
<li><p>集合操作</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220314151044730.png" alt="image-20220314151044730" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>大型集合使用“|&#x3D;”和“&amp;&#x3D;”更高效</p>
</li>
<li><p>和字典类似，集合的元素必须是不可变的。如果想要包含列表型的元素，必须先转换为元组</p>
</li>
<li><p>检查一个集合是否是另一个结合的子集（包含于）或超集（包含）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a_set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;.issubset(a_set) <span class="comment"># True</span></span><br><span class="line">a_set.issuperset(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; == &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125; <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 当且仅当两个集合的内容一模一样时，两个集合才相等</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="列表、集合和字典的推导式"><a href="#列表、集合和字典的推导式" class="headerlink" title="列表、集合和字典的推导式"></a>列表、集合和字典的推导式</h3><ul>
<li><p>过滤容器元素生成新的列表：[expr for val in collection if condition]，与下面for循环等价</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> collection:</span><br><span class="line">    <span class="keyword">if</span> Condition:</span><br><span class="line">        result.append(expr)</span><br></pre></td></tr></table></figure>

<p>过滤出字符串列表长度大于2的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strings = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;as&#x27;</span>,<span class="string">&#x27;bat&#x27;</span>,<span class="string">&#x27;car&#x27;</span>,<span class="string">&#x27;dove&#x27;</span>,<span class="string">&#x27;python&#x27;</span>]</span><br><span class="line">[x.upper() <span class="keyword">for</span> x <span class="keyword">in</span> strings <span class="keyword">if</span> <span class="built_in">len</span>(x)&gt;<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 输出：[&#x27;BAT&#x27;, &#x27;CAR&#x27;, &#x27;DOVE&#x27;, &#x27;PYTHON&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字典推导式</p>
<ul>
<li><p>&#96;&#96;&#96;python<br>dict_comp &#x3D; {key-expr:value-expr for value in collection if condition}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 推导式实现一个集合包含列表中字符串的长度</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  unique_lengths = &#123;len(x) for x in strings&#125;</span><br><span class="line">  unique_lengths</span><br><span class="line">  # &#123;1, 2, 3, 4, 6&#125;</span><br></pre></td></tr></table></figure>

<p>使用map函数更函数化、更简洁地表达</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">len</span>,strings))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>嵌套列表推导式</strong></p>
<ul>
<li>可以嵌套多层列表推导式</li>
</ul>
<h2 id="3-2-函数"><a href="#3-2-函数" class="headerlink" title="3.2 函数"></a>3.2 函数</h2><ul>
<li>函数使用def关键字声明，return关键字返回</li>
<li>可以有多条返回语句，如果到结尾仍然没有return语句，自动返回None</li>
<li>每个函数都有位置参数和关键字参数<ul>
<li>关键字参数常用于指定默认值或可选参数</li>
<li>关键字参数必须跟在位置参数后</li>
<li>可以按任意顺序指定关键字参数，不必强行记住参数的顺序，而只需用参数名指定</li>
</ul>
</li>
</ul>
<h3 id="命名空间、作用域和本地函数"><a href="#命名空间、作用域和本地函数" class="headerlink" title="命名空间、作用域和本地函数"></a>命名空间、作用域和本地函数</h3><ul>
<li><p>函数两种连接变量的方式：全局、本地</p>
</li>
<li><p>描述变量作用域的名称是命名空间</p>
<ul>
<li><p>在函数内部，任意变量默认分配到本地命名空间，在函数被调用时生成，执行结束后被销毁</p>
</li>
<li><p>在函数外声明变量，可以在外部给变量赋值，但是变量必须用global关键字声明为全局变量</p>
</li>
<li><blockquote>
<p>通常全局变量用来存储系统中的某些状态</p>
<p>大量使用全局变量时，表明需要面向对象编程</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><ul>
<li>返回多个值实际是返回了一个对象，也就是元组，而元组又被拆包为多个结果变量</li>
</ul>
<h3 id="函数是对象"><a href="#函数是对象" class="headerlink" title="函数是对象"></a>函数是对象</h3><ul>
<li><p>Python函数是对象，很多在其他语言中比较难的构造在Python中很容易实现，例子：去除用户提交数据中的凌乱字符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_strings</span>(<span class="params">strings</span>):</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> strings:</span><br><span class="line">        value = value.strip()</span><br><span class="line">        value = re.sub(<span class="string">&#x27;[! #?]&#x27;</span>,<span class="string">&#x27;&#x27;</span>,value)</span><br><span class="line">        value = value.title()</span><br><span class="line">        result.append(value)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">states = states = [<span class="string">&#x27;   Alabama &#x27;</span>, <span class="string">&#x27;Georgia!&#x27;</span>, <span class="string">&#x27;Georgia&#x27;</span>, <span class="string">&#x27;georgia&#x27;</span>, <span class="string">&#x27;FlOrIda&#x27;</span>,<span class="string">&#x27;south   carolina##&#x27;</span>, <span class="string">&#x27;West virginia?&#x27;</span>]</span><br><span class="line"></span><br><span class="line">clean_strings(states)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[&#x27;Alabama&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Georgia&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Georgia&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Georgia&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Florida&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Southcarolina&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Westvirginia&#x27;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>函数化的模式可以使你在更高层次上方便地修改字符串变换方法，例子：将特定的列表操作应用到某个特定的字符串集合上</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove_punctuation</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="keyword">return</span> re.sub(<span class="string">&#x27;[! #? ]&#x27;</span>,<span class="string">&#x27;&#x27;</span>,value)</span><br><span class="line">clean_ops = [<span class="built_in">str</span>.strip,remove_punctuation,<span class="built_in">str</span>.title]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_strings</span>(<span class="params">strings,ops</span>):</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> strings:</span><br><span class="line">        <span class="keyword">for</span> function <span class="keyword">in</span> ops:</span><br><span class="line">            value = function(value)</span><br><span class="line">        result.append(value)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">clean_strings(states,clean_ops)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[&#x27;Alabama&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Georgia&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Georgia&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Georgia&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Florida&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Southcarolina&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Westvirginia&#x27;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>可以将函数作为一个参数传给其他的函数，比如内建的map函数</p>
</li>
</ul>
<h3 id="匿名（Lambda）函数"><a href="#匿名（Lambda）函数" class="headerlink" title="匿名（Lambda）函数"></a>匿名（Lambda）函数</h3><ul>
<li><p>匿名函数是一种通过单个语句生成函数的方式，其结果是返回值</p>
</li>
<li><p>匿名函数使用lambda关键字定义，该关键字仅表达“我们声明一个匿名函数”的意思</p>
</li>
<li><p>匿名函数代码量小（也更为清晰），将它作为参数进行传值，比写一个完整的函数或者将匿名函数赋值给局部变量更好。<strong>在数据分析中非常方便</strong></p>
</li>
<li><p>假设你想要根据字符串中不同字母的数量对一个字符串集合进行排序，可以将一个匿名函数传给列表的sort方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strings = [<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;card&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="string">&#x27;abab&#x27;</span>]</span><br><span class="line">strings.sort(key = <span class="keyword">lambda</span> x:<span class="built_in">len</span>(<span class="built_in">set</span>(<span class="built_in">list</span>(x))))</span><br><span class="line">strings</span><br><span class="line"><span class="comment"># 输出：[&#x27;aaaa&#x27;, &#x27;foo&#x27;, &#x27;abab&#x27;, &#x27;bar&#x27;, &#x27;card&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>和def关键字声明的函数不同，匿名函数对象自身并没有一个显式的__name__属性</p>
</li>
</ul>
<h3 id="柯里化：部分参数应用"><a href="#柯里化：部分参数应用" class="headerlink" title="柯里化：部分参数应用"></a>柯里化：部分参数应用</h3><ul>
<li><p>柯里化是计算机科学术语（以数学家Haskell Curry命名），它表示通过部分参数应用的方式从已有的函数中衍生出新的函数</p>
</li>
<li><p>示例</p>
<ul>
<li><p>实现两个函数相加</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_numbers</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br></pre></td></tr></table></figure>
</li>
<li><p>衍生出一个只有一个变量的新函数，add_five，可以给参数加上5</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_five = <span class="keyword">lambda</span> y:add_numbers(<span class="number">5</span>,y)</span><br></pre></td></tr></table></figure>
</li>
<li><p>内建的functools模块可以使用Pratial函数简化处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line">add_five = partial(add_numbers,<span class="number">5</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><ul>
<li>迭代器协议是一种令对象可遍历的通用方式</li>
<li>大部分以列表或列表型对象为参数的方法都可以接收任意的迭代器对象。包括内建方法比如min、max和sum，以及类型构造函数比如list和tuple</li>
<li>生成器一次返回多个结果序列，产生一个元素后暂停，直到下一个请求。创建生成器需要将return替换为yield关键字</li>
<li>实际调用生成器时，代码并不会立即执行，直到你请求生成器中的元素时，它才会执行它的代码。</li>
</ul>
<p><strong>生成器表达式</strong></p>
<ul>
<li>用生成器表达式来创建生成器更简单，与列表推导式类似，把其中括号换成小括号即可。</li>
<li>生成器表达式可以作为函数参数用于替代列表推导式</li>
</ul>
<p><strong>itertools模块</strong></p>
<ul>
<li><p>标准库中的itertools模块是适用于大多数数据算法的生成器集合</p>
</li>
<li><p>例子：groupby可以根据任意的序列和一个函数，通过函数的返回值对序列中连续的元素进行分组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">first_letter = <span class="keyword">lambda</span> x:x[<span class="number">0</span>]</span><br><span class="line">names = [<span class="string">&#x27;Alan&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;Wes&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Albert&#x27;</span>, <span class="string">&#x27;Steven&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> letter, names <span class="keyword">in</span> itertools.groupby(names, first_letter):</span><br><span class="line">    <span class="built_in">print</span>(letter, <span class="built_in">list</span>(names)) <span class="comment"># names is a generator</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">A [&#x27;Alan&#x27;, &#x27;Adam&#x27;]</span></span><br><span class="line"><span class="string">W [&#x27;Wes&#x27;, &#x27;Will&#x27;]</span></span><br><span class="line"><span class="string">A [&#x27;Albert&#x27;]</span></span><br><span class="line"><span class="string">S [&#x27;Steven&#x27;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一些有用的内建工具库信息        <img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220315141817033.png" alt="image-20220315141817033" style="zoom:67%;" /></p>
</li>
</ul>
<h3 id="错误和异常处理"><a href="#错误和异常处理" class="headerlink" title="错误和异常处理"></a>错误和异常处理</h3><ul>
<li><pre><code class="python">def attempt_float(x):
    try:
        return float(x)
    except (TypeError, ValueError):
        return x
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 无论try是否报错都要执行，使用finally</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  f = open(path,&#x27;w&#x27;)</span><br><span class="line">  try:</span><br><span class="line">      write_to_file(f)</span><br><span class="line">  finally:</span><br><span class="line">      f.close()</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>使用else来执行当try代码块成功执行时才会执行的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(path,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    write_to_file(f)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Succeeded&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>IPython中的异常</strong></p>
<ul>
<li>报错时，IPython将会默认打印出完整的调用堆栈跟踪（报错追溯）。</li>
<li>使用%xmode命令来控制上下文的数量，可以从Plain（普通）模（与标准Python解释器一致）切换到Verbose（复杂）模式（可以显示函数的参数值以及更多有用信息）。</li>
</ul>
<h3 id="文件与操作系统"><a href="#文件与操作系统" class="headerlink" title="文件与操作系统"></a>文件与操作系统</h3><ul>
<li><p>打开文件进行读取或写入，需要使用内建函数open和绝对、相对路径</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">&#x27;examples/segismundo.txt&#x27;</span></span><br><span class="line">f = <span class="built_in">open</span>(path)</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认文件以只读方式打开，可以像处理列表一样遍历文件f中的内容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>行结尾标识（EOL）完整，文件内容被全部读出，一些代码的功能就是从文件中读出不带EOL的内容列表</p>
</li>
<li><p>使用open来创建文件对象时，在结束时<strong>显式关闭</strong>文件非常重要，关闭文件会将资源释放回操作系统。</p>
<ul>
<li>&#96;&#96;&#96;python<br>f.close()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用with语句关闭</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  with open(path) as f:</span><br><span class="line">      lines = [x.rstrip() for x in f]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>写下f&#x3D;open(path, ‘w’)，一个新的文件会examples&#x2F;segismundo.txt的位置被创建（请小心！），并在同一路径下覆盖同名文件。</p>
</li>
<li><p>’x’文件模式，它会创建可写的文件，但如果给定路径下已经存在同名文件就会创建失败</p>
</li>
<li><p>可读文件常用方法：read、seek、tell</p>
<ul>
<li>read返回文件中一定量的字符，通过读取的字节数来推进文件句柄的位置</li>
<li>ell方法可以给出句柄当前的位置：f.tell()</li>
<li>seek方法可以将句柄位置改变到文件中特定的字节：f.seek(3)</li>
</ul>
</li>
<li><p>使用sys模块来检查文件的默认编码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.getdefaultencoding() <span class="comment">#&#x27;utf-8&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Python文件模式<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220315145945478.png" alt="image-20220315145945478" style="zoom:80%;" /></p>
</li>
<li><p>写文件：使用文件对象的write或wirtelines方法</p>
</li>
<li><p>重要的Python文件方法或属性</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220315150219007.png" alt="image-20220315150219007" style="zoom:80%;" /></li>
</ul>
<p><strong>字节与Unicode文件</strong></p>
<ul>
<li>根据文本编码，你可能会将字节解码为str对象，但是只有每个已编码的Unicode字符是完整的情况下，才能进行解码</li>
<li>文本模式下，利用open方法的参数encoding可以将文件内容从Unicode编码转换为其他类型的编码</li>
<li>除了二进制模式，在打开文件时使用seek要当心。如果文件的句柄位置恰好在一个Unicode符号的字节中间时，后续的读取会导致错误</li>
<li>常常需要在非ASCⅡ文本数据上进行数据分析，那么精通Python的Unicode功能是很有必要的，具体参见官方文档。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="TT"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">TT</p>
  <div class="site-description" itemprop="description">The Journey Is the Reward</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TT</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'TNUpeWIcsOXnq5yrEo6XphL5-gzGzoHsz',
      appKey     : 'HdE2XffT6XTWRYvV2zovg336',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
