<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01 Introduction 简介和回归——李宏毅深度学习2021春</title>
    <url>/2021/11/07/01%20Introduction%E2%80%94%E2%80%94%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2021%E6%98%A5/</url>
    <content><![CDATA[<h1 id="01-1-Introduction"><a href="#01-1-Introduction" class="headerlink" title="01-1 Introduction"></a>01-1 Introduction</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">课程网址：https://speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.html</span><br></pre></td></tr></table></figure>

<h2 id="1-Prerequisite"><a href="#1-Prerequisite" class="headerlink" title="1. Prerequisite"></a>1. Prerequisite</h2><ul>
<li>Math<ul>
<li>Calculus (微积分)</li>
<li>Linear algebra (线性代数)</li>
<li>Probability (概率)</li>
</ul>
</li>
<li>Programming<ul>
<li>Python</li>
<li>PyTorch</li>
</ul>
</li>
<li>Hardware:不需要硬件设备，在Google Colab上运行</li>
</ul>
<h2 id="2-Assignment"><a href="#2-Assignment" class="headerlink" title="2. Assignment"></a>2. Assignment</h2><ul>
<li><p>multiple-choice questions（多选）：submitted via NTU COOL</p>
</li>
<li><p>Leaderboard（排行榜）：Kaggle or JudgeBoi (our in-house Kaggle  )</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110271932872.png" alt="Assignment Schedule" style="zoom:50%;" align="left" /></li>
</ul>
<h2 id="3-Lecture-Schedule"><a href="#3-Lecture-Schedule" class="headerlink" title="3. Lecture Schedule"></a>3. Lecture Schedule</h2><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110271937805.jpg" alt="Lecture Schedule" style="zoom:40%;" align="left"/>

<h2 id="4-Kaggle-JudgeBoi-is-similar"><a href="#4-Kaggle-JudgeBoi-is-similar" class="headerlink" title="4. Kaggle (JudgeBoi is similar)"></a>4. Kaggle (JudgeBoi is similar)</h2><ul>
<li>Register a Kaggle account by yourself 注册自己账号</li>
<li>select two results for evaluating on the private set before the assignment deadline</li>
<li>limited submission times per day 每天提交有字数限制</li>
</ul>
<h1 id="01-2-Regression"><a href="#01-2-Regression" class="headerlink" title="01-2 Regression"></a>01-2 Regression</h1><blockquote>
<h2 id="Machine-Learning-≈-Looking-for-Function"><a href="#Machine-Learning-≈-Looking-for-Function" class="headerlink" title="Machine Learning  ≈ Looking for Function"></a>Machine Learning  ≈ Looking for Function</h2></blockquote>
<h2 id="1-Different-types-of-Functions"><a href="#1-Different-types-of-Functions" class="headerlink" title="1. Different types of Functions"></a>1. Different types of Functions</h2><ul>
<li><strong>Regression:</strong> The function outputs a scalar （输出固定值）</li>
<li><strong>Classification:</strong> Given options (<strong>classes</strong>), the function outputs the correct one (分类)</li>
<li><strong>Structured Learning:</strong> create something with structure (image, document)</li>
</ul>
<h2 id="2-How-to-find-a-function"><a href="#2-How-to-find-a-function" class="headerlink" title="2. How to find a function?"></a>2. How to find a function?</h2><blockquote>
<p>研究案例：YouTube Channel     （李宏毅老师YouTube频道观看量）</p>
<p><a href="https://www.youtube.com/c/HungyiLeeNTU">https://www.youtube.com/c/HungyiLeeNTU</a></p>
</blockquote>
<h3 id="2-1-Function-with-Unknown-Parameters"><a href="#2-1-Function-with-Unknown-Parameters" class="headerlink" title="2.1 Function with Unknown Parameters"></a>2.1 Function with Unknown Parameters</h3><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110272049047.png" alt="YouTube案例" style="zoom:50%;" align="left"/>

<blockquote>
<p>y: 2&#x2F;26日的观看量，x:2&#x2F;25日的观看量</p>
<p>w 和 b是将要从数据中学习的未知参数   W:<strong>weight</strong>  b:<strong>bias</strong></p>
</blockquote>
<h3 id="2-2-Define-Loss-from-Training-Data"><a href="#2-2-Define-Loss-from-Training-Data" class="headerlink" title="2.2 Define Loss from Training Data"></a>2.2 Define Loss from Training Data</h3><p>等高线图：梯度下降的方向与切线方向垂直  </p>
<p>证明：<a href="https://blog.csdn.net/chekongfu/article/details/85317288">人工智能数学基础04之：梯度等高线_智者之家-CSDN博客_机器学习等高线</a></p>
<p><strong>Loss损失函数</strong>：L(b,w),表示这组值有多好</p>
<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110272055908.png" alt="image-20211027204735464" style="zoom: 50%;" align="left"/> <img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110272055176.png" alt="image-20211027205518090" style="zoom:50%;" align="right"/></p>
<h3 id="2-3-Optimization"><a href="#2-3-Optimization" class="headerlink" title="2.3 Optimization"></a>2.3 Optimization</h3><p>$$<br>\begin{array}{l}<br>w^{<em>}, b^{</em>}&#x3D;\arg \min_{w, b}  L<br>\end{array}<br>$$</p>
<blockquote>
<p>Gradient Descent梯度下降   Local Minima 局部最优 Global Minima 全局最优</p>
</blockquote>
<ul>
<li><p>(Randomly) Pick initial values $w^0, b^0$ 随机初始化</p>
</li>
<li><p>Compute计算</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110272117754.png" alt="image-20211027211733695" style="zoom:50%;" align="left"/>
</li>
<li><p>Update w and b iteratively   交替更新w和b</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[Step 1:&lt;br /&gt;function with unknown] --&gt; B[Step 2: &lt;br /&gt;define loss from training data] </span><br><span class="line">B --&gt; C[Step 3:&lt;br /&gt; optimization ]</span><br></pre></td></tr></table></figure>

<h3 id="2-4-Sigmoid激活函数"><a href="#2-4-Sigmoid激活函数" class="headerlink" title="2.4 Sigmoid激活函数"></a>2.4 Sigmoid激活函数</h3><p>线性模型太简单，不能满足复杂问题的需要，因此我们需要建立更复杂的模型来拟合复杂曲线</p>
<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110272325187.png" alt="image-20211027232521119"></p>
<p>为了更好的拟合现实世界中复杂的曲线，就需要很多这样分段碎片（hard sigmoid），将它们和常数叠加就可以拟合出各种各样的线性折线</p>
<p>然而hard sigmoid需要用分段函数来表示，在分段函数处不可导，针对计算机来说处理分段函数也更加麻烦，因此可以使用更加圆滑的sigmoid函数来代替，如下图所示</p>
<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110272335279.png" alt="image-20211027233500190"></p>
<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110272336167.png" alt="image-20211027233615094"></p>
<blockquote>
<p>i：no. of sigmoid</p>
<p>j：no. of features</p>
</blockquote>
<p>以上是<strong>线性模型</strong>到<strong>非线性模型</strong>的过程，接下来介绍<strong>非线性模型</strong>到<strong>神经网络</strong>的过程</p>
<h2 id="3-Neural-Networks"><a href="#3-Neural-Networks" class="headerlink" title="3.Neural Networks"></a>3.Neural Networks</h2><blockquote>
<p>本部分展示了$y &#x3D; b + \sum_i :c_i sigmoid(b_i + \sum_j w_{ij}x_j)$公式由内到外的形成过程</p>
</blockquote>
<h3 id="3-1-b-i-sum-j-w-ij-x-j-形成过程"><a href="#3-1-b-i-sum-j-w-ij-x-j-形成过程" class="headerlink" title="3.1 $b_i + \sum_j w_{ij}x_j$形成过程"></a>3.1 $b_i + \sum_j w_{ij}x_j$形成过程</h3><img align = "left " src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281252711.png" alt="image-20211028125240578" style="zoom:50%;" />
i:1,2,3 no. of sigmoid
j:1,2,3 no. of features

<p>$w_{ij}$: weight for $x_j$ for i-th sigmoid </p>
<p>将系数抽象成矩阵</p>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281311792.png" alt="image-20211028131110717" style="zoom:60%;" />

<h3 id="3-2-sigmoid-b-i-sum-j-w-ij-x-j-形成过程"><a href="#3-2-sigmoid-b-i-sum-j-w-ij-x-j-形成过程" class="headerlink" title="3.2 $sigmoid(b_i + \sum_j w_{ij}x_j)$形成过程"></a>3.2 $sigmoid(b_i + \sum_j w_{ij}x_j)$形成过程</h3><img align ="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281320585.png" alt="image-20211028132034512" style="zoom:60%;" />

<h3 id="3-3-b-sum-i-c-i-sigmoid-b-i-sum-j-w-ij-x-j-形成过程"><a href="#3-3-b-sum-i-c-i-sigmoid-b-i-sum-j-w-ij-x-j-形成过程" class="headerlink" title="3.3 $b + \sum_i :c_i sigmoid(b_i + \sum_j w_{ij}x_j)$形成过程"></a>3.3 $b + \sum_i :c_i sigmoid(b_i + \sum_j w_{ij}x_j)$形成过程</h3><img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281404694.png" alt="image-20211028140402595" style="zoom:60%;" />

<h3 id="3-4-神经网络处理过程-Back-to-ML-Framework"><a href="#3-4-神经网络处理过程-Back-to-ML-Framework" class="headerlink" title="3.4 神经网络处理过程 Back to ML Framework"></a>3.4 神经网络处理过程 Back to ML Framework</h3><h4 id="3-4-1-Function-with-unknown-parameters"><a href="#3-4-1-Function-with-unknown-parameters" class="headerlink" title="3.4.1 Function with unknown parameters"></a>3.4.1 Function with unknown parameters</h4><p><img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281409777.png" alt="image-20211028140953706" style="zoom:60%;" />w、b、$c_T$、b组成参数矩阵$\theta$</p>
<h4 id="3-4-2-Loss"><a href="#3-4-2-Loss" class="headerlink" title="3.4.2 Loss"></a>3.4.2 Loss</h4><p>$$<br>L &#x3D; 1&#x2F;N \sum_ne_n<br>$$</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281416887.png" alt="image-20211028141604827" style="zoom:67%;" />

<h4 id="3-4-3-Optimization-of-New-Model"><a href="#3-4-3-Optimization-of-New-Model" class="headerlink" title="3.4.3 Optimization of New Model"></a>3.4.3 Optimization of New Model</h4><ul>
<li><p>$$<br>\theta&#x3D;<br>\begin{vmatrix}<br>\theta_1\<br>\theta_2\<br>\theta_3\<br>\vdots<br>\end{vmatrix}<br>\enspace\enspace\enspace\enspace<br>\theta^*&#x3D;\arg \min_\theta L<br>$$</p>
</li>
<li><p>随机初始化$\theta^0$</p>
</li>
</ul>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281431998.png" alt="image-20211028143107939" style="zoom:40%;" />



<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281444043.png" style="zoom:50%;" />

<blockquote>
<table>
<thead>
<tr>
<th>名词</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>Epoch</td>
<td>使用训练集的全部数据对模型进行一次完整训练，被称之为“<strong>一代训练</strong>”</td>
</tr>
<tr>
<td>Batch</td>
<td>使用训练集中的一小部分样本对模型权重进行一次反向传播的参数更新，这一小部分样本被称为“<strong>一批数据</strong>”</td>
</tr>
<tr>
<td>Iteration</td>
<td>使用一个Batch数据对模型进行一次参数更新的过程，被称之为“<strong>一次训练</strong>”</td>
</tr>
</tbody></table>
<p>一个例子说明：</p>
<p>N&#x3D;10000（10000个样本），B&#x3D;10（Batch size为10）</p>
<p>那么可以得出在一个epoch内更新了1000次参数</p>
</blockquote>
<h2 id="4-ReLU"><a href="#4-ReLU" class="headerlink" title="4. ReLU"></a>4. ReLU</h2><ul>
<li><img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281518156.png" alt="image-20211028151847079" style="zoom:50%;" />
两个ReLU合成了一个Hard Sigmoid</li>
</ul>
<p>系数c可以为复数，有负数时依然使用max而不使用min是为了更好的将公式合起来，更好表示</p>
<ul>
<li><img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281521055.png" alt="image-20211028152141997" style="zoom:50%;" />
Activation function**激活函数**
i变成2i是因为两个ReLU才能合成一个sigmoid




</li>
<li><p>激活函数模拟人脑内的神经元，因此这种结构被称为神经网络</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.怎么样才能处理更复杂的模型呢？</span><br><span class="line">	够多的ReLU和Sigmoid就可以模拟出各种复杂的曲线</span><br><span class="line">	现在也会用一层叠一层的方式，向深度发展（具体为什么，接下来的课程会讲），也就是深度学习</span><br><span class="line">	【注】过多的层数会造成过拟合</span><br><span class="line">2.课程将讲述的模型真的应用到了youtube频道的流量预测，每一层有100个ReLu</span><br></pre></td></tr></table></figure>

<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281531545.png" alt="image-20211028153132333" style="zoom: 33%;" />
深度学习模型的层数越来越多,预测误差也越来越小

















<h1 id="01-3-深度学习简介（To-Learn-More）"><a href="#01-3-深度学习简介（To-Learn-More）" class="headerlink" title="01-3 深度学习简介（To Learn More）"></a>01-3 深度学习简介（To Learn More）</h1><h2 id="1-深度学习历史"><a href="#1-深度学习历史" class="headerlink" title="1. 深度学习历史"></a>1. 深度学习历史</h2><ul>
<li><p>1958: Perceptron (linear model)</p>
</li>
<li><p>1969: Perceptron has limitation</p>
</li>
<li><p>1980s: Multi layer perceptron</p>
<ul>
<li>Do not have significant difference from DNN today</li>
</ul>
</li>
<li><p>1986: Backpropagation</p>
<ul>
<li>Usually more than 3 hidden layers is not helpful</li>
</ul>
</li>
<li><p>1989: 1 hidden layer is “good enough”, why deep?</p>
</li>
<li><p>2006: RBM initialization (breakthrough)</p>
</li>
<li><p>2009: GPU</p>
</li>
<li><p>2011: Start to be popular in speech recognition 语音辨识</p>
</li>
<li><p>2012: win ILSVRC image competition</p>
</li>
</ul>
<blockquote>
<p>这部分看看就行</p>
</blockquote>
<h2 id="2-神经网络（Neural-Network）"><a href="#2-神经网络（Neural-Network）" class="headerlink" title="2.神经网络（Neural Network）"></a>2.神经网络（Neural Network）</h2><p>把一个逻辑回归函数看作是一个“<strong>Neural</strong>”，这些神经元不同连接方式就构成了不同的神经网络结构。所有神经元的<strong>weights</strong>和<strong>biases</strong>组成了神经网络的参数$\theta$</p>
<h3 id="2-1-全连接前馈网络"><a href="#2-1-全连接前馈网络" class="headerlink" title="2.1 全连接前馈网络"></a>2.1 全连接前馈网络</h3><blockquote>
<p>Fully Connect Feedforward Network</p>
<p>给定一个网络结构，就是定义了一个函数集合</p>
</blockquote>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111040932704.png" alt="image-20211104093219575" style="zoom:50%;" />

<p>deep 就体现在有很多隐藏层</p>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111040935813.png" alt="image-20211104093518738" style="zoom:67%;" />

<p>把神经网络转化成矩阵运算</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111040952391.png" alt="image-20211104095205311" style="zoom:80%;" />

<p>输出层</p>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111040954041.png" alt="image-20211104095452979" style="zoom:67%;" />

<h3 id="2-2-应用举例：识别数字"><a href="#2-2-应用举例：识别数字" class="headerlink" title="2.2 应用举例：识别数字"></a>2.2 应用举例：识别数字</h3><ul>
<li><p>第一步：神经网络</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111040957516.png" alt="image-20211104095718448" style="zoom:67%;" />

<p>输出层分表表示数字是i(0-9)的概率</p>
<p>需要研究人员自己探索到更好的神经网络结构来实现好的函数设计</p>
</li>
<li><p>第二步：寻找好的函数</p>
<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041014018.png" alt="image-20211104101456912"></p>
</li>
<li><p>第三步：优化参数，找到最好的函数</p>
<ul>
<li><p>梯度下降优化参数</p>
</li>
<li><p>反向传播机制计算偏微分可能更有效率</p>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041023474.png" alt="image-20211104102334382" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<h3 id="2-3-FAQ"><a href="#2-3-FAQ" class="headerlink" title="2.3 FAQ"></a>2.3 FAQ</h3><ul>
<li>How many layers? How many neurons for each layer?</li>
<li>Trial and Error  +   Intution</li>
<li>用多层网络的计算减少了特征工程的工作</li>
<li>深度学习在NLP上没有那么好的效果</li>
<li>Can the structure be automatically determined? 自动找到更好的网络结构<ul>
<li>E.g. Evolutionary Artificial Neural Networks</li>
</ul>
</li>
<li>我们可以自己设计网络结构吗？<ul>
<li>当然可以，比如Convolutional Neural Network (CNN)</li>
</ul>
</li>
<li>深度学习一定是层数越多越好吗？  不是</li>
<li>每一层多添加神经元也可以实现同样的输出矩阵？为什么选择让网络结构更深而不是更宽呢？</li>
</ul>
<h3 id="2-4-深度学习扩展资料"><a href="#2-4-深度学习扩展资料" class="headerlink" title="2.4 深度学习扩展资料"></a>2.4 深度学习扩展资料</h3><ul>
<li>My Course: Machine learning and having it deep and structured<ul>
<li><a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_MLSD15_2.html">http://speech.ee.ntu.edu.tw/~tlkagk/courses_MLSD15_2.html</a></li>
<li>6 hour version: <a href="http://www.slideshare.net/tw_dsconf/ss62245351">http://www.slideshare.net/tw_dsconf/ss62245351</a></li>
</ul>
</li>
<li>“Neural Networks and Deep<ul>
<li>written by Michael Nielsen</li>
<li><a href="http://neuralnetworksanddeeplearning.com/">http://neuralnetworksanddeeplearning.com/</a></li>
</ul>
</li>
<li>“Deep Learning”<ul>
<li>written by Yoshua Bengio , Ian J. Goodfellow and Aaron Courville</li>
<li><a href="http://www.deeplearningbook.org/">http://www.deeplearningbook.org</a></li>
</ul>
</li>
</ul>
<h1 id="01-4-反向传播（To-Learn-More）"><a href="#01-4-反向传播（To-Learn-More）" class="headerlink" title="01-4 反向传播（To Learn More）"></a>01-4 反向传播（To Learn More）</h1><h2 id="1-梯度下降"><a href="#1-梯度下降" class="headerlink" title="1. 梯度下降"></a>1. 梯度下降</h2><p>神经网络的参数<br>$$<br>\theta &#x3D; \left {  w_1,w_2,…,b_1,b_2,…  \right }<br>$$<br>初始化$\theta_0$之后，逐步计算$\theta_1,\theta_2$…..</p>
<p>一个大的神经网络中有上百万的参数，为了更有效率的计算梯度下降，我们使用<strong>反向传播（backpropagation）</strong></p>
<h2 id="2-链式法则"><a href="#2-链式法则" class="headerlink" title="2. 链式法则"></a>2. 链式法则</h2><img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041053505.png" alt="image-20211104105312441" style="zoom:50%;" />

<p>case1：x变化一点，y就跟着变化一点，z也相应变化一点</p>
<p>case2：s变化一点，x和y就变化一点，z也随之变化；s通过两条路径影响z的变化</p>
<h2 id="3-反向传播"><a href="#3-反向传播" class="headerlink" title="3. 反向传播"></a>3. 反向传播</h2><img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041445343.png" alt="image-20211104144505209" style="zoom:50%;" />

<h3 id="3-1-前向传播"><a href="#3-1-前向传播" class="headerlink" title="3.1 前向传播"></a>3.1 前向传播</h3><blockquote>
<p>Forward pass，针对所有参数计算$\dfrac{\partial z}{\partial w}$</p>
</blockquote>
<p>根据<strong>链式法则</strong>可以将梯度下降中需要求解的<strong>偏微分</strong>分解，根据前文链式法则有如下公式成立<br>$$<br>\dfrac{\partial C}{\partial w}&#x3D; \dfrac{\partial C}{\partial z}    \dfrac{\partial z}{\partial w}<br>$$<br><img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041455924.png" alt="image-20211104145558857" style="zoom:67%;" /></p>
<p>如图，$\dfrac{\partial z}{\partial w}$的值就是weight前对应的输入值：$\dfrac{\partial z}{\partial w_1}&#x3D;x_1$，$\dfrac{\partial z}{\partial w_2}&#x3D;x_2$</p>
<img  align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041500754.png" alt="image-20211104150040687" style="zoom:50%;" />

<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041503239.png" alt="image-20211104150305176" style="zoom:50%;" />
      那么$\dfrac{\partial C}{\partial z}$该如何求呢？ 如下图，依然使用链式法则分解

<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041908378.png" alt="image-20211104151604648"></p>
<h3 id="3-2-反向传播"><a href="#3-2-反向传播" class="headerlink" title="3.2 反向传播"></a>3.2 反向传播</h3><blockquote>
<p>Backward pass</p>
<p>针对所有激活函数的输入$z$计算$\dfrac{\partial C} {\partial z}$</p>
</blockquote>
<p>接上文，想要求解$\dfrac{\partial C} {\partial z}$，必须要知道$\dfrac{\partial C} {\partial z^&#96;}$和$\dfrac{\partial C} {\partial z^{&#96;&#96;}}$，因为$w_3,w_4$,$\sigma^,(z)$是一个常数。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">关于为什么σ导数的值是确定的？</span><br><span class="line">    在进行参数初始化后，参数的值就固定下来了，每一次前向传播计算时，这些参数的值是不会变化的。参数不变化，由参数计算出来的函数值就不会发生变化，因此每个激活函数结点的σ导数值已经随着参数的确定而确定，并且已知。</span><br></pre></td></tr></table></figure>

<p>换一种视角（从后向前）看神经网络的结构，可以很好地理解偏微分的计算过程</p>
<p>反向传播约等于建立了一个反向的神经网络，用空间换时间</p>
<p>&#x3D;&#x3D;很想知道计算偏微分的式子为啥可以和这个神经网络的结构很好的对应上（可能要对偏微分的数学原理很清楚才能搞明白）&#x3D;&#x3D;</p>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041908248.png" alt="image-20211104161626409" style="zoom:50%;" />

<blockquote>
<p>灰色方块</p>
<p>​    输入：输入层数值和w</p>
<p>​    输出：z</p>
<p>圆形（激活函数）</p>
<p>​    输入：z</p>
<p>​    输出：a</p>
</blockquote>
<p>虽然这样看来，偏微分之间的关系更好理解了，但是$\dfrac{\partial C} {\partial z^&#96;}$和$\dfrac{\partial C} {\partial z^{&#96;&#96;}}$到底要怎么计算呢？</p>
<ul>
<li><p>case 1：之后就是输出层</p>
<p>问题变得简单了，直接计算就可以了</p>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041908388.png" alt="image-20211104163323083" style="zoom:67%;" />
</li>
<li><p>case2：之后连接的不是输出层</p>
<p>后面还有好多层才到达输出层，其实和直接到达输出层原理一样，就是不断的迭代计算，因为总有一个时刻会到达输出层。</p>
</li>
</ul>
<p>这样看来，从输出层着手逐步向前计算$\dfrac{\partial C} {\partial z}$会更简单，这就是&#x3D;&#x3D;后向传播机制&#x3D;&#x3D;</p>
<img align=left src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041908710.png" alt="image-20211104163717385" style="zoom:67%;" />

<h2 id="3-3-反向传播机制总结"><a href="#3-3-反向传播机制总结" class="headerlink" title="3.3 反向传播机制总结"></a>3.3 反向传播机制总结</h2><p>其实每进行一次参数的梯度下降迭代，都要把神经网络【从前往后】【从后往前】计算两遍</p>
<ul>
<li>【从前往后】根据给定的参数计算函数，在计算的过程中，每个激活函数的到数值都被计算出来了，$\dfrac{\partial Z} {\partial w}$也得到了计算。</li>
<li>【从后往前】为了寻找更好的参数，使用梯度下降的方法，要计算每一个参数的偏微分，但是计算偏微分从前往后太难求了，根据【从前往后】计算出的<strong>输出层值</strong>从后向前推更简便，算法效率更高。</li>
</ul>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041908500.png" alt="image-20211104164618904" style="zoom:67%;" />

<p>为什么要反着算呢？</p>
<p>​    从前往后算偏微分，算一个偏微分就要把后面的偏微分全都算了，倒着算的话只算一遍就好。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>机器学习，深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>60分钟入门PyTorch——自动求导autograd</title>
    <url>/2022/07/17/autograd/</url>
    <content><![CDATA[<h1 id="torch-autograd"><a href="#torch-autograd" class="headerlink" title="torch.autograd"></a>torch.autograd</h1><p><code>torch.autograd</code>是PyTorch自动求导的工具，求导支撑着神经网络的训练。</p>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>神经网络（NN）是作用在<strong>输入数据</strong>上的一系列嵌套函数的集合，这些函数由参数（weights和biases）定义，被存储在PyTorch的tensor中。</p>
<p>训练神经网络的两个步骤</p>
<ul>
<li><strong>前向传播</strong>：在前向传播中，NN尽最大努力猜测正确的输出结果。如何猜测呢？将输入数据送入到NN中的每一个函数进行处理。</li>
<li><strong>反向传播</strong>：在反向传播中，NN根据上一步骤猜测的误差来相应地调整参数。如何调整的？它通过从输出结果向回遍历，收集有关函数参数（梯度）的误差的导数，并使用梯度下降来优化参数。更多的细节可以参照3Blue1Brown的讲解视频。</li>
</ul>
<hr>
<h2 id="2-在PyTorch中的应用"><a href="#2-在PyTorch中的应用" class="headerlink" title="2. 在PyTorch中的应用"></a>2. 在PyTorch中的应用</h2><p>下面看一个示例的训练步骤，从torchvision中加载一个预训练的<strong>resnet18</strong></p>
<p><strong>模型</strong>。</p>
<p>使用随机数创建tensor去表示一张图片：有3个通道，高和宽均为64，相应的标签也用随机数初始化，形状为（1,1000）。</p>
<blockquote>
<p>该示例的工作运行在CPU上，而不是GPU（即使tensor被移动到CUDA上）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch,torchvision</span><br><span class="line"></span><br><span class="line">model = torchvision.models.resnet18(pretrained=<span class="literal">True</span>) <span class="comment"># 加载模型</span></span><br><span class="line">data = torch.rand(<span class="number">1</span>,<span class="number">3</span>,<span class="number">64</span>,<span class="number">64</span>) <span class="comment"># 创建输入数据</span></span><br><span class="line">labels = torch.rand(<span class="number">1</span>,<span class="number">1000</span>) <span class="comment"># 随机初始化标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将输入数据通过模型的每一层来进行预测，所谓前向传播</span></span><br><span class="line">prediction = model(data)</span><br><span class="line"><span class="comment"># 用模型预测值和标签计算误差（损失）</span></span><br><span class="line">loss = (prediction-labels).<span class="built_in">sum</span>()</span><br><span class="line"><span class="comment"># 使用损失，反向传播通过神经网络</span></span><br><span class="line"><span class="comment"># 在误差的tensor上使用.backward()，它会自动计算模型每一个参数的的梯度并存储在参数的.grad属性中</span></span><br><span class="line">loss.backward()</span><br><span class="line"><span class="comment"># 加载优化器:随机梯度下降</span></span><br><span class="line">optim = torch.optim.SGD(model.parameters(), lr=<span class="number">1e-2</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line"><span class="comment"># 使用.step()梯度下降，优化器会根据存储在.grad中的梯度值调整每一个参数</span></span><br><span class="line">optim.step()</span><br></pre></td></tr></table></figure>

<p>以上是训练一个神经网络的步骤，下面是autograd工作的一些细节——可以随意跳过它们</p>
<hr>
<h2 id="3-autograd中的求导"><a href="#3-autograd中的求导" class="headerlink" title="3. autograd中的求导"></a>3. autograd中的求导</h2><h3 id="autograd如何收集梯度呢？"><a href="#autograd如何收集梯度呢？" class="headerlink" title="autograd如何收集梯度呢？"></a>autograd如何收集梯度呢？</h3><p>创建两个tensor：a和b，<code>requires_grad=True</code>，这表明<code>autograd</code>会追踪a和b上的每一个操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">a = torch.tensor([<span class="number">2.</span>, <span class="number">3.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.tensor([<span class="number">6.</span>, <span class="number">4.</span>], requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>使用a和b创建另一个张量Q<br>$$<br>Q &#x3D; 3a^3 - b^2<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Q = 3*a**3 - b**2</span><br></pre></td></tr></table></figure>

<p>假设a和b是神经网络的参数，Q是损失，在训练网络时，需要计算损失的参数的梯度<br>$$<br>\frac{\partial Q}{\partial a} &#x3D; 9a^2 \<br>\frac{\partial Q}{\partial b} &#x3D; -2b<br>$$<br>执行Q.backward()，会自动计算这些梯度，同时在相应的tensor.grad属性中存储。</p>
<p>我们需要在执行<code>Q.backward()</code>时显式传递<code>gradient</code>属性，因为这里的gradient是一个<strong>向量</strong>，和Q形状相同，它表示Q的梯度<br>$$<br>\frac{dQ}{dQ}&#x3D;1<br>$$<br>同样地，可以把Q聚合成标量，然后隐式地反向传播：<code>Q.sum().backward()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">external_grad = torch.tensor([<span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line">Q.backward(gradient=external_grad)</span><br></pre></td></tr></table></figure>

<p>现在梯度被保存在<code>a.grad</code>和<code>b.grad</code>中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查收集到的梯度是否正确</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">9</span>*a**<span class="number">2</span> == a.grad)</span><br><span class="line"><span class="built_in">print</span>(-<span class="number">2</span>*b == b.grad</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor([<span class="literal">True</span>, <span class="literal">True</span>])</span><br><span class="line">tensor([<span class="literal">True</span>, <span class="literal">True</span>])</span><br></pre></td></tr></table></figure>



<h3 id="选读：用autograd进行向量计算"><a href="#选读：用autograd进行向量计算" class="headerlink" title="选读：用autograd进行向量计算"></a>选读：用autograd进行向量计算</h3><p>在数学上，如果有一个向量值函数：$\vec y &#x3D; f(\vec x)$，用$\vec x$表示的梯度$\vec y$是雅克比矩阵(Jacobian matrix)$J$<br>$$<br>J &#x3D; (\frac{\partial y}{\partial x_1}…\frac{\partial y}{\partial x_n})&#x3D;<br>\begin{pmatrix}<br>\frac{\partial y_1}{\partial x_1} &amp; … &amp; \frac{\partial y_1}{\partial x_n} \<br>.&amp;&amp;.\.&amp;.&amp;.\.&amp;&amp;.\<br>\frac{\partial y_m}{\partial x_1} &amp; … &amp; \frac{\partial y_m}{\partial x_n}<br>\end{pmatrix}<br>$$<br>通常来说，<code>torch.autograd</code>是计算向量雅克比乘积的工具，也就是，给定一个向量$\vec v$，计算乘积$J^T<em>\vec v$。如果$\vec v$是标量函数$l&#x3D;g(\vec y)$的梯度:<br>$$<br>\vec v &#x3D; (\frac{\partial l}{\partial y_1}…\frac{\partial l}{\partial y_m})^T<br>$$<br>根据链式法则，用$\vec x$来表示$l$的梯度，即为*<em>向量-雅克比矩阵 乘积</em></em>&#x3D;&#x3D;图片未上传成功&#x3D;&#x3D;</p>
<p><img src="C:/Users/TSY/Desktop/Snipaste_2022-07-17_21-23-00.png" alt="Snipaste00"></p>
<p>向量雅可比积的这种特性使得将外部梯度馈送到具有非标量输出的模型中非常方便，也是在我们上面的例子中使用的，<code>external_grad</code>代表$\vec v$。</p>
<hr>
<h2 id="4-计算图-Computational-Graph"><a href="#4-计算图-Computational-Graph" class="headerlink" title="4. 计算图(Computational Graph)"></a>4. 计算图(Computational Graph)</h2><p>从概念上讲，<code>autograd</code>在由函数对象组成的<strong>有向无环图(DAG)<strong>中保存数据(tensor)和所有执行的操作（以及由操作产生的新tensor）。在这个DAG中，叶子节点是输入tensors，根节点是输出tensors。从根节点到叶子节点来追踪这个图，可以使用</strong>链式法则</strong>来自动计算梯度。</p>
<p>在前向传播中，autograd同时做两件事情：</p>
<ul>
<li>运行所请求的操作来计算<strong>输出tensor</strong></li>
<li>在DAG中保存操作的梯度</li>
</ul>
<p>当在DAG根节点上调用<code>.backward()</code>时，反向传播开始启动，<code>autograd</code>会做一系列操作：</p>
<ul>
<li>计算每一个<code>.grad_fn</code>的梯度</li>
<li>将它们累加到各自tensor的<code>.grad</code>属性中</li>
<li>使用链式法则，一直传播到叶子节点的tensors</li>
</ul>
<p>下图是我们示例的DAG可视化表示。在图中，箭头表示前向传播的方向，节点表示在前向传播中的每个操作的向后函数，蓝色的叶子节点表示张量a和b。</p>
<p><img src="https://pytorch.org/tutorials/_images/dag_autograd.png" alt="../../_images/dag_autograd.png"></p>
<blockquote>
<p>DAG在PyTorch中是动态的，在每一次调用.backward()之后，计算图是重新开始创建的，autograd会重新填充一个新的图，这就是允许在模型中使用控制流语句的原因。</p>
<p>可以根据需求在每次迭代时更改形状、大小和操作。</p>
</blockquote>
<h3 id="从DAG中删除-Exclusion-from-the-DAG"><a href="#从DAG中删除-Exclusion-from-the-DAG" class="headerlink" title="从DAG中删除(Exclusion from the DAG)"></a>从DAG中删除(Exclusion from the DAG)</h3><p>如果<code>requires_grad</code>设置为True，<code>torch.autograd</code>就可以追踪对tensor的相关操作。如果不需要tensor的梯度，把属性设置成False就可以从DAG的梯度计算中排除。</p>
<p>即使只有一个简单的输入tensor的<code>requires_grad=True</code>，输出tensors也需要梯度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.rand(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">y = torch.rand(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">z = torch.rand((<span class="number">5</span>, <span class="number">5</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">a = x + y</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Does `a` require gradients? : <span class="subst">&#123;a.requires_grad&#125;</span>&quot;</span>)</span><br><span class="line">b = x + z</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Does `b` require gradients?: <span class="subst">&#123;b.requires_grad&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Does `a` require gradients? : <span class="literal">False</span></span><br><span class="line">Does `b` require gradients?: <span class="literal">True</span></span><br></pre></td></tr></table></figure>



<p>在一个网络结构中，通常把不需要计算梯度的参数称为冻结参数（<strong>frozen parameters</strong>）。如果提前知道哪些参数不需要计算梯度，模型的冻结功能非常有用，还可以通过减少梯度计算来提升性能受益。</p>
<p>另一个从DAG中删除的应用是<strong>微调一个预训练的模型</strong></p>
<p>在微调的过程中，会冻结模型中的大部分，通常只修改分类层来预测新的标签。让我们通过一个小例子来说明，向以前一样，我们加载预训练模型resnet18，并且冻结所有参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn,optim</span><br><span class="line">model = torchvision.models.resnet18(pretrained=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 冻结网络中的所有参数</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> model.parameters():</span><br><span class="line">    param.requires_grad = <span class="literal">False</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">目的：在有10个标签的新数据集上微调模型</span></span><br><span class="line"><span class="string">resnet最后一层的线性分类器为：model.fc</span></span><br><span class="line"><span class="string">我们可以简单的使用一个新的线性层（默认未冻结）来代替它作为分类器</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">model.fc = nn.Linear(<span class="number">512</span>,<span class="number">10</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">现在除了model.fc的参数，模型的所有参数被冻结了</span></span><br><span class="line"><span class="string">只有model.fc的weights和bias来参与梯度计算</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">1e-2</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure>

<p>【注意】尽管我们在优化器中注册了所有参数，只有分类器的weights和bias计算梯度并使用梯度下降更新，<code>torch.no_grad()</code>也有同样的功能</p>
<hr>
<h2 id="5-拓展阅读"><a href="#5-拓展阅读" class="headerlink" title="5. 拓展阅读"></a>5. 拓展阅读</h2><p><strong><a href="https://pytorch.org/docs/stable/notes/autograd.html">in-place操作&amp;多线程autograd</a></strong></p>
<p><strong><a href="https://colab.research.google.com/drive/1VpeE6UvEPRz9HmsHh1KS0XxXjYu533EC">反向模式autodiff的例子</a></strong></p>
]]></content>
      <categories>
        <category>深度学习： PyTorch</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>02 机器学习任务攻略——李宏毅深度学习2021春</title>
    <url>/2021/11/07/02%20Deep%20Learning%E2%80%94%E2%80%94%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2021%E6%98%A5/</url>
    <content><![CDATA[<h1 id="02-1-机器学习任务攻略（General-Guidance）"><a href="#02-1-机器学习任务攻略（General-Guidance）" class="headerlink" title="02-1 机器学习任务攻略（General Guidance）"></a>02-1 机器学习任务攻略（General Guidance）</h1><p><strong>机器学习任务框架</strong></p>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111042034399.png" alt="image-20211104203451301" style="zoom:67%;" />

<p>从训练数据中找到最优化的参数$\theta^*$，将$\theta^*$带入到假设函数中预测结果</p>
<p>当机器学习任务预测的结果不满意时，可以按照下图所示方法检查问题出现在哪</p>
<p>发现问题从训练集<strong>loss</strong>值开始</p>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111042040700.png" alt="image-20211104204008635" style="zoom: 67%;" />



<h2 id="1-训练集loss值大"><a href="#1-训练集loss值大" class="headerlink" title="1. 训练集loss值大"></a>1. 训练集loss值大</h2><h3 id="1-1-模型偏差"><a href="#1-1-模型偏差" class="headerlink" title="1.1 模型偏差"></a>1.1 模型偏差</h3><blockquote>
<p>model bias</p>
</blockquote>
<ul>
<li>原因：模型太简单了，不够复杂，弹性不够大，不能拟合很多复杂情况。</li>
<li>解决方法：重新设计更复杂的模型<ul>
<li>增加特征</li>
<li>使用深度学习（更多的神经元和层数）</li>
</ul>
</li>
</ul>
<h3 id="1-2-优化问题"><a href="#1-2-优化问题" class="headerlink" title="1.2 优化问题"></a>1.2 优化问题</h3><blockquote>
<p>Optimization</p>
</blockquote>
<ul>
<li><p>原因：可能陷入<strong>局部最优解</strong>，没有得到参数的最优方案。</p>
</li>
<li><p>解决方法：探寻更好的优化方法</p>
</li>
<li><p>思考：如果在训练集上<strong>损失值很大</strong>，不一定是因为这个模型太复杂导致过拟合，很可能是因为没有做好优化，致使复杂的模型没有表现出更好的效果。</p>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111042058554.png" alt="image-20211104205810485" style="zoom: 67%;" />

<p>如图，看到测试集数据，我们很容易认为这是<strong>过拟合</strong>问题，但是检查训练数据后才发现，比【20层模型】更有弹性、更复杂的【56层模型】竟然在训练集数据上表现的没有【20层模型】。</p>
<p>越复杂的模型就越能拟合训练集的数据，出现这种反常情况，就是因为没有做好模型优化，也就是说<strong>参数的优化问题</strong>限制了【56层模型】的发挥。</p>
<p>那如何判断复杂模型性能不好是因为过拟合还是参数优化问题呢？</p>
<ul>
<li>同时从<strong>测试集</strong>和<strong>训练集</strong>的实验结果中分析</li>
<li>从更容易训练的较浅的网络（或其他模型）开始</li>
<li>如果更深的网络在训练数据上没有获得更小的损失，则存在优化问题</li>
</ul>
</li>
</ul>
<h2 id="2-训练集loss值小"><a href="#2-训练集loss值小" class="headerlink" title="2. 训练集loss值小"></a>2. 训练集loss值小</h2><p>训练集loss值小就要去检查<strong>测试集的loss值</strong>了</p>
<h3 id="2-1-训练集loss值小-amp-测试集loss小"><a href="#2-1-训练集loss值小-amp-测试集loss小" class="headerlink" title="2.1 训练集loss值小&amp;测试集loss小"></a>2.1 训练集loss值小&amp;测试集loss小</h3><p>模型很成功</p>
<h3 id="2-2-训练集loss值小-amp-测试集loss大"><a href="#2-2-训练集loss值小-amp-测试集loss大" class="headerlink" title="2.2  训练集loss值小&amp;测试集loss大"></a>2.2  训练集loss值小&amp;测试集loss大</h3><h4 id="2-2-1-过拟合"><a href="#2-2-1-过拟合" class="headerlink" title="2.2.1 过拟合"></a>2.2.1 过拟合</h4><blockquote>
<p>Overfitting</p>
</blockquote>
<ul>
<li><p>原因：在训练集中模型自由发展，过度地拟合了训练集中的数据，不能很好的泛化。</p>
</li>
<li><p>解决方法：</p>
<ul>
<li><p>提供更多的训练数据</p>
<ul>
<li>寻找更多的数据来训练</li>
<li>根据对特定问题的了解<strong>扩充数据</strong></li>
</ul>
</li>
<li><p>给模型一些<strong>限制</strong></p>
<ul>
<li>规定假设函数的形式，就起到了限制模型的作用。比如一个二次函数，怎么更改参数形状也不会随意变化</li>
<li>设置更少数量的参数或共享参数（比如减少神经元的数量）</li>
<li>正则化</li>
<li>Early spotting</li>
<li>Dropout</li>
</ul>
<blockquote>
<p>限制也不能太多哦，如果只是一个一次函数，再怎么训练也不能拟合复杂的数据，这就又回到了<strong>模型偏差</strong>的问题</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-2-mismatch"><a href="#2-2-2-mismatch" class="headerlink" title="2.2.2 mismatch"></a>2.2.2 mismatch</h4><ul>
<li><p>原因：训练集和测试集不匹配，简单地提升训练数据于事无补。</p>
<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111051432295.png" alt="image-20211105143219217"></p>
</li>
</ul>
<h2 id="3-交叉验证"><a href="#3-交叉验证" class="headerlink" title="3. 交叉验证"></a>3. 交叉验证</h2><p>在训练的时候使用交叉验证，比如<strong>N折交叉验证</strong></p>
<h1 id="02-2-临界点"><a href="#02-2-临界点" class="headerlink" title="02-2 临界点"></a>02-2 临界点</h1><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111051625534.png" alt="image-20211105162515443" style="zoom: 33%;" />

<p>如上图所示，在使用梯度下降方法训练时，很有可能出现<strong>loss值不够小</strong>或者<strong>loss值干脆不变化</strong>的情况，到达临界点后再怎么训练也于事无补。</p>
<p>两种可能：<strong>局部最小值（local minima）</strong>和到达<strong>鞍点（saddle point）</strong></p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111051633185.png" alt="image-20211105163301079" style="zoom: 50%;" />

<p>到达局部最优解就意味着随机下降真的无路可走了，但是到达鞍点还可以通过计算识别并逃离。</p>
<h2 id="1-数学知识-泰勒公式"><a href="#1-数学知识-泰勒公式" class="headerlink" title="1. 数学知识-泰勒公式"></a>1. 数学知识-泰勒公式</h2><blockquote>
<p>Tayler Series Approximation </p>
</blockquote>
<p>根据泰勒公式，$\theta^&#96;$周围的公式可以表示成如下形式</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111091745706.png" alt="image-20211109174520587" style="zoom:50%;" />

<p>其中<strong>g</strong>和<strong>H</strong>是两个矩阵</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111091749507.png" alt="image-20211109174922459" style="zoom:60%;" />

<p>在临界点的时候，<strong>g为零向量</strong>，只剩下原式子的第三项，我们可以根据第三项的<strong>正负号</strong>来判断这个点是<strong>局部最优解</strong>还是<strong>鞍点</strong>。</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111091752661.png" alt="image-20211109175258600" style="zoom:67%;" />

<p>如果第三项<strong>一直是正数</strong>，代表$\theta^&#96;$周围的值都比它大，那么它是局部最小值</p>
<p>如果第三项<strong>一直是负数</strong>，代表$\theta^&#96;$周围的值都比它小，那么它是局部最大值</p>
<p>如果第三项<strong>有正有负</strong>，代表$\theta^&#96;$周围既有比它大的值也有比它小的值，那么它是鞍点，还可以找到方式来优化</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111091759702.png" alt="image-20211109175959619" style="zoom: 60%;" />

<h2 id="2-例子-判断是局部最小值还是鞍点"><a href="#2-例子-判断是局部最小值还是鞍点" class="headerlink" title="2. 例子-判断是局部最小值还是鞍点"></a>2. 例子-判断是局部最小值还是鞍点</h2><p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111091813921.png" alt="image-20211109181317865"></p>
<p>$\lambda_1$为正，$\lambda_2$为负，说明这是一个<strong>鞍点</strong>，<strong>矩阵H</strong>会帮助我们计算接下来递归下降的方向。</p>
<p>假设$u$是H的特征向量，$\lambda$是$u$的特征值，如果$\lambda&lt;0$，则有如下推导：</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111091823574.png" alt="image-20211109182307518" style="zoom:67%;" />

<p>当$\lambda&#x3D;-2$时，有特征向量<br>$$<br>u&#x3D;<br>\begin{vmatrix}<br>1  \<br>1<br>\end{vmatrix}<br>$$<br>沿着这个方向更新参数，就可以逃离鞍点，减小损失函数的值</p>
<blockquote>
<p>展望：当有很多参数存在时，局部最小值可能是罕见的。</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111091831368.png" alt="image-20211109183104296" style="zoom:50%;" />
</blockquote>
<h2 id="3-批处理Batch"><a href="#3-批处理Batch" class="headerlink" title="3. 批处理Batch"></a>3. 批处理Batch</h2><p>借用下图回顾一下用批处理方法来做优化的形式</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111092132287.png" alt="image-20211109213204206" style="zoom:50%;" />

<p>1个<strong>epoch</strong> &#x3D; 1次更新所有的batches，在每一个<strong>epoch</strong>之后<strong>Shuffle</strong></p>
<p>接下来比较<strong>Small Batch</strong>和<strong>Large Batch</strong>（small batch就是batch size小）</p>
<p>假设有20个样本，分两种Batch size训练</p>
<blockquote>
<p>左图：Batch size &#x3D; N (Full Batch)   20个样本更新一次，共更新一次</p>
<p>右图：Batch size &#x3D; 1  每个样本更新一次，共更新20次</p>
</blockquote>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111100918927.png" alt="image-20211110091821813" style="zoom:50%;" />

<ul>
<li><p>按照正常的想法，如果batch size越大，<strong>训练时间</strong>就会越长。但是随着<strong>GPU</strong>的发展，计算机并行计算能力加强，除非batch size特别大，不然batch size的大小几乎不会影响训练时间。</p>
</li>
<li><p><strong>batch size太小</strong>每训练一个<strong>epoch</strong>花费时间就更长</p>
</li>
</ul>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111100930768.png" alt="image-20211110093040684" style="zoom:50%;" />

<ul>
<li><strong>small batch</strong>在训练时会体现出更好的<strong>性能</strong></li>
</ul>
<p>​    <img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111100933135.png" alt="image-20211110093327068" style="zoom: 67%;" /></p>
<p>​    为什么会有这样奇怪的现象呢？</p>
<p>​    其实每一个batch内就有一个<strong>新的样本分布形式</strong>，batch数量越多，数据的分布形式就越多，每一次更新时<strong>损    失函数</strong>都有所变化，不容易卡在某个位置。</p>
<p>​    <img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111100938327.png" alt="image-20211110093813280" style="zoom:50%;" /></p>
<p>​    左图Full Batch卡在某一个地方之后，就没办法继续走下去了。但是如果分了很多batch,就有多次更新的机会，在一个batch中卡住不要紧，可能会在下一个batch中继续求出梯度。逐步优化。</p>
<ul>
<li><p>batch数量多有有助于<strong>泛化</strong>，在测试集上表现效果更好。</p>
<blockquote>
<p>引用On Large Batch Training for Deep Learning: Generalization Gap and Sharp Minima(<a href="https://arxiv.org/abs/1609.04836)%E7%9A%84%E7%BB%93%E6%9E%9C">https://arxiv.org/abs/1609.04836)的结果</a></p>
</blockquote>
<p>实验发现：在训练集上把<strong>大的batch</strong>和<strong>小的batch</strong>训练的差不多好，但是在测试集上<strong>小的batch</strong>表现更好。</p>
<p>如何解释这一现象呢？论文作者有如下猜想。</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111100955858.png" alt="image-20211110095516754" style="zoom:50%;" />

<p>图中<strong>实线</strong>为<strong>训练集</strong>的loss曲线，<strong>虚线</strong>为<strong>测试集</strong>的loss曲线。每一个问题的loss曲线都会遇到各种<strong>局部最小值</strong>，有的较平坦，有的较陡峭，想比较而言，我们更喜欢<strong>较平坦</strong>的局部最小值。</p>
<p>由于样本抽取不同等原因，训练集loss和测试集loss的分布会存在一定偏差，图中是假设测试集loss向右平移。这样一来，在<strong>较陡峭局部最小值</strong>的地方可能在测试集中对应着较大的loss值，导致泛化能力很差</p>
</li>
</ul>
<p><strong>总结</strong></p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111101002845.png" alt="image-20211110100230779" style="zoom:67%;" />

<p>&#x3D;&#x3D;<strong>Batch Size</strong>也是一个需要决定的<strong>参数</strong>哦&#x3D;&#x3D;</p>
<h2 id="4-Momentum"><a href="#4-Momentum" class="headerlink" title="4. Momentum"></a>4. Momentum</h2><blockquote>
<p>解决优化损失函数时，卡在局部最小值时的状况。</p>
</blockquote>
<h3 id="4-1-梯度下降"><a href="#4-1-梯度下降" class="headerlink" title="4.1 梯度下降"></a>4.1 梯度下降</h3><p>每一次梯度下降的方向都是某一点<strong>偏导数的反方向</strong></p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111101017888.png" alt="image-20211110101759828" style="zoom:50%;" />

<h3 id="4-2-梯度下降-动量"><a href="#4-2-梯度下降-动量" class="headerlink" title="4.2 梯度下降+动量"></a>4.2 梯度下降+动量</h3><p>移动方向 &#x3D; 上一步移动方向 - 现在的梯度方向</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111101020945.png" alt="image-20211110102006879" style="zoom:50%;" />

<p>每一次移动的方向都考量了前面所有方向<br>$$ {align*}<br>m^0 &#x3D;0 \<br>m^1 &#x3D; -\eta g^0 \<br>m^2 &#x3D; - \lambda \eta g^0 - \eta g^1\<br>……<br>$$ {align*}<br><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111101030250.png" alt="image-20211110103003184" style="zoom:50%;" /></p>
<p>如图，在局部最小值仍然可以向前移动，这是因为，前边累加了太多的力量，可以让它逃离局部最小值。</p>
<h2 id="5-临界点总结"><a href="#5-临界点总结" class="headerlink" title="5.临界点总结"></a>5.临界点总结</h2><ul>
<li><strong>临界点</strong>的梯度是<strong>0</strong></li>
<li>临界点可能是<strong>鞍点</strong>或<strong>局部最小值</strong><ul>
<li><strong>Hessian矩阵</strong>可以帮助缺点临界点是<strong>鞍点</strong>还是<strong>局部最小值</strong></li>
<li>局部最小值的情况很<strong>罕见</strong></li>
<li>根据<strong>Hessian矩阵特征向量</strong>可以逃离<strong>鞍点</strong></li>
</ul>
</li>
<li><strong>小的Batch Size</strong>和<strong>动量（Momentum）</strong>可以帮助逃离临界点</li>
</ul>
<h1 id="02-3-学习率"><a href="#02-3-学习率" class="headerlink" title="02-3 学习率"></a>02-3 学习率</h1><h2 id="1-Adaptive-Learning-Rate"><a href="#1-Adaptive-Learning-Rate" class="headerlink" title="1. Adaptive Learning Rate"></a>1. Adaptive Learning Rate</h2><p>很多时候训练模型卡住了都不是因为临界点（梯度很小或者无法再下降），因为在loss值几乎稳定的时候，很有可能梯度并不是0，而且在反复横跳。多数训练在还没有走到临界点时就已经停止了。</p>
<p><strong>不同的参数需要不同的学习率</strong>，有一个大致的原则，如果有一个方向很平缓，希望学习率大一点；如果很陡峭，希望学习率小一点。</p>
<p>以一个参数$\theta_i$为例，其他可以推广</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152015703.png" alt="image-20211115201533635" style="zoom:50%;" />

<p>不同的参数有不同的$\sigma$，同一个参数不同的迭代次数$\sigma$的值也不同。</p>
<p>如何计算$\sigma$?有不同的策略</p>
<h3 id="1-1-Root-Mean-Square"><a href="#1-1-Root-Mean-Square" class="headerlink" title="1.1 Root Mean Square"></a>1.1 Root Mean Square</h3><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152018883.png" alt="image-20211115201857815" style="zoom:50%;" />

<p>这种策略在Adagrad中被使用，这一方法为什么奏效呢？设想一下有$\theta_1$和$\theta_2$两种曲线：</p>
<ul>
<li><p>$\theta_1$更平滑，计算得到的g就更小，$\sihma$就更小，相应地学习率就变大</p>
</li>
<li><p>$\theta_2$更陡峭，计算得到的g就更大，$\sihma$就更大，相应地学习率就变小</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152024449.png" alt="image-20211115202409401" style="zoom:50%;" /></li>
</ul>
<p>但是这种方法并不总是有效的，因为很多时候即使在同一个方向我们也希望学习率的大小是有变化的，可以动态调整。于是出现了RMSProp</p>
<h3 id="1-2-RMSProp"><a href="#1-2-RMSProp" class="headerlink" title="1.2 RMSProp"></a>1.2 RMSProp</h3><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152027157.png" alt="image-20211115202703094" style="zoom:50%;" />

<p><strong>$(1-\alpha)$可以动态地调整</strong></p>
<p>现在最常用的策略就是<strong>Adam:RMSProp+Momentum</strong>(pyTorch可以掉包)</p>
<h3 id="1-3-Learning-Rate-Scheduling"><a href="#1-3-Learning-Rate-Scheduling" class="headerlink" title="1.3 Learning Rate Scheduling"></a>1.3 Learning Rate Scheduling</h3><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152039818.png" alt="image-20211115203907761" style="zoom:60%;" />

<p>在梯度下降的过程中为什么会出现横跳的情况呢？因为本来梯度很小，逐渐行走，但是<strong>多个小的梯度累加之后</strong>，$\sigma$就会产生变化，方向也就跟着改变了，但是会逐步调整回来</p>
<p>这个时候可以给学习率加一个<strong>时间</strong>的变化，比如：随着训练的进行，$\eta^t$越来越小；也可以先增大再减小</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152045004.png" alt="image-20211115204504958" style="zoom:50%;" />

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152046382.png" alt="image-20211115204626330" style="zoom:50%;" />

<p>warm up没有一个有说服力的解释，只是由训练时的经验得到。</p>
<blockquote>
<p>warm up可能的解释：一开始学习率小一点，有助于学到更多关于error surface的知识</p>
</blockquote>
<h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><p>学习率有多种方式去改变它，只不过课上讲解的方式更常用，还可以加<strong>动量</strong>。</p>
<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152051866.png" alt="image-20211115205100819"></p>
<p>动量m和$\theta$都是结合了过去所有的梯度，一个在分子一个在分母，会不会抵消掉呢？不会的，一个重点结合过去的方向，一个重点结合过去的大小。</p>
<p>我们还可以有其他方法来解决训练时遇到的问题，比如试试改变<strong>error surface</strong>呢？把它变得更平滑。</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152055323.png" alt="image-20211115205531215" style="zoom:50%;" />

<h1 id="02-4-Batch-Normalization"><a href="#02-4-Batch-Normalization" class="headerlink" title="02-4 Batch Normalization"></a>02-4 Batch Normalization</h1><h2 id="1-改变landscape"><a href="#1-改变landscape" class="headerlink" title="1. 改变landscape"></a>1. 改变landscape</h2><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111161935633.png" alt="image-20211116193532495" style="zoom: 67%;" />

<p>如图所示，w变化一点，y就会变化一点，相应地L就会变化一点。但是$x1$很小，变化$w_1$对L的影响就很小；$x_2$很大，变化$w_2$对L的影响就很大。这样每个特征对损失函数的影响不同，如果让特征里不同的维度有同样的数值范围，就可以制造比较好的error surface，训练就变得容易一些。</p>
<h2 id="2-Feature-Normalization"><a href="#2-Feature-Normalization" class="headerlink" title="2. Feature Normalization"></a>2. Feature Normalization</h2><blockquote>
<p>有很多方法，只介绍其中几种</p>
</blockquote>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111161944428.png" alt="image-20211116194440336" style="zoom: 60%;" />

<p>考虑深度学习的特征标准化，对<strong>激活函数前的z</strong>和<strong>激活函数后的a</strong>做标准化都可以，如果激活函数是sigmoid，推荐在其之前标准化，因为sigmoid函数在0附近斜率比较大，算出来的gradient也比较大。</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111161952647.png" alt="image-20211116195202506" style="zoom: 33%;" />

<p>以标准化z为例</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111161954557.png" alt="image-20211116195426467" style="zoom: 67%;" />

<p>和以前神经网络不同的是，现在变化$z_1$会对三个输出层都有影响（因为它参与计算了平均数和标准差）。</p>
<p>每一层神经网络都要标准化，这样网络变得更大了，GPU的运算能力可能无法承载。所以要引入<strong>batch</strong>，在每一个batch内部进行标准化，这就是<strong>Batch Normalization</strong>。</p>
<p>为了不让z在0之间活动，对<strong>标准化后的z</strong>，做一些更改<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111162003235.png" alt="image-20211116200315192" style="zoom:67%;" /></p>
<h2 id="3-批处理标准化——测试"><a href="#3-批处理标准化——测试" class="headerlink" title="3. 批处理标准化——测试"></a>3. 批处理标准化——测试</h2><p>如果是线上的应用，模型是要随时预测数据的，不能等到积累了一个batch size大小的数据才开始训练（计算平均值和标准差等）。解决这一困境的方式就是计算<strong>滑动窗口（moving average)</strong></p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111162009766.png" alt="image-20211116200939720" style="zoom:60%;" />

<p>记录下每一个batch的平均值，以便后续计算，p也是参数</p>
<p>其他知名的正则化方式</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111162015783.png" alt="image-20211116201512724" style="zoom:67%;" />

<h1 id="02-5-分类"><a href="#02-5-分类" class="headerlink" title="02-5 分类"></a><strong>02-5 分类</strong></h1><blockquote>
<p>李宏毅老师y表示的是预测值，$\hat{y}$表示真实值</p>
</blockquote>
<p>分类类似于回归，但是输出值如果是1,2,3等数字来代表类别会有一些问题，比如是不是1和2更接近，1和3更远？这些数字可以在数学上区别开来，所以应该换一种方式表示。</p>
<p>想要预测三个类别，我们就可以让神经网络输出三个结果组成矩阵，采用<strong>one-hot编码</strong>来预测类别</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152128746.png" alt="image-20211115212856681" style="zoom:50%;" />

<p>与回归不同的时，在分类时，预测值y通常需要<strong>softmax函数</strong>转换为$y^&#96;$再去和真实值比较</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152130199.png" alt="image-20211115213046150" style="zoom:50%;" />

<p>输出值可能是任何值，但是类别只能用0和1表示，所以要经过转换，变成0,1之间的数字，这样才便于区分类别。举例：如下图所示：</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152132555.png" alt="image-20211115213227488" style="zoom:50%;" />

<p>如果是二分类问题，直接用sigmoid做转换就可以啦，和Soft-max的功能一样</p>
<p>分类时，损失函数也有很多种，比如<strong>Mean Square Error (MSE)<strong>和</strong>交叉熵Cross-entropy</strong>(最小交叉熵等于极大似然)</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152137501.png" alt="image-20211115213702442" style="zoom:50%;" />

<p>最常用的就是交叉熵，常用到pyTorch的包已经将softmax和交叉熵绑定在一起，不需要你自己定义。使用的时候如果你再定义，就是使用了两遍。</p>
<p>为什么交叉熵更常用呢？</p>
<ul>
<li><p>因为使用平方差很可能让训练陷入困境，在损失函数图像中，它有导数的地方占比比较小，会有无法求出梯度的情况，像下面这个例子一样。</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152207269.png" alt="image-20211115220719160" style="zoom:50%;" />
</li>
<li><p>如图，$y_3$的值可以忽略不计，损失函数的右下方为最优解位置，MSE会因为没有导数而困在左上方</p>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习，深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>60分钟入门PyTorch——训练一个图片分类器</title>
    <url>/2022/07/19/classifier/</url>
    <content><![CDATA[<h1 id="训练一个分类器"><a href="#训练一个分类器" class="headerlink" title="训练一个分类器"></a>训练一个分类器</h1><p><a href="https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html#sphx-glr-beginner-blitz-cifar10-tutorial-py">原文链接</a></p>
<h2 id="1-数据"><a href="#1-数据" class="headerlink" title="1. 数据"></a>1. 数据</h2><p>通常来说，当你处理图像、文本、音频和视频数据时，可以使用标准的Python包将数据加载为numpy array形式，然后将数组转换成<code>torch.*Tensor</code></p>
<ul>
<li>图像数据：Pillow、Opencv</li>
<li>音频数据：scipy、librosa</li>
<li>文本数据：原始Python或Cpython来加载，或者使用NLTK、SpaCy</li>
</ul>
<p>视觉数据有一些特殊，有一个包<code>torchvision</code>，可以加载常见数据集，比如ImageNet、CIFAR10、MINIST等，也包括图像转换器，即<code>torchvision.datasets</code>和<code>torch.utils.data.DataLoader</code></p>
<p>这给我们提供了极大的便利，同时避免样板代码（boilerplate code）</p>
<p>在本教程中，使用CIFAR10数据集。它包含类： ‘airplane’, ‘automobile’, ‘bird’, ‘cat’, ‘deer’, ‘dog’, ‘frog’, ‘horse’, ‘ship’, ‘truck’。CIFAR10的图像大小为3×32×32，即3个颜色通道，像素大小32×32.</p>
<p><img src="https://pytorch.org/tutorials/_images/cifar10.png" alt="cifar10"></p>
<hr>
<h2 id="2-训练一个图片分类器"><a href="#2-训练一个图片分类器" class="headerlink" title="2. 训练一个图片分类器"></a>2. 训练一个图片分类器</h2><p>按序执行如下步骤</p>
<ul>
<li>使用<code>torchvision</code>加载并标准化CIFAR10的训练集和测试集</li>
<li>定义一个卷积神经网络</li>
<li>定义一个损失函数</li>
<li>在训练数据上训练网络</li>
<li>在测试数据上测试网络</li>
</ul>
<h3 id="（1）加载和标准化CIFAR10"><a href="#（1）加载和标准化CIFAR10" class="headerlink" title="（1）加载和标准化CIFAR10"></a>（1）加载和标准化CIFAR10</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br></pre></td></tr></table></figure>

<p><code>torchvision</code>数据集的输出是[0,1]的PILImage图像，将它们转换成Tensor类型，并标准化在[-1,1]范围内</p>
<blockquote>
<p>如果在Windows上运行出现了BrokenPipeError，尝试将<code>torch.utils.data.DataLoader()</code>的num_worker设置为0</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transform = transforms.Compose(</span><br><span class="line">    [transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize((<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>),(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>))]</span><br><span class="line">)</span><br><span class="line">batch_size = <span class="number">4</span></span><br><span class="line">trainset = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./data&#x27;</span>,train=<span class="literal">True</span>,download=<span class="literal">True</span>,transform=transform)</span><br><span class="line">trainloader = torch.utils.data.DataLoader(trainset,batch_size=batch_size,shuffle=<span class="literal">True</span>,num_workers=<span class="number">2</span>)</span><br><span class="line">testset = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./data&#x27;</span>,train=<span class="literal">False</span>,download=<span class="literal">True</span>,transform=transform)</span><br><span class="line">testloader = torch.utils.data.DataLoader(testset,batch_size=batch_size,shuffle=<span class="literal">False</span>,num_workers=<span class="number">2</span>)</span><br><span class="line">classes = (<span class="string">&#x27;plane&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;deer&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;frog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;ship&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Downloading https://www.cs.toronto.edu/~kriz/cifar-<span class="number">10</span>-python.tar.gz to ./data/cifar-<span class="number">10</span>-python.tar.gz</span><br><span class="line">Extracting ./data/cifar-<span class="number">10</span>-python.tar.gz to ./data</span><br><span class="line">Files already downloaded <span class="keyword">and</span> verified</span><br></pre></td></tr></table></figure>

<p>展示一些有趣的训练图像</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">imshow</span>(<span class="params">img</span>):</span><br><span class="line">    img = img/<span class="number">2</span> + <span class="number">0.5</span>  <span class="comment"># 未标准化</span></span><br><span class="line">    npimg = img.numpy()</span><br><span class="line">    <span class="comment"># 将数组的值以图片的形式展示出来</span></span><br><span class="line">    plt.imshow(np.transpose(npimg,(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>)))</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到一些随机的训练图片</span></span><br><span class="line">dataiter = <span class="built_in">iter</span>(trainloader)</span><br><span class="line">images,labels = dataiter.<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示图片</span></span><br><span class="line">imshow(torchvision.utils.make_grid(images))</span><br><span class="line"><span class="comment"># 输出标签</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="string">f&#x27;<span class="subst">&#123;classes[labels[j]]:5s&#125;</span>&#x27;</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(batch_size)))</span><br></pre></td></tr></table></figure>

<p><img src="https://pytorch.org/tutorials/_images/sphx_glr_cifar10_tutorial_001.png" alt="../../_images/sphx_glr_cifar10_tutorial_001.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">car   bird  cat   cat</span><br></pre></td></tr></table></figure>

<h3 id="（2）定义一个卷积神经网络"><a href="#（2）定义一个卷积神经网络" class="headerlink" title="（2）定义一个卷积神经网络"></a>（2）定义一个卷积神经网络</h3><p>复制神经网络教程的神经网络代码，并将它修改成适用于3个channel图片的形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">        self.pool = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.pool(F.relu(self.conv1(x)))</span><br><span class="line">        x = self.pool(F.relu(self.conv2(x)))</span><br><span class="line">        x = torch.flatten(x, <span class="number">1</span>) <span class="comment"># flatten all dimensions except batch</span></span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net = Net()</span><br></pre></td></tr></table></figure>

<h3 id="（3）定义损失函数和优化器"><a href="#（3）定义损失函数和优化器" class="headerlink" title="（3）定义损失函数和优化器"></a>（3）定义损失函数和优化器</h3><p>使用交叉熵损失分类，含有momentum的SGD优化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(net.parameters(),lr=<span class="number">0.001</span>,momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure>

<h3 id="（4）训练网络"><a href="#（4）训练网络" class="headerlink" title="（4）训练网络"></a>（4）训练网络</h3><p>这时候开始变得有趣，我们只需简单地在迭代数据上循环，并将输入数据输送到网络并优化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):  <span class="comment"># 循环数据集多次</span></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i , data <span class="keyword">in</span> <span class="built_in">enumerate</span>(trainloader,<span class="number">0</span>):</span><br><span class="line">        <span class="comment"># 得到输入数据，数据是[inputs,labels]形式的列表</span></span><br><span class="line">        inputs,labels =data</span><br><span class="line">        <span class="comment"># 参数梯度置为0</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 前向传播 + 后向传播 + 优化</span></span><br><span class="line">        outputs = net(inputs)</span><br><span class="line">        loss = criterion(outputs,labels)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#输出统计数据</span></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2000</span> == <span class="number">1999</span>: <span class="comment"># 每2000个mini-batchs输出一次</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span>,<span class="subst">&#123;i+<span class="number">1</span>:5d&#125;</span>] loss:<span class="subst">&#123;running_loss/<span class="number">2000</span>:<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;完成训练&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,  <span class="number">2000</span>] loss: <span class="number">2.144</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">4000</span>] loss: <span class="number">1.828</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">6000</span>] loss: <span class="number">1.659</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">8000</span>] loss: <span class="number">1.579</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">10000</span>] loss: <span class="number">1.530</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">12000</span>] loss: <span class="number">1.491</span></span><br><span class="line">[<span class="number">2</span>,  <span class="number">2000</span>] loss: <span class="number">1.405</span></span><br><span class="line">[<span class="number">2</span>,  <span class="number">4000</span>] loss: <span class="number">1.379</span></span><br><span class="line">[<span class="number">2</span>,  <span class="number">6000</span>] loss: <span class="number">1.359</span></span><br><span class="line">[<span class="number">2</span>,  <span class="number">8000</span>] loss: <span class="number">1.329</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">10000</span>] loss: <span class="number">1.309</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">12000</span>] loss: <span class="number">1.299</span></span><br><span class="line">Finished Training</span><br></pre></td></tr></table></figure>

<p>快速保存好我们训练的模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PATH = <span class="string">&#x27;./cifar_net.pth&#x27;</span></span><br><span class="line">torch.save(net.state_dict(),PATH)</span><br></pre></td></tr></table></figure>

<h3 id="（5）在测试集上测试网络"><a href="#（5）在测试集上测试网络" class="headerlink" title="（5）在测试集上测试网络"></a>（5）在测试集上测试网络</h3><p>我们已经在训练集上训练了2次网络，但是我们需要检查网络有没有学到东西</p>
<p>网络的输出作为预测的类标签，检查它和真实值之间的差距，如果预测正确，我们将样本添加到正确预测的列表中</p>
<p>第一步，展示测试集的图片熟悉下内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataiter = <span class="built_in">iter</span>(testloader)</span><br><span class="line">images,labels = dataiter.<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出图片</span></span><br><span class="line">imshow(torchvision.utils.make_grid(images))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;GroundTruth: &#x27;</span>, <span class="string">&#x27; &#x27;</span>.join(<span class="string">f&#x27;<span class="subst">&#123;classes[labels[j]]:5s&#125;</span>&#x27;</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">GroundTruth:  cat   ship  ship  plane</span><br></pre></td></tr></table></figure>

<p><img src="https://pytorch.org/tutorials/_images/sphx_glr_cifar10_tutorial_002.png" alt="../../_images/sphx_glr_cifar10_tutorial_002.png"></p>
<p>接下来，加载回存储过的模型（注意：存储并且再加载模型不是必要的步骤，这里这是说明如何做）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = Net()</span><br><span class="line">net.load_state_dict(torch.load(PATH))</span><br></pre></td></tr></table></figure>

<p>现在，让我们来看看神经网络认为以上图片是什么</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">outputs = net(images)</span><br></pre></td></tr></table></figure>

<p>输出10个标签的概率，一个类别的概率越大，神经网络越认为它是这个类别，所以我们得到最高概率的标签</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_, predicted = torch.<span class="built_in">max</span>(outputs, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Predicted: &#x27;</span>, <span class="string">&#x27; &#x27;</span>.join(<span class="string">f&#x27;<span class="subst">&#123;classes[predicted[j]]:5s&#125;</span>&#x27;</span></span><br><span class="line">                              <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Predicted:  cat   car   car   plane</span><br></pre></td></tr></table></figure>

<p>结果看起来不错</p>
<p>让我们看看在整个数据集上网络的表现效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 网络在整个数据集上的表现效果</span></span><br><span class="line">correct = <span class="number">0</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="comment"># 不训练，就不需要计算输出的梯度</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    images,labels = data</span><br><span class="line">    <span class="comment"># 将图片传进网络计算输出</span></span><br><span class="line">    outputs = net(images)</span><br><span class="line">    <span class="comment"># 在哪个类别上概率最高，就是预测的类别结果</span></span><br><span class="line">    _,predicted = torch.<span class="built_in">max</span>(outputs.data,<span class="number">1</span>)</span><br><span class="line">    total += labels.size(<span class="number">0</span>)</span><br><span class="line">    correct = (predicted==labels).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;神经网络在10000条测试图像上的准确率为：<span class="subst">&#123;<span class="number">100</span> * correct // total&#125;</span>%&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Accuracy of the network on the <span class="number">10000</span> test images: <span class="number">54</span> %</span><br></pre></td></tr></table></figure>

<p>结果看起来比随机猜测效果要好，因为随机猜测的准确率是10%，网络似乎学到了一些东西</p>
<p>在哪些类上的预测效果比较好，哪些不好呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># prepare to count predictions for each class</span></span><br><span class="line">correct_pred = &#123;classname: <span class="number">0</span> <span class="keyword">for</span> classname <span class="keyword">in</span> classes&#125;</span><br><span class="line">total_pred = &#123;classname: <span class="number">0</span> <span class="keyword">for</span> classname <span class="keyword">in</span> classes&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># again no gradients needed</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> testloader:</span><br><span class="line">        images, labels = data</span><br><span class="line">        outputs = net(images)</span><br><span class="line">        _, predictions = torch.<span class="built_in">max</span>(outputs, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># collect the correct predictions for each class</span></span><br><span class="line">        <span class="keyword">for</span> label, prediction <span class="keyword">in</span> <span class="built_in">zip</span>(labels, predictions):</span><br><span class="line">            <span class="keyword">if</span> label == prediction:</span><br><span class="line">                correct_pred[classes[label]] += <span class="number">1</span></span><br><span class="line">            total_pred[classes[label]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print accuracy for each class</span></span><br><span class="line"><span class="keyword">for</span> classname, correct_count <span class="keyword">in</span> correct_pred.items():</span><br><span class="line">    accuracy = <span class="number">100</span> * <span class="built_in">float</span>(correct_count) / total_pred[classname]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Accuracy for class: <span class="subst">&#123;classname:5s&#125;</span> is <span class="subst">&#123;accuracy:<span class="number">.1</span>f&#125;</span> %&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: plane <span class="keyword">is</span> <span class="number">54.2</span> %</span><br><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: car   <span class="keyword">is</span> <span class="number">85.1</span> %</span><br><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: bird  <span class="keyword">is</span> <span class="number">41.1</span> %</span><br><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: cat   <span class="keyword">is</span> <span class="number">33.9</span> %</span><br><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: deer  <span class="keyword">is</span> <span class="number">38.7</span> %</span><br><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: dog   <span class="keyword">is</span> <span class="number">55.8</span> %</span><br><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: frog  <span class="keyword">is</span> <span class="number">66.7</span> %</span><br><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: horse <span class="keyword">is</span> <span class="number">70.5</span> %</span><br><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: ship  <span class="keyword">is</span> <span class="number">55.3</span> %</span><br><span class="line">Accuracy <span class="keyword">for</span> <span class="keyword">class</span>: truck <span class="keyword">is</span> <span class="number">44.6</span> %</span><br></pre></td></tr></table></figure>

<p>如何在GPU上训练神经网络呢？</p>
<h2 id="3-在GPU上训练"><a href="#3-在GPU上训练" class="headerlink" title="3. 在GPU上训练"></a>3. 在GPU上训练</h2><p>就像是如何把一个tensor转换到GPU上，也同样把神经网络转换到GPU上</p>
<p>如果我们有可用的CUDA，首先将我们的设备定义为一个可用的CUDA设备</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = torch.device(<span class="string">&#x27;cuda:0&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"><span class="comment"># 假设我们在CUDA机器上，应该打印一个CUDA设备</span></span><br><span class="line"><span class="built_in">print</span>(device)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cuda:<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>下面的<code>device</code>就是一个CUDA设备</p>
<p>然后，这些方法将递归遍历所有模块，并且将它们的参数和缓冲区转换成CUDA tensor</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net.to(device)</span><br><span class="line"><span class="comment"># 必须在每个步骤中将输入和目标发送到GPU</span></span><br><span class="line">inputs,labels = data[<span class="number">0</span>].to(device),data[<span class="number">1</span>].to(device)</span><br></pre></td></tr></table></figure>

<p>为什么没注意到和CPU相比要较大的速度提升呢？因为模型太小了。</p>
<p><strong>实践练习</strong>：</p>
<p>尝试提升网络的宽度（第一个<code>nn.Conv2d</code>的第二个参数，第二个<code>nn.Conv2d</code>的第一个参数，它们应该是相同的数字），看看你得到了什么样的加速</p>
<p><strong>已实现目标</strong>：</p>
<ul>
<li>深入了解PyTorch的Tensor库和神经网络</li>
<li>训练一个小的网络去分类图片</li>
</ul>
<hr>
<h2 id="4-在多个GPU上训练"><a href="#4-在多个GPU上训练" class="headerlink" title="4. 在多个GPU上训练"></a>4. 在多个GPU上训练</h2><p>如果你希望使用所有的GPU来获得更大的加快速度，请看选读：<a href="https://pytorch.org/tutorials/beginner/blitz/data_parallel_tutorial.html">数据并行</a></p>
]]></content>
      <categories>
        <category>深度学习： PyTorch</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>60分钟入门PyTorch——神经网络（用PyTorch构建一个神经网络）</title>
    <url>/2022/07/18/Neural%20Nwtworks/</url>
    <content><![CDATA[<h1 id="Neural-Networks"><a href="#Neural-Networks" class="headerlink" title="Neural Networks"></a>Neural Networks</h1><h2 id="1-神经网络"><a href="#1-神经网络" class="headerlink" title="1. 神经网络"></a>1. 神经网络</h2><p><code>torch.nn</code>包可以用来构建神经网络，<code>nn</code>包依赖于<code>autograd</code>包去定义模型并对其进行求导</p>
<p>一个<code>nn.Module</code>包含很多层，和一个以<code>input</code>作为输入的前向方法<code>forward</code>，并返回输出<code>output</code></p>
<p>下面是一个分类数字图像的网络</p>
<p><img src="https://pytorch.org/tutorials/_images/mnist.png" alt="convnet"></p>
<h3 id="卷积网络"><a href="#卷积网络" class="headerlink" title="卷积网络"></a>卷积网络</h3><p>这是一个简单的前馈神经网络，网络接受输入数据，一层接着一层的传输输入数据，最后给出输出结果。</p>
<p>一个神经网络的典型训练过程如下：</p>
<ul>
<li>定义包括可学习参数（或权重）的网络，</li>
<li>用数据集做迭代</li>
<li>计算损失（输出值和真实值之间的差异）</li>
<li>将梯度反向传播进网络的参数</li>
<li>更新网络的参数，经典的一个简单的更新规则：$weight &#x3D; weight - learning_rate *gradient$</li>
</ul>
<hr>
<h2 id="2-定义网络"><a href="#2-定义网络" class="headerlink" title="2. 定义网络"></a>2. 定义网络</h2><p>定义网络</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net,self).__init__()</span><br><span class="line">        <span class="comment"># 输入通道：1，输出通道：6，卷积核：3*3</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>,<span class="number">6</span>,<span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>,<span class="number">16</span>,<span class="number">5</span>)</span><br><span class="line">        <span class="comment"># y = Wx + b</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span>*<span class="number">5</span>*<span class="number">5</span>,<span class="number">120</span>) </span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>,<span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        <span class="comment"># 最大池化层(2,2)</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv1(x)),<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 如果是方形，可以使用单个数字定义</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv2(x)),<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 除batch维度外，展开所有维度</span></span><br><span class="line">        x = torch.flatten(x,<span class="number">1</span>)</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line"><span class="built_in">print</span>(net)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Net(</span><br><span class="line">  (conv1): Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">  (conv2): Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">  (fc1): Linear(in_features=<span class="number">400</span>, out_features=<span class="number">120</span>, bias=<span class="literal">True</span>)</span><br><span class="line">  (fc2): Linear(in_features=<span class="number">120</span>, out_features=<span class="number">84</span>, bias=<span class="literal">True</span>)</span><br><span class="line">  (fc3): Linear(in_features=<span class="number">84</span>, out_features=<span class="number">10</span>, bias=<span class="literal">True</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>必须要定义<code>forward</code>函数，计算梯度的<code>backward</code>函数会使用<code>autograd</code>自动定义，在<code>forward</code>函数中可以使用任何针对Tensor的操作</p>
<p><code>net.parameters()</code>返回一个模型需要学习的参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params = <span class="built_in">list</span>(net.parameters())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(params))</span><br><span class="line"><span class="built_in">print</span>(params[<span class="number">0</span>].size()) <span class="comment"># conv1的权重</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">torch.Size([6, 1, 5, 5])</span><br></pre></td></tr></table></figure>

<p>随机构造32×32大小的输入数据，这个网络结构（LeNet）期待的输入数据是32×32。如果要在MINIST数据集上使用这个网络，需要把数据集中的图像调整到32×32</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">input</span> = torch.randn(<span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line">out = net(<span class="built_in">input</span>)</span><br><span class="line"><span class="built_in">print</span>(out)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor([[ 0.0242, -0.0113, -0.1382, -0.1108,  0.1062,  0.0663,  0.0473,  0.0761, 0.1049, -0.0412]], grad_fn=&lt;AddmmBackward0&gt;)</span><br></pre></td></tr></table></figure>

<p>将所有参数的梯度缓存清零，然后进行随机梯度的反向传播</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net.zero_grad()</span><br><span class="line">out.backward(torch.randn(<span class="number">1</span>,<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>torch.nn</code>只支持小批量输入，整个<code>torch.nn</code>包都只支持小样本的输入，而不是单个样本</p>
<p>例如：<code>nn.Conv2d</code>将接受一个四维的张量：nSamples×nChannels×Height×Width</p>
<p>如果有单个样本，使用<code>input.unsqueeze(0)</code>来添加一个假batch维度</p>
</blockquote>
<p>回归一下到目前为止见过的所有类</p>
<ul>
<li><code>torch.Tensor</code>：支持autograd操作（比如<code>backward()</code>）的多维数组，同时保存梯度（tensor形式）</li>
<li><code>nn.Module</code>：神经网络模块，方便封装参数，帮助移到到GPU上运行、导出和加载等</li>
<li><code>nn.Parameter</code>：一种张量，当把它赋值给Module的属性时，会自动注册为参数</li>
<li><code>autograd.Function</code>：实现autograd操作的前向和后向定义，每个<code>Tensor</code>操作会创造至少一个<code>Function</code>节点，这个节点连接到创建<code>tensor</code>并对其历史进行编码的函数</li>
</ul>
<p>现在，我们已覆盖如下内容</p>
<ul>
<li>定义一个神经网络</li>
<li>处理输入，调用反向传播函数</li>
</ul>
<p>还剩下：</p>
<ul>
<li>计算损失</li>
<li>更新网络的权重参数</li>
</ul>
<hr>
<h2 id="3-损失函数"><a href="#3-损失函数" class="headerlink" title="3. 损失函数"></a>3. 损失函数</h2><p>损失函数接受（output，target）作为输入（output为网络的输出,target为实际值），计算值来评估output和target的误差</p>
<p>在<code>nn</code>包下有几种不同的损失函数，一个简单的损失是：<code>nn.MSELoss</code>，计算output和target之间的均方误差</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output = net(<span class="built_in">input</span>)</span><br><span class="line">target = torch.randn(<span class="number">10</span>)</span><br><span class="line">target = target.view(<span class="number">1</span>,-<span class="number">1</span>) <span class="comment"># 保持和output输出形状相同</span></span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line"></span><br><span class="line">loss = criterion(output,target)</span><br><span class="line"><span class="built_in">print</span>(loss)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor(<span class="number">0.3965</span>, grad_fn=&lt;MseLossBackward0&gt;)</span><br></pre></td></tr></table></figure>

<p>现在，如果你反向跟踪loss，使用<code>.grad_fn</code>属性，将会看到下面这样的计算图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">input</span> -&gt; conv2d -&gt; relu -&gt; maxpool2d -&gt; conv2d -&gt; relu -&gt; maxpool2d</span><br><span class="line">      -&gt; flatten -&gt; linear -&gt; relu -&gt; linear -&gt; relu -&gt; linear</span><br><span class="line">      -&gt; MSELoss</span><br><span class="line">      -&gt; loss</span><br></pre></td></tr></table></figure>

<p>所以，当调用<code>loss.backward()</code>的时候，整个图被分为神经网络参数和图中设置<code>requires_grad=True</code>的所有tensor，帮助<code>.grad</code>张量的梯度积累</p>
<p>为了说明情况，我们向回追踪几步：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(loss.grad_fn)  <span class="comment"># MSELoss</span></span><br><span class="line"><span class="built_in">print</span>(loss.grad_fn.next_functions[<span class="number">0</span>][<span class="number">0</span>]) <span class="comment"># Linear</span></span><br><span class="line"><span class="built_in">print</span>(loss.grad_fn.next_functions[<span class="number">0</span>][<span class="number">0</span>].next_functions[<span class="number">0</span>][<span class="number">0</span>]) <span class="comment"># ReLU</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;MseLossBackward0 <span class="built_in">object</span> at <span class="number">0x0000019DABCB18B0</span>&gt;</span><br><span class="line">&lt;AddmmBackward0 <span class="built_in">object</span> at <span class="number">0x0000019DABCB1250</span>&gt;</span><br><span class="line">&lt;AccumulateGrad <span class="built_in">object</span> at <span class="number">0x0000019DABCB18B0</span>&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-反向传播"><a href="#4-反向传播" class="headerlink" title="4. 反向传播"></a>4. 反向传播</h2><p>为了反向传播误差，要调用<code>loss.backward()</code>，你需要清除已经存在的梯度，不然梯度就会被累加到已经存在的梯度</p>
<p>现在调用<code>loss.backward()</code>，看看conv1在反向传播前后的偏置梯度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net.zero_grad()     <span class="comment"># zeroes the gradient buffers of all parameters</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;conv1.bias.grad before backward&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(net.conv1.bias.grad)</span><br><span class="line"></span><br><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;conv1.bias.grad after backward&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(net.conv1.bias.grad)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv1.bias.grad before backward</span><br><span class="line">tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])</span><br><span class="line">conv1.bias.grad after backward</span><br><span class="line">tensor([-<span class="number">0.0079</span>,  <span class="number">0.0134</span>,  <span class="number">0.0143</span>,  <span class="number">0.0054</span>,  <span class="number">0.0081</span>, -<span class="number">0.0033</span>])</span><br></pre></td></tr></table></figure>

<p>现在，我们已经知道如何使用损失函数</p>
<p>接下来最后一件要学习的是：更新网络权重</p>
<h2 id="5-更新权重"><a href="#5-更新权重" class="headerlink" title="5. 更新权重"></a>5. 更新权重</h2><p>在实践中最简单的更新规则是<strong>随机梯度下降</strong>(SGD)</p>
<p>$$weight&#x3D;weight−learning_rate∗gradient$$</p>
<p>使用Python代码简单实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> net.parameters():</span><br><span class="line">    f.data.sub_(f.grad.data * learning_rate)</span><br></pre></td></tr></table></figure>

<p><code>torch.optim</code>包里面有各种更新方法的实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建优化器</span></span><br><span class="line">optimizer = optim.SGD(net.parameters(),lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练循环中</span></span><br><span class="line">optimizer.zero_grad()</span><br><span class="line">output = net(<span class="built_in">input</span>)</span><br><span class="line">loss = criterion(output,target)</span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step()  <span class="comment"># 更新参数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>梯度是可以累积的，所以要使用<code>optimizer.zero_grad()</code>手动将梯度缓冲区设置为零</p>
</blockquote>
]]></content>
      <categories>
        <category>深度学习： PyTorch</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>60分钟入门PyTorch——Tensor</title>
    <url>/2022/07/17/tensor/</url>
    <content><![CDATA[<h1 id="Tensor"><a href="#Tensor" class="headerlink" title="Tensor"></a>Tensor</h1><p>tensor被翻译为<strong>张量</strong>，是一种与NumPy数据和矩阵十分相似的特殊数据结构</p>
<p>在PyTorch中，我们使用tensor给模型的输入输出以及参数进行编码</p>
<p>除了可以在GPUs和其他可以加速运算的硬件上运行这一特点之外，tensors和NumPy数组非常相似</p>
<h2 id="1-初始化tensor"><a href="#1-初始化tensor" class="headerlink" title="1. 初始化tensor"></a>1. 初始化tensor</h2><h3 id="使用数据直接初始化"><a href="#使用数据直接初始化" class="headerlink" title="使用数据直接初始化"></a>使用数据直接初始化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">data = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">x_data = torch.tensor(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">tensor([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="使用NumPy-arrays初始化"><a href="#使用NumPy-arrays初始化" class="headerlink" title="使用NumPy arrays初始化"></a>使用NumPy arrays初始化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np_array = np.array(data)</span><br><span class="line">x_np = torch.from_numpy(np_array)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">tensor([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>]], dtype=torch.int32)</span><br></pre></td></tr></table></figure>

<h3 id="使用另一个tensor创建"><a href="#使用另一个tensor创建" class="headerlink" title="使用另一个tensor创建"></a>使用另一个tensor创建</h3><p>新的tensor保留了参数tensor的一些属性（形状，数据类型），除非显式覆盖</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_ones = torch.ones_like(x_data) <span class="comment"># 保留了x_data的属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Ones Tensor: \n <span class="subst">&#123;x_ones&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="comment"># 显示覆盖x_data的数据类型</span></span><br><span class="line">x_rand = torch.rand_like(x_data,dtype=torch.<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Random Tensor: \n <span class="subst">&#123;x_rand&#125;</span> \n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Ones Tensor: </span><br><span class="line"> tensor([[<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>]]) </span><br><span class="line"></span><br><span class="line">Random Tensor: </span><br><span class="line"> tensor([[<span class="number">0.5502</span>, <span class="number">0.3189</span>],</span><br><span class="line">        [<span class="number">0.0911</span>, <span class="number">0.7488</span>]]) </span><br></pre></td></tr></table></figure>

<h3 id="使用随机数或者常数创建tensor"><a href="#使用随机数或者常数创建tensor" class="headerlink" title="使用随机数或者常数创建tensor"></a>使用随机数或者常数创建tensor</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shape是关于tensor维度的元组，它决定输出tensor的维度</span></span><br><span class="line">shape = (<span class="number">2</span>,<span class="number">3</span>,)</span><br><span class="line"></span><br><span class="line">rand_tensor = torch.rand(shape)</span><br><span class="line">ones_tensor = torch.ones(shape)</span><br><span class="line">zeros_tensor = torch.zeros(shape)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Random Tensor: \n <span class="subst">&#123;rand_tensor&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Ones Tensor: \n <span class="subst">&#123;ones_tensor&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Zeros Tensor: \n <span class="subst">&#123;zeros_tensor&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Random Tensor:</span><br><span class="line"> tensor([[<span class="number">0.8012</span>, <span class="number">0.4547</span>, <span class="number">0.4156</span>],</span><br><span class="line">        [<span class="number">0.6645</span>, <span class="number">0.1763</span>, <span class="number">0.3860</span>]])</span><br><span class="line"></span><br><span class="line">Ones Tensor:</span><br><span class="line"> tensor([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line">Zeros Tensor:</span><br><span class="line"> tensor([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>

<h2 id="2-tensor属性"><a href="#2-tensor属性" class="headerlink" title="2. tensor属性"></a>2. tensor属性</h2><p>Tensor的属性包括形状，数据类型以及存储的设备</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor = torch.rand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Shape of tensor: <span class="subst">&#123;tensor.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Datatype of tensor: <span class="subst">&#123;tensor.dtype&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Device tensor is stored on: <span class="subst">&#123;tensor.device&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Shape of tensor: torch.Size([<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">Datatype of tensor: torch.float32</span><br><span class="line">Device tensor <span class="keyword">is</span> stored on: cpu</span><br></pre></td></tr></table></figure>

<h2 id="3-tensor操作"><a href="#3-tensor操作" class="headerlink" title="3. tensor操作"></a>3. tensor操作</h2><p>tensor有超过100种操作，包括转置（transposing）, 索引（indexing）,切片（ slicing）, 数学运算（mathematical operations）, 线性代数（linear algebra）,随机操作（ random sampling）等等。</p>
<p>它们都可以在GPU上运行（速度通常比CPU快），如果你使用的是Colab，通过编辑&gt;笔记本设置来分配一个GPU</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将tensor移到GPU上</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    tensor = tensor.to(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Device tensor is stored on: <span class="subst">&#123;tensor.device&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出 ：Device tensor is stored on: cuda:0</span></span><br></pre></td></tr></table></figure>

<p>尝试一些操作</p>
<h3 id="像NumPy一样标准的索引和切片"><a href="#像NumPy一样标准的索引和切片" class="headerlink" title="像NumPy一样标准的索引和切片"></a>像NumPy一样标准的索引和切片</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor = torch.ones(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">tensor[:,<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(tensor)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="连接tensor-Joining-tensors"><a href="#连接tensor-Joining-tensors" class="headerlink" title="连接tensor(Joining tensors)"></a>连接tensor(<strong>Joining tensors</strong>)</h3><p>使用torch.cat可以沿着给定的维度合并一系列tensor</p>
<p>torch.stack是另一个连接tensor的操作，和torch.cat有些许不同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = torch.cat([tensor, tensor, tensor], dim=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(t1)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="tensor相乘"><a href="#tensor相乘" class="headerlink" title="tensor相乘"></a>tensor相乘</h3><p>元素层面的乘法操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tensor在元素层面的乘法操作</span></span><br><span class="line">tensor.mul(tensor)</span><br><span class="line"><span class="comment"># 和上面等价的写法</span></span><br><span class="line">tensor * tensor</span><br><span class="line"><span class="comment"># 输出 </span></span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>

<p>两个tensor之间的矩阵乘法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor.matmul(tensor.T)</span><br><span class="line"><span class="comment"># 等价写法</span></span><br><span class="line">tensor @ tensor.T</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">tensor([[<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="In-place操作"><a href="#In-place操作" class="headerlink" title="In-place操作"></a>In-place操作</h3><p>带有后缀<code>_</code>的操作是in_place操作，例如：<code>x.copy_(y)</code>，<code>x.t_()</code>将改变x</p>
<blockquote>
<p>in_place操作虽然会节省很多内存空间，但是会因为即刻清除历史记录在计算导数的时候可能出现问题，所以不鼓励使用这种操作方式</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(tensor, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">tensor.add_(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(tensor)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>]]) </span><br><span class="line"></span><br><span class="line">tensor([[<span class="number">6.</span>, <span class="number">5.</span>, <span class="number">6.</span>, <span class="number">6.</span>],</span><br><span class="line">        [<span class="number">6.</span>, <span class="number">5.</span>, <span class="number">6.</span>, <span class="number">6.</span>],</span><br><span class="line">        [<span class="number">6.</span>, <span class="number">5.</span>, <span class="number">6.</span>, <span class="number">6.</span>],</span><br><span class="line">        [<span class="number">6.</span>, <span class="number">5.</span>, <span class="number">6.</span>, <span class="number">6.</span>]])</span><br></pre></td></tr></table></figure>

<h2 id="4-使用Numpy作为桥梁"><a href="#4-使用Numpy作为桥梁" class="headerlink" title="4. 使用Numpy作为桥梁"></a>4. 使用Numpy作为桥梁</h2><p>在cpu上的tensor和NumPy数组可以共享基本的内存位置，<strong>改变一个就会改变另一个</strong></p>
<h3 id="tnsor转变成Numpy数组"><a href="#tnsor转变成Numpy数组" class="headerlink" title="tnsor转变成Numpy数组"></a>tnsor转变成Numpy数组</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = torch.ones(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line">n = t.numpy()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">t: tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line">n: [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br></pre></td></tr></table></figure>

<p>tensor中的改变会影响到NumPy数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t.add_(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t: tensor([<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>])</span><br><span class="line">n: [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br></pre></td></tr></table></figure>

<h3 id="NumPy数组转变成tensor"><a href="#NumPy数组转变成tensor" class="headerlink" title="NumPy数组转变成tensor"></a>NumPy数组转变成tensor</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = np.ones(<span class="number">5</span>)</span><br><span class="line">t = torch.from_numpy(n)</span><br><span class="line"><span class="comment"># 在NumPy数组中的改变会影响到tensor</span></span><br><span class="line">np.add(n, <span class="number">1</span>, out=n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t: tensor([<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>], dtype=torch.float64)</span><br><span class="line">n: [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>深度学习： PyTorch</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>一、准备工作——《利用Python进行数据分析》</title>
    <url>/2022/03/26/%E4%B8%80%E3%80%81%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/</url>
    <content><![CDATA[<h1 id="第一章-准备工作"><a href="#第一章-准备工作" class="headerlink" title="第一章 准备工作"></a>第一章 准备工作</h1><h2 id="1-1-本书内容"><a href="#1-1-本书内容" class="headerlink" title="1.1 本书内容"></a>1.1 本书内容</h2><p><strong>常见数据形式</strong></p>
<ul>
<li>表格型的数据，每一列可能会包含不同的类型（字符串、数值、日期或其他）。</li>
<li>多维数组（矩阵）。</li>
<li>由键位列关联的多张表数据（对于SQL用户来说就是主键或外键）。</li>
<li>均匀或非均匀的时间序列。</li>
</ul>
<h2 id="1-2-为何利用Python进行数据分析"><a href="#1-2-为何利用Python进行数据分析" class="headerlink" title="1.2 为何利用Python进行数据分析"></a>1.2 为何利用Python进行数据分析</h2><ul>
<li>Python作为胶水，整合C、C++等语言的代码</li>
<li>解决“双语言”难题：使用相同程序工具集来兼顾研究人员和软件工程师的好处越发明显。</li>
<li>当搭建高并发、多线程应用，尤其是多CPU绑定线程时，使用Python则会成为一项挑战。原因在于Python拥有全局解释器锁（GIL），这是一种防止解释器同时执行多个Python指令的机制。当搭建高并发、多线程应用，尤其是多CPU绑定线程时，使用Python则会成为一项挑战。原因在于Python拥有全局解释器锁（GIL），这是一种防止解释器同时执行多个Python指令的机制。</li>
</ul>
<h2 id="1-3-重要的Python库"><a href="#1-3-重要的Python库" class="headerlink" title="1.3 重要的Python库"></a>1.3 重要的Python库</h2><span id="more"></span>

<p><strong>Numpy</strong></p>
<ul>
<li>NumPy（<a href="http://numpy.org)是numerical/">http://numpy.org）是Numerical</a> Python的简写，是Python数值计算的基石。</li>
<li>NumPy赋予Python的快速数组处理能力。</li>
<li>对于数值数据，NumPy数组能够比Python内建数据结构更为高效地存储和操作数据。</li>
<li>用底层语言编写的库可以在NumPy数组存储的数据上直接操作，而无须将数据复制到其他内存中后再操作。</li>
</ul>
<p><strong>Pandas</strong></p>
<ul>
<li>pandas（<a href="http://pandas.pyda/">http://pandas.pyda</a> ta.org）提供了高级数据结构和函数</li>
<li>在本书中主要使用的pandas对象是DataFrame，它是用于实现表格化、面向列、使用行列标签的数据结构；以及Series，一种一维标签数组对象。</li>
<li>pandas尤其擅长深度时间序列和处理商业进程中产生的时间索引数据</li>
</ul>
<p><strong>matplotlib</strong></p>
<ul>
<li>matplotlib（<a href="http://matplotlib.org)是最流行的用于制图及其他二维数据可视化的python库/">http://matplotlib.org）是最流行的用于制图及其他二维数据可视化的Python库</a></li>
</ul>
<p><strong>IPython与Jupyter</strong></p>
<ul>
<li>IPython使用<strong>执行-探索</strong>工作流来替代其他语言典型的<strong>编辑-编译-运行</strong>工作流</li>
<li>本书所有章节代码：<a href="http://github.com/wesm/pydata-book">http://github.com/wesm/pydata-book</a></li>
</ul>
<p><strong>SciPy</strong></p>
<ul>
<li><p>SciPy（<a href="http://scipy.org)是科学计算领域针对不同标准问题域的包集合,scipy与numpy一起为很多传统科学计算应用提供了一个合理、完整、成熟的计算基础./">http://scipy.org）是科学计算领域针对不同标准问题域的包集合，SciPy与NumPy一起为很多传统科学计算应用提供了一个合理、完整、成熟的计算基础。</a></p>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scipy.integrate  #数值积分例程和微分方程求解器</span><br><span class="line">scipy.linalg  #线性代数例程和基于numpy.linalg的矩阵分解</span><br><span class="line">scipy.optimize  #函数优化器（最小化器）和求根算法</span><br><span class="line">scipy.signal  #信号处理工具</span><br><span class="line">scipy.sparse  #稀疏矩阵与稀疏线性系统求解器</span><br><span class="line">scipy.special  #SPECFUN的包装器。SPECFUN是Fortran语言下实现通用数据函数的包，例如gamma函数。</span><br><span class="line">scipy.stats  #标准的连续和离散概率分布（密度函数、采样器、连续分布函数）、各类统计测试、各类描述性统计。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>scikit-learn</strong></p>
<ul>
<li><a href="http://scikit-learn.org：机器学习工具包">http://scikit-learn.org：机器学习工具包</a></li>
<li>分类：SVM、最近邻、随机森林、逻辑回归等</li>
<li>回归：Lasso、岭回归等</li>
<li>聚类：k-means、谱聚类等·</li>
<li>降维：PCA、特征选择、矩阵分解等</li>
<li>模型选择：网格搜索、交叉验证、指标矩阵</li>
<li>预处理：特征提取、正态化</li>
</ul>
<p><strong>statsmodels</strong></p>
<ul>
<li>statsmodels（<a href="http://statsmodels.org)是一个统计分析包,为r语言公式系统所驱动的statsmodels包提供公式、模型规范框架./">http://statsmodels.org）是一个统计分析包，为R语言公式系统所驱动的statsmodels包提供公式、模型规范框架。</a></li>
<li>与scikit-learn相比，statsmodels包含经典的（高频词汇）统计学、经济学算法。<ul>
<li>方差分析（ANOVA）</li>
<li>时间序列分析：AR、ARMA、ARIMA、VAR等模型</li>
<li>非参数方法：核密度估计、核回归</li>
<li>统计模型结果可视化</li>
</ul>
</li>
<li>statsmodels更专注于统计推理，提供不确定性评价和p值参数。相反，scikit-learn更专注于预测。</li>
</ul>
<h2 id="1-4-安装与配置"><a href="#1-4-安装与配置" class="headerlink" title="1.4 安装与配置"></a>1.4 安装与配置</h2><p><strong>Windows</strong></p>
<ul>
<li>下载安装Anaconda：<a href="http://anaconda.com/downloads">http://anaconda.com/downloads</a></li>
<li>查看设置是否正确，在命令行中输入python启动python解释器，应该可以看到符合你下载的Anaconda版本的信息。</li>
<li>退出命令行：Ctrl-D（Linux或macOS）&#x2F; Ctrl-Z（Windows），或者输入exit()</li>
</ul>
<p><strong>Apple（OS X和macOS）</strong></p>
<ul>
<li>略</li>
</ul>
<p><strong>GNU&#x2F;Linux</strong></p>
<ul>
<li>略</li>
</ul>
<p><strong>安装及更新Python包</strong></p>
<ul>
<li><p>通常通过以下命令进行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install package_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用pip包管理工具进行安装:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install package_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用conda update命令来更新包:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda update package_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>pip还支持通过–upgrade标识升级：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install --upgrade package_name</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>同时使用conda和pip进行包安装时，请不要尝试使用pip更新conda安装的包，否则可能会导致环境问题。</p>
<p>当使用Anaconda或者Miniconda时，最好还是使用conda进行更新。</p>
</blockquote>
<h2 id="1-5-社区和会议"><a href="#1-5-社区和会议" class="headerlink" title="1.5 社区和会议"></a>1.5 社区和会议</h2><h2 id="1-6-快速浏览本书"><a href="#1-6-快速浏览本书" class="headerlink" title="1.6 快速浏览本书"></a>1.6 快速浏览本书</h2><p><strong>示例数据</strong></p>
<ul>
<li>每章的示例数据托管在GitHub仓库：<a href="http://github.com/wesm/pydata-book">http://github.com/wesm/pydata-book</a></li>
<li>关于如何获得本书资料的最新指引：<a href="http://wesmckinney.com/">http://wesmckinney.com</a></li>
</ul>
<p><strong>导入约定</strong></p>
<ul>
<li><p>一次性从像NumPy这样的大包中引入所有内容（from numpyimport *）在Python软件开发中被认为是拙劣实践。</p>
</li>
<li><pre><code>import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import statsmodels as sm
</code></pre>
</li>
</ul>
<p><strong>术语</strong></p>
<ul>
<li>处理&#x2F;处置&#x2F;规整（munge&#x2F;munging&#x2F;wrangling）<ul>
<li>将非结构化或者同时又很凌乱的数据整理成结构化、清晰形式的整个过程。</li>
</ul>
</li>
<li>伪代码<ul>
<li>将非结构化或者同时又很凌乱的数据整理成结构化、清晰形式的整个过程。</li>
</ul>
</li>
<li>语法糖<ul>
<li>并不增加新特性，但便利于代码编写的编程语法。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习： 数据分析</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>三、内建数据结构、函数及文件——《利用Python进行数据分析》</title>
    <url>/2022/03/28/%E4%B8%89%E3%80%81%E5%86%85%E5%BB%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%8A%E6%96%87%E4%BB%B6%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/</url>
    <content><![CDATA[<h1 id="第三章-内建数据结构、函数及文件"><a href="#第三章-内建数据结构、函数及文件" class="headerlink" title="第三章 内建数据结构、函数及文件"></a>第三章 内建数据结构、函数及文件</h1><h2 id="3-1-数据结构和序列"><a href="#3-1-数据结构和序列" class="headerlink" title="3.1 数据结构和序列"></a>3.1 数据结构和序列</h2><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><ul>
<li><p>固定长度，<strong>不可变</strong>的Python对象序列</p>
</li>
<li><p>创建元组</p>
<ul>
<li>最简单：用逗号分隔序列值</li>
<li>更复杂：用括号将值包起来，例如：生成元素是元组的元组</li>
<li>使用tuple函数将任意序列或迭代器转换为元组</li>
</ul>
</li>
<li><p>元组中存储的对象自身是可变的，但是元组一旦创建，各个位置上的对象是无法被修改的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[<span class="number">1</span>]:tup=<span class="built_in">tuple</span>([<span class="string">&#x27;foo&#x27;</span>,[<span class="number">1</span>,<span class="number">2</span>],<span class="literal">True</span>])</span><br><span class="line">In[<span class="number">2</span>]:tup[<span class="number">2</span>] = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 提示错误</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果元组中的一个对象是可变的，例如列表，你可以在它内部进行修改</p>
</blockquote>
</li>
<li><p>可以使用+号连接元组来生成更长的元组,将元组乘以整数，则会和列表一样，生成含有多份拷贝的元组.</p>
<blockquote>
<p>对象自身并没有复制，只是指向它们的引用进行了复制</p>
</blockquote>
</li>
</ul>
<p><strong>元组拆包</strong></p>
<ul>
<li><p>将元组型的表达式赋值给变量，Python会对等号右边的值进行拆包，<strong>即使是嵌套元组也可以拆包</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[<span class="number">1</span>]:tup=(<span class="number">4</span>,<span class="number">5</span>,(<span class="number">6</span>,<span class="number">7</span>))</span><br><span class="line">In[<span class="number">2</span>]:a,b,(c,d)=tup</span><br><span class="line">In[<span class="number">3</span>]:d</span><br><span class="line">Out[<span class="number">1</span>]:<span class="number">7</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在Python中，交换值可以采用如下方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a,b = <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">b,a = a,b</span><br><span class="line">a <span class="comment">#输出2</span></span><br><span class="line">b <span class="comment"># 输出1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>拆包常用场景：遍历元组或列表组成的序列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seq = [(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>)]</span><br><span class="line"><span class="keyword">for</span> a,b,c <span class="keyword">in</span> seq:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a=&#123;0&#125;,b=&#123;1&#125;,c=&#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(a,b,c))</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span></span><br><span class="line">a=<span class="number">4</span>,b=<span class="number">5</span>,c=<span class="number">6</span></span><br><span class="line">a=<span class="number">7</span>,b=<span class="number">8</span>,c=<span class="number">9</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用*rest在函数调用时获取任意长度的位置参数列表，有时候rest部分表示要丢弃的数据，很多编程者会使用下划线(_)来表示不想要的遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a,b,*_ = values</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>元组方法</strong></p>
<ul>
<li><p>用count计量每个数值在元组中出现的次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line">a.count(<span class="number">2</span>)  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul>
<li>长度可变，包含的内容可以修改</li>
<li>可使用[]或者list类型函数来定义列表</li>
<li>list函数在数据处理中常用于<strong>将迭代器或者生成器转化为列表</strong></li>
</ul>
<p><strong>增加和移除元素</strong></p>
<ul>
<li><p>append方法：将元素添加到列表尾部</p>
</li>
<li><p>使用insert方法将元素插入到列表的指定位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b_list.insert(<span class="number">1</span>,<span class="string">&#x27;red&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>insert比append计算代价更高，因为内部序列移动需要时间</p>
<p>想要在序列头部和尾部都插入元素，应该探索下collections.deque，它是一个双端队列，可以满足头尾部都增加的要求。</p>
</blockquote>
</li>
<li><p>pop方法：insert的反向操作，将特定位置的元素移除并返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b_list.pop(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>remove方法可以移除：定位第一个符合要求的值并移除它</p>
</li>
<li><p>in关键字：查询一个值是否在列表中，not in表示不在</p>
</li>
</ul>
<blockquote>
<p>​    与字典和集合相比，检查列表是否包含一个值很缓慢，因为需要遍历，而字典和集合是基于哈希表同时查找的。</p>
</blockquote>
<p><strong>连接和联合列表</strong></p>
<ul>
<li>两个列表可以用+号连接</li>
<li>extend方法向列表中添加多个元素</li>
</ul>
<blockquote>
<p>​    extend方法比用添加内容来连接列表代价更高，因为连接过程涉及创建新列表、复制对象；使用extend将元素添加到已经存在的列表是更好的方式（尤其是大型链表）。</p>
</blockquote>
<p><strong>排序</strong></p>
<ul>
<li>使用sort方法进行列表内部排序</li>
</ul>
<p><strong>二分搜索和已排序列表的维护</strong></p>
<ul>
<li><p>内建的bisect模块实现了二分搜索和已排序列表的插值</p>
<ul>
<li><p>bisect.bisect会找到元素应当被插入的位置，并保持序列排序</p>
</li>
<li><p>bisect.bisect会找到元素应当被插入的位置，并保持序列排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line">c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line">bisect.bisect(c,<span class="number">5</span>) <span class="comment"># 输出6</span></span><br><span class="line">bisect.insort(c,<span class="number">6</span>)</span><br><span class="line">c <span class="comment"># 输出[1, 2, 2, 2, 3, 4, 6, 7]</span></span><br></pre></td></tr></table></figure>


</li>
<li><blockquote>
<p>因为代价问题，bisect模块的函数不会检查列表是否已经排序，对未排序列表使用bisect的函数虽然不会报错，但可能会导致不正确的结果。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>切片</strong></p>
<ul>
<li>使用切片可以选取子集，也可以用来赋值</li>
<li>切片包含起始位置start，不包含结尾stop，元素数量：stop-start</li>
<li>切片索引省略会默认传入起始位置或结束位置</li>
<li>负索引可以从序列的尾部进行索引</li>
<li>步进值step可以在第二个冒号后面使用，意思是每隔多少个数取一个值；对列表或元组进行翻转时，向步进传值-1</li>
</ul>
<h3 id="内建序列函数"><a href="#内建序列函数" class="headerlink" title="内建序列函数"></a>内建序列函数</h3><p><strong>enumerate</strong></p>
<ul>
<li><p>遍历序列时，同时追踪当前元素的索引，使用enumerate函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i,value <span class="keyword">in</span> <span class="built_in">enumerate</span>(collection):</span><br><span class="line">    <span class="comment"># 使用值做点事</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对数据建立索引，使用enumerate构造字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">some_list = [<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>,<span class="string">&#x27;baz&#x27;</span>]</span><br><span class="line">mapping = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(some_list):</span><br><span class="line">    mapping[v] = i</span><br><span class="line">mapping <span class="comment"># 输出 &#123;&#x27;foo&#x27;: 0, &#x27;bar&#x27;: 1, &#x27;baz&#x27;: 2&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>sorted</strong></p>
<ul>
<li>sorted函数返回一个根据任意序列中的元素新建的已排序列表</li>
</ul>
<p><strong>zip</strong></p>
<ul>
<li><p>zip将列表、元组或其他序列的元素配对，新建一个元组构成的列表</p>
</li>
<li><p>zip将列表、元组或其他序列的元素配对，新建一个元组构成的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seq1 = [<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>,<span class="string">&#x27;baz&#x27;</span>]</span><br><span class="line">seq2 = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>]</span><br><span class="line">zipped = <span class="built_in">zip</span>(seq1,seq2)</span><br><span class="line"><span class="built_in">list</span>(zipped)</span><br><span class="line"><span class="comment"># 输出：[(&#x27;foo&#x27;, &#x27;one&#x27;), (&#x27;bar&#x27;, &#x27;two&#x27;), (&#x27;baz&#x27;, &#x27;three&#x27;)]</span></span><br><span class="line">seq3 = [<span class="literal">False</span>,<span class="literal">True</span>]</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">zip</span>(seq1,seq2,seq3))</span><br><span class="line"><span class="comment"># 输出：[(&#x27;foo&#x27;, &#x27;one&#x27;, False), (&#x27;bar&#x27;, &#x27;two&#x27;, True)]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>zip常用场景：<u>和enumerate同时使用同时遍历多个序列</u></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i,(a,b) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(seq1,seq2)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>:<span class="subst">&#123;a&#125;</span>,<span class="subst">&#123;b&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0:foo,one</span></span><br><span class="line"><span class="string">1:bar,two</span></span><br><span class="line"><span class="string">2:baz,three</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>zip“拆分”已“配对”的序列，也就是将行的列表转换为列的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pitchers = [(<span class="string">&#x27;Nolan&#x27;</span>,<span class="string">&#x27;Ryan&#x27;</span>),(<span class="string">&#x27;Roger&#x27;</span>,<span class="string">&#x27;Clemens&#x27;</span>),(<span class="string">&#x27;Schilling&#x27;</span>,<span class="string">&#x27;Curt&#x27;</span>)]</span><br><span class="line">first_names,last_names = <span class="built_in">zip</span>(*pitchers)</span><br><span class="line">first_names <span class="comment"># (&#x27;Nolan&#x27;, &#x27;Roger&#x27;, &#x27;Schilling&#x27;)</span></span><br><span class="line">last_names <span class="comment"># (&#x27;Ryan&#x27;, &#x27;Clemens&#x27;, &#x27;Curt&#x27;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>reversed</strong></p>
<ul>
<li>reversed函数可以将序列的元素倒序排列，它是一个生成器，在没有进行实例化的时候，它并不会产生一个倒序的列表</li>
</ul>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul>
<li><p>字典，也是哈希表和关联数组</p>
</li>
<li><p>用大括号{}创建字典，在字典中用逗号将键值对分隔</p>
</li>
<li><p>用del关键字或pop方法删除值，pop方法会在删除的同时返回被删的值，并删除键</p>
</li>
<li><p>keys方法和values方法可以提供字典键、值的迭代器</p>
</li>
<li><p>update方法将两个字典合并</p>
<blockquote>
<p>update方法改变了字典中元素位置，用del关键字或pop方法删除值，pop方法会在删除的同时返回被删的值，并删除键。</p>
</blockquote>
</li>
</ul>
<p><strong>从序列生成字典</strong></p>
<ul>
<li><p>字典本质上是2-元组（含有2个元素的元组）的集合，字典是可以接受一个2-元组的列表作为参数的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mapping = <span class="built_in">dict</span>(<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">5</span>),<span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">5</span>))))</span><br><span class="line">mapping</span><br><span class="line"><span class="comment"># 输出：&#123;0: 4, 1: 3, 2: 2, 3: 1, 4: 0&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>默认值</strong></p>
<ul>
<li><p>字典的get方法和pop方法可以返回一个默认值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = some_dict.get(key,default_value)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>带有默认值的get方法会在key参数不是字典的键时返回None，而pop会抛出异常</p>
</blockquote>
</li>
<li><p>常用场景：字典中的值集合通过设置成为另外一种值集合，例子：根据首字母分类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">words = [<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;bat&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>,<span class="string">&#x27;atom&#x27;</span>,<span class="string">&#x27;book&#x27;</span>]</span><br><span class="line">by_letter = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    letter = word[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> letter <span class="keyword">not</span> <span class="keyword">in</span> by_letter:</span><br><span class="line">        by_letter[letter] = [word]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        by_letter[letter].append(word)</span><br><span class="line"></span><br><span class="line">by_letter <span class="comment"># 输出：&#123;&#x27;a&#x27;: [&#x27;apple&#x27;, &#x27;atom&#x27;], &#x27;b&#x27;: [&#x27;bat&#x27;, &#x27;bar&#x27;, &#x27;book&#x27;]&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>字典的setdefault方法就是为了这个目的而生，上述循环可以改写成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line"> letter = word[<span class="number">0</span>]</span><br><span class="line"> by_letter.setdefault(letter,[]).append(word)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>defaultdict类</strong>：向字典中传入类型或能在各位置生成默认值的函数，生成符合要求的字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">by_letter = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    by_letter[word[<span class="number">0</span>]].append(word)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>有效的字典键类型</strong></p>
<ul>
<li>字典的值可以是任何Python对象，但是键必须是不可变对象，比如标量类型（整数、浮点数、字符串）或元组（且元组内对象也必须是不可变对象）</li>
<li>哈希化：通过hash函数可以检查一个对象是否可以哈希化（即是否可以用作字典的键）</li>
<li>为了将列表作为键，一种方式就是将其转换为元组，而元组只要它内部元素都可以哈希化，则它自己也可哈希化</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li><p>集合是一种无序且元素唯一的容器</p>
</li>
<li><p>创建方式</p>
<ul>
<li>set函数 set([2,2,2,1,3,3])</li>
<li>字面集与大括号的语法{2,2,2,1,3,3}</li>
</ul>
</li>
<li><p>集合支持数学上的集合操作：联合、交集、差集、对称差集。</p>
<ul>
<li><p>并集：a.union(b)，a|b</p>
</li>
<li><p>交集：a.intersection(b)，a&amp;b</p>
</li>
<li><p>集合操作</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220314151044730.png" alt="image-20220314151044730" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>大型集合使用“|&#x3D;”和“&amp;&#x3D;”更高效</p>
</li>
<li><p>和字典类似，集合的元素必须是不可变的。如果想要包含列表型的元素，必须先转换为元组</p>
</li>
<li><p>检查一个集合是否是另一个结合的子集（包含于）或超集（包含）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a_set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;.issubset(a_set) <span class="comment"># True</span></span><br><span class="line">a_set.issuperset(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; == &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125; <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 当且仅当两个集合的内容一模一样时，两个集合才相等</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="列表、集合和字典的推导式"><a href="#列表、集合和字典的推导式" class="headerlink" title="列表、集合和字典的推导式"></a>列表、集合和字典的推导式</h3><ul>
<li><p>过滤容器元素生成新的列表：[expr for val in collection if condition]，与下面for循环等价</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> collection:</span><br><span class="line">    <span class="keyword">if</span> Condition:</span><br><span class="line">        result.append(expr)</span><br></pre></td></tr></table></figure>

<p>过滤出字符串列表长度大于2的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">strings = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;as&#x27;</span>,<span class="string">&#x27;bat&#x27;</span>,<span class="string">&#x27;car&#x27;</span>,<span class="string">&#x27;dove&#x27;</span>,<span class="string">&#x27;python&#x27;</span>]</span><br><span class="line">[x.upper() <span class="keyword">for</span> x <span class="keyword">in</span> strings <span class="keyword">if</span> <span class="built_in">len</span>(x)&gt;<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 输出：[&#x27;BAT&#x27;, &#x27;CAR&#x27;, &#x27;DOVE&#x27;, &#x27;PYTHON&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字典推导式</p>
<ul>
<li><p>&#96;&#96;&#96;python<br>dict_comp &#x3D; {key-expr:value-expr for value in collection if condition}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 推导式实现一个集合包含列表中字符串的长度</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  unique_lengths = &#123;len(x) for x in strings&#125;</span><br><span class="line">  unique_lengths</span><br><span class="line">  # &#123;1, 2, 3, 4, 6&#125;</span><br></pre></td></tr></table></figure>

<p>使用map函数更函数化、更简洁地表达</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">len</span>,strings))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>嵌套列表推导式</strong></p>
<ul>
<li>可以嵌套多层列表推导式</li>
</ul>
<h2 id="3-2-函数"><a href="#3-2-函数" class="headerlink" title="3.2 函数"></a>3.2 函数</h2><ul>
<li>函数使用def关键字声明，return关键字返回</li>
<li>可以有多条返回语句，如果到结尾仍然没有return语句，自动返回None</li>
<li>每个函数都有位置参数和关键字参数<ul>
<li>关键字参数常用于指定默认值或可选参数</li>
<li>关键字参数必须跟在位置参数后</li>
<li>可以按任意顺序指定关键字参数，不必强行记住参数的顺序，而只需用参数名指定</li>
</ul>
</li>
</ul>
<h3 id="命名空间、作用域和本地函数"><a href="#命名空间、作用域和本地函数" class="headerlink" title="命名空间、作用域和本地函数"></a>命名空间、作用域和本地函数</h3><ul>
<li><p>函数两种连接变量的方式：全局、本地</p>
</li>
<li><p>描述变量作用域的名称是命名空间</p>
<ul>
<li><p>在函数内部，任意变量默认分配到本地命名空间，在函数被调用时生成，执行结束后被销毁</p>
</li>
<li><p>在函数外声明变量，可以在外部给变量赋值，但是变量必须用global关键字声明为全局变量</p>
</li>
<li><blockquote>
<p>通常全局变量用来存储系统中的某些状态</p>
<p>大量使用全局变量时，表明需要面向对象编程</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><ul>
<li>返回多个值实际是返回了一个对象，也就是元组，而元组又被拆包为多个结果变量</li>
</ul>
<h3 id="函数是对象"><a href="#函数是对象" class="headerlink" title="函数是对象"></a>函数是对象</h3><ul>
<li><p>Python函数是对象，很多在其他语言中比较难的构造在Python中很容易实现，例子：去除用户提交数据中的凌乱字符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_strings</span>(<span class="params">strings</span>):</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> strings:</span><br><span class="line">        value = value.strip()</span><br><span class="line">        value = re.sub(<span class="string">&#x27;[! #?]&#x27;</span>,<span class="string">&#x27;&#x27;</span>,value)</span><br><span class="line">        value = value.title()</span><br><span class="line">        result.append(value)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">states = states = [<span class="string">&#x27;   Alabama &#x27;</span>, <span class="string">&#x27;Georgia!&#x27;</span>, <span class="string">&#x27;Georgia&#x27;</span>, <span class="string">&#x27;georgia&#x27;</span>, <span class="string">&#x27;FlOrIda&#x27;</span>,<span class="string">&#x27;south   carolina##&#x27;</span>, <span class="string">&#x27;West virginia?&#x27;</span>]</span><br><span class="line"></span><br><span class="line">clean_strings(states)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[&#x27;Alabama&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Georgia&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Georgia&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Georgia&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Florida&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Southcarolina&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Westvirginia&#x27;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>函数化的模式可以使你在更高层次上方便地修改字符串变换方法，例子：将特定的列表操作应用到某个特定的字符串集合上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove_punctuation</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="keyword">return</span> re.sub(<span class="string">&#x27;[! #? ]&#x27;</span>,<span class="string">&#x27;&#x27;</span>,value)</span><br><span class="line">clean_ops = [<span class="built_in">str</span>.strip,remove_punctuation,<span class="built_in">str</span>.title]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_strings</span>(<span class="params">strings,ops</span>):</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> strings:</span><br><span class="line">        <span class="keyword">for</span> function <span class="keyword">in</span> ops:</span><br><span class="line">            value = function(value)</span><br><span class="line">        result.append(value)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">clean_strings(states,clean_ops)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[&#x27;Alabama&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Georgia&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Georgia&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Georgia&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Florida&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Southcarolina&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;Westvirginia&#x27;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>可以将函数作为一个参数传给其他的函数，比如内建的map函数</p>
</li>
</ul>
<h3 id="匿名（Lambda）函数"><a href="#匿名（Lambda）函数" class="headerlink" title="匿名（Lambda）函数"></a>匿名（Lambda）函数</h3><ul>
<li><p>匿名函数是一种通过单个语句生成函数的方式，其结果是返回值</p>
</li>
<li><p>匿名函数使用lambda关键字定义，该关键字仅表达“我们声明一个匿名函数”的意思</p>
</li>
<li><p>匿名函数代码量小（也更为清晰），将它作为参数进行传值，比写一个完整的函数或者将匿名函数赋值给局部变量更好。<strong>在数据分析中非常方便</strong></p>
</li>
<li><p>假设你想要根据字符串中不同字母的数量对一个字符串集合进行排序，可以将一个匿名函数传给列表的sort方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">strings = [<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;card&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="string">&#x27;abab&#x27;</span>]</span><br><span class="line">strings.sort(key = <span class="keyword">lambda</span> x:<span class="built_in">len</span>(<span class="built_in">set</span>(<span class="built_in">list</span>(x))))</span><br><span class="line">strings</span><br><span class="line"><span class="comment"># 输出：[&#x27;aaaa&#x27;, &#x27;foo&#x27;, &#x27;abab&#x27;, &#x27;bar&#x27;, &#x27;card&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>和def关键字声明的函数不同，匿名函数对象自身并没有一个显式的__name__属性</p>
</li>
</ul>
<h3 id="柯里化：部分参数应用"><a href="#柯里化：部分参数应用" class="headerlink" title="柯里化：部分参数应用"></a>柯里化：部分参数应用</h3><ul>
<li><p>柯里化是计算机科学术语（以数学家Haskell Curry命名），它表示通过部分参数应用的方式从已有的函数中衍生出新的函数</p>
</li>
<li><p>示例</p>
<ul>
<li><p>实现两个函数相加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_numbers</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br></pre></td></tr></table></figure>
</li>
<li><p>衍生出一个只有一个变量的新函数，add_five，可以给参数加上5</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add_five = <span class="keyword">lambda</span> y:add_numbers(<span class="number">5</span>,y)</span><br></pre></td></tr></table></figure>
</li>
<li><p>内建的functools模块可以使用Pratial函数简化处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line">add_five = partial(add_numbers,<span class="number">5</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><ul>
<li>迭代器协议是一种令对象可遍历的通用方式</li>
<li>大部分以列表或列表型对象为参数的方法都可以接收任意的迭代器对象。包括内建方法比如min、max和sum，以及类型构造函数比如list和tuple</li>
<li>生成器一次返回多个结果序列，产生一个元素后暂停，直到下一个请求。创建生成器需要将return替换为yield关键字</li>
<li>实际调用生成器时，代码并不会立即执行，直到你请求生成器中的元素时，它才会执行它的代码。</li>
</ul>
<p><strong>生成器表达式</strong></p>
<ul>
<li>用生成器表达式来创建生成器更简单，与列表推导式类似，把其中括号换成小括号即可。</li>
<li>生成器表达式可以作为函数参数用于替代列表推导式</li>
</ul>
<p><strong>itertools模块</strong></p>
<ul>
<li><p>标准库中的itertools模块是适用于大多数数据算法的生成器集合</p>
</li>
<li><p>例子：groupby可以根据任意的序列和一个函数，通过函数的返回值对序列中连续的元素进行分组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">first_letter = <span class="keyword">lambda</span> x:x[<span class="number">0</span>]</span><br><span class="line">names = [<span class="string">&#x27;Alan&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;Wes&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Albert&#x27;</span>, <span class="string">&#x27;Steven&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> letter, names <span class="keyword">in</span> itertools.groupby(names, first_letter):</span><br><span class="line">    <span class="built_in">print</span>(letter, <span class="built_in">list</span>(names)) <span class="comment"># names is a generator</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">A [&#x27;Alan&#x27;, &#x27;Adam&#x27;]</span></span><br><span class="line"><span class="string">W [&#x27;Wes&#x27;, &#x27;Will&#x27;]</span></span><br><span class="line"><span class="string">A [&#x27;Albert&#x27;]</span></span><br><span class="line"><span class="string">S [&#x27;Steven&#x27;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一些有用的内建工具库信息        <img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220315141817033.png" alt="image-20220315141817033" style="zoom:67%;" /></p>
</li>
</ul>
<h3 id="错误和异常处理"><a href="#错误和异常处理" class="headerlink" title="错误和异常处理"></a>错误和异常处理</h3><ul>
<li><pre><code class="python">def attempt_float(x):
    try:
        return float(x)
    except (TypeError, ValueError):
        return x
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 无论try是否报错都要执行，使用finally</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  f = open(path,&#x27;w&#x27;)</span><br><span class="line">  try:</span><br><span class="line">      write_to_file(f)</span><br><span class="line">  finally:</span><br><span class="line">      f.close()</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>使用else来执行当try代码块成功执行时才会执行的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(path,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    write_to_file(f)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Succeeded&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>IPython中的异常</strong></p>
<ul>
<li>报错时，IPython将会默认打印出完整的调用堆栈跟踪（报错追溯）。</li>
<li>使用%xmode命令来控制上下文的数量，可以从Plain（普通）模（与标准Python解释器一致）切换到Verbose（复杂）模式（可以显示函数的参数值以及更多有用信息）。</li>
</ul>
<h3 id="文件与操作系统"><a href="#文件与操作系统" class="headerlink" title="文件与操作系统"></a>文件与操作系统</h3><ul>
<li><p>打开文件进行读取或写入，需要使用内建函数open和绝对、相对路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">&#x27;examples/segismundo.txt&#x27;</span></span><br><span class="line">f = <span class="built_in">open</span>(path)</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认文件以只读方式打开，可以像处理列表一样遍历文件f中的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>行结尾标识（EOL）完整，文件内容被全部读出，一些代码的功能就是从文件中读出不带EOL的内容列表</p>
</li>
<li><p>使用open来创建文件对象时，在结束时<strong>显式关闭</strong>文件非常重要，关闭文件会将资源释放回操作系统。</p>
<ul>
<li>&#96;&#96;&#96;python<br>f.close()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 使用with语句关闭</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  with open(path) as f:</span><br><span class="line">      lines = [x.rstrip() for x in f]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>写下f&#x3D;open(path, ‘w’)，一个新的文件会examples&#x2F;segismundo.txt的位置被创建（请小心！），并在同一路径下覆盖同名文件。</p>
</li>
<li><p>’x’文件模式，它会创建可写的文件，但如果给定路径下已经存在同名文件就会创建失败</p>
</li>
<li><p>可读文件常用方法：read、seek、tell</p>
<ul>
<li>read返回文件中一定量的字符，通过读取的字节数来推进文件句柄的位置</li>
<li>ell方法可以给出句柄当前的位置：f.tell()</li>
<li>seek方法可以将句柄位置改变到文件中特定的字节：f.seek(3)</li>
</ul>
</li>
<li><p>使用sys模块来检查文件的默认编码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.getdefaultencoding() <span class="comment">#&#x27;utf-8&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Python文件模式<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220315145945478.png" alt="image-20220315145945478" style="zoom:80%;" /></p>
</li>
<li><p>写文件：使用文件对象的write或wirtelines方法</p>
</li>
<li><p>重要的Python文件方法或属性</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220315150219007.png" alt="image-20220315150219007" style="zoom:80%;" /></li>
</ul>
<p><strong>字节与Unicode文件</strong></p>
<ul>
<li>根据文本编码，你可能会将字节解码为str对象，但是只有每个已编码的Unicode字符是完整的情况下，才能进行解码</li>
<li>文本模式下，利用open方法的参数encoding可以将文件内容从Unicode编码转换为其他类型的编码</li>
<li>除了二进制模式，在打开文件时使用seek要当心。如果文件的句柄位置恰好在一个Unicode符号的字节中间时，后续的读取会导致错误</li>
<li>常常需要在非ASCⅡ文本数据上进行数据分析，那么精通Python的Unicode功能是很有必要的，具体参见官方文档。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习： 数据分析</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>七、数据清洗与准备——《利用Python进行数据分析》</title>
    <url>/2022/03/29/%E4%B8%83%E3%80%81%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E5%87%86%E5%A4%87%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/</url>
    <content><![CDATA[<h1 id="第七章-数据清洗与准备"><a href="#第七章-数据清洗与准备" class="headerlink" title="第七章 数据清洗与准备"></a>第七章 数据清洗与准备</h1><blockquote>
<p>讨论用于缺失值、重复值、字符串操作和其他分析数据转换的工具</p>
</blockquote>
<h2 id="7-1-处理缺失值"><a href="#7-1-处理缺失值" class="headerlink" title="7.1  处理缺失值"></a>7.1  处理缺失值</h2><blockquote>
<p>pandas对象的所有描述性统计信息默认情况下是排除缺失值的</p>
</blockquote>
<ul>
<li><p>对于数值型数据，pandas使用浮点值NaN（Not a Number来表示缺失值）</p>
<ul>
<li>NA（not available，不可用）</li>
<li>Python内建的None值在对象数组中也被当作NA处理</li>
</ul>
</li>
<li><p>NA处理方法</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_91" alt="epub_22739904_91" style="zoom:50%;" /></li>
</ul>
<h3 id="过滤缺失值"><a href="#过滤缺失值" class="headerlink" title="过滤缺失值"></a>过滤缺失值</h3><ul>
<li><p>过滤缺失值方法</p>
<ul>
<li><p>使用pandas.isnull和布尔值索引</p>
</li>
<li><p>使用dropna</p>
<ul>
<li><p>在Series上使用，会返回Series中所有的非空数据及其索引值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> nan <span class="keyword">as</span> NA</span><br><span class="line">data = pd.Series([<span class="number">1</span>,NA,<span class="number">3.5</span>,NA,<span class="number">7</span>])</span><br><span class="line">data.dropna()</span><br></pre></td></tr></table></figure>

<p>等价表示：<code>data[data.notnull()]</code></p>
</li>
<li><p>处理DataFrame对象时，dropna默认删除包含缺失值的<strong>行</strong></p>
<ul>
<li><p>传入how&#x3D;’all’时，将删除所有值均为NA的行</p>
</li>
<li><p>删除列，传入参数axis&#x3D;1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.dropna(axis=<span class="number">1</span>,how=<span class="string">&#x27;all&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用thresh参数保留一定数量的观察值的行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dropna(thresh=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="补全缺失值"><a href="#补全缺失值" class="headerlink" title="补全缺失值"></a>补全缺失值</h3><ul>
<li><p>使用fillna方法来补全缺失值</p>
<ul>
<li>可以使用一个常数来代替缺失值：<code>df.fillna(0)</code></li>
<li>调用时使用<strong>字典</strong>来为不同<strong>列</strong>设定不同的填充值：<code>df.fillna(&#123;1:0,2:0&#125;)</code></li>
<li>fillna返回一个新对象，也可以修改意见存在的对象：<code>df.fillna(0,inplace=True)</code></li>
<li>用于重建索引的相同的插值方法也可以用于fillna：<code>df.fillna(method=‘ffill’,limit=2)</code></li>
<li>使用fillna完成创造性填充：<code>data.fillna(data.mean())</code></li>
</ul>
</li>
<li><p>fillna函数参数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_92" alt="img" style="zoom:50%;" /></li>
</ul>
<h2 id="7-2-数据转换"><a href="#7-2-数据转换" class="headerlink" title="7.2 数据转换"></a>7.2 数据转换</h2><h3 id="删除重复值"><a href="#删除重复值" class="headerlink" title="删除重复值"></a>删除重复值</h3><ul>
<li><p>有些数据会出现<strong>重复行</strong></p>
<ul>
<li><p>DataFrame的duplicated方法返回一个布尔值的Series，反映每一行是否与之前出现过相同的行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.DataFrame(&#123;<span class="string">&#x27;k1&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>] * <span class="number">3</span> + [<span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">                     <span class="string">&#x27;k2&#x27;</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]&#125;)</span><br><span class="line">data</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	k1	k2</span></span><br><span class="line"><span class="string">0	one	1</span></span><br><span class="line"><span class="string">1	two	1</span></span><br><span class="line"><span class="string">2	one	2</span></span><br><span class="line"><span class="string">3	two	3</span></span><br><span class="line"><span class="string">4	one	3</span></span><br><span class="line"><span class="string">5	two	4</span></span><br><span class="line"><span class="string">6	two	4</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">data.duplicated()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0    False</span></span><br><span class="line"><span class="string">1    False</span></span><br><span class="line"><span class="string">2    False</span></span><br><span class="line"><span class="string">3    False</span></span><br><span class="line"><span class="string">4    False</span></span><br><span class="line"><span class="string">5    False</span></span><br><span class="line"><span class="string">6     True</span></span><br><span class="line"><span class="string">dtype: bool</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>drop_duplicates返回duplicated返回数组中为False的部分，格式为DataFrame</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.drop_duplicates()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	k1	k2</span></span><br><span class="line"><span class="string">0	one	1</span></span><br><span class="line"><span class="string">1	two	1</span></span><br><span class="line"><span class="string">2	one	2</span></span><br><span class="line"><span class="string">3	two	3</span></span><br><span class="line"><span class="string">4	one	3</span></span><br><span class="line"><span class="string">5	two	4</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法默认针对<strong>列</strong>，可以指定数据的子集来检测是否有重复</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设有一个额外的列，并想基于’k1’列去除重复值</span></span><br><span class="line">data[<span class="string">&#x27;v1&#x27;</span>] = <span class="built_in">range</span>(<span class="number">7</span>)</span><br><span class="line">data.drop_duplicates([<span class="string">&#x27;k1&#x27;</span>])</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">k1	k2	v1</span></span><br><span class="line"><span class="string">0	one	1	0</span></span><br><span class="line"><span class="string">1	two	1	1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>【注意】</strong>：uplicated和drop_duplicates默认都是保留第一个观测到的值。传入参数keep&#x3D;’last’将会返回最后一个</p>
</li>
</ul>
</li>
</ul>
<h3 id="使用函数或映射进行数据转换"><a href="#使用函数或映射进行数据转换" class="headerlink" title="使用函数或映射进行数据转换"></a>使用函数或映射进行数据转换</h3><blockquote>
<p>基于DataFrame中的数组、列或列中的数值进行一些转换</p>
<p>map是一种可以便捷执行按元素转换及其他清洗相关操作的方法</p>
</blockquote>
<p>收集到的基于肉类的假设数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.DataFrame(&#123;<span class="string">&#x27;food&#x27;</span>: [<span class="string">&#x27;bacon&#x27;</span>, <span class="string">&#x27;pulled pork&#x27;</span>, <span class="string">&#x27;bacon&#x27;</span>,</span><br><span class="line">                              <span class="string">&#x27;Pastrami&#x27;</span>, <span class="string">&#x27;corned beef&#x27;</span>, <span class="string">&#x27;Bacon&#x27;</span>,</span><br><span class="line">                              <span class="string">&#x27;pastrami&#x27;</span>, <span class="string">&#x27;honey ham&#x27;</span>, <span class="string">&#x27;nova lox&#x27;</span>],</span><br><span class="line">                     <span class="string">&#x27;ounces&#x27;</span>: [<span class="number">4</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329161532043.png" alt="image-20220329161532043" style="zoom: 50%;" />

<ul>
<li><p>添加一列用于表明每种食物的动物肉类型，先写下一个食物和肉类的映射</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">meat_to_animal = &#123;</span><br><span class="line">  <span class="string">&#x27;bacon&#x27;</span>: <span class="string">&#x27;pig&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pulled pork&#x27;</span>: <span class="string">&#x27;pig&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pastrami&#x27;</span>: <span class="string">&#x27;cow&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;corned beef&#x27;</span>: <span class="string">&#x27;cow&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;honey ham&#x27;</span>: <span class="string">&#x27;pig&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;nova lox&#x27;</span>: <span class="string">&#x27;salmon&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Series的str.lower方法将每个值都转换为小写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lowercased = data[<span class="string">&#x27;food&#x27;</span>].<span class="built_in">str</span>.lower()</span><br></pre></td></tr></table></figure>
</li>
<li><p>Series的map方法接收<strong>一个函数</strong>或<strong>一个包含映射关系</strong>的<strong>字典型对象</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[<span class="string">&#x27;animal&#x27;</span>] = lowercased.<span class="built_in">map</span>(meat_to_animal)</span><br><span class="line">data</span><br></pre></td></tr></table></figure></li>
</ul>
<p>总结：传入一个能够完成所有工作的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[<span class="string">&#x27;food&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: meat_to_animal[x.lower()])</span><br></pre></td></tr></table></figure>

<h3 id="替代值"><a href="#替代值" class="headerlink" title="替代值"></a>替代值</h3><ul>
<li>使用replace方法更灵活地替代缺失值：<code>data.replace(-999,np.nan)</code></li>
<li>一次替代多个值，传入一个列表和一个替代值：<code>data.replace([-999,-1000],np.nan)</code></li>
<li>将不同的值替换为不同的值，可以传入替代值的列表:<code>data.replace([-999, -1000], [np.nan, 0])</code>；也可通过字典传递：<code>data.replace(&#123;-999: np.nan, -1000: 0&#125;)</code></li>
</ul>
<blockquote>
<p>data.replace方法与data.str.replace方法是不同的</p>
<p>data.str. replace是对字符串进行按元素替代的</p>
</blockquote>
<h3 id="重命名轴索引"><a href="#重命名轴索引" class="headerlink" title="重命名轴索引"></a>重命名轴索引</h3><p>数据</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329163415871.png" alt="image-20220329163415871" style="zoom:50%;" />

<ul>
<li><p>修改轴</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transform = <span class="keyword">lambda</span> x : x[:<span class="number">4</span>].upper() </span><br><span class="line">data.index.<span class="built_in">map</span>(transform)</span><br><span class="line"><span class="comment"># Index([&#x27;OHIO&#x27;, &#x27;COLO&#x27;, &#x27;NEW &#x27;], dtype=&#x27;object&#x27;)</span></span><br><span class="line"><span class="comment"># 赋值给index，修改DataFrame</span></span><br><span class="line">data.index = data.index.<span class="built_in">map</span>(transform)</span><br><span class="line">data</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329163828079.png" alt="image-20220329163828079" style="zoom:50%;" />
</li>
<li><p><strong>rename</strong>：创建数据集转换后的版本，并且不修改原有的数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.rename(index=<span class="built_in">str</span>.title,columns=<span class="built_in">str</span>.upper)</span><br><span class="line"><span class="comment"># rename可以结合字典型对象使用，为轴标签的子集提供新的值</span></span><br><span class="line">data.rename(index=&#123;<span class="string">&#x27;OHIO&#x27;</span>:<span class="string">&#x27;INDIANA&#x27;</span>&#125;,</span><br><span class="line">            columns=&#123;<span class="string">&#x27;three&#x27;</span>:<span class="string">&#x27;peekaboo&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>想要修改原有的数据，传入<code>inplace=True</code></p>
</li>
</ul>
<h3 id="离散化和分箱"><a href="#离散化和分箱" class="headerlink" title="离散化和分箱"></a>离散化和分箱</h3><blockquote>
<p>连续值经常需要离散化，或者分离成”箱子“进行分析</p>
</blockquote>
<p>假设研究一组人群的数据，将他们进行分组，放入离散的年龄框中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ages = [<span class="number">20</span>, <span class="number">22</span>, <span class="number">25</span>, <span class="number">27</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">37</span>, <span class="number">31</span>, <span class="number">61</span>, <span class="number">45</span>, <span class="number">41</span>, <span class="number">32</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用<strong>pandas中的cut</strong>将这些年龄分为18～25、26～35、36～60以及61及以上等若干组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bins = [<span class="number">18</span>,<span class="number">25</span>,<span class="number">35</span>,<span class="number">60</span>,<span class="number">100</span>]</span><br><span class="line">cats = pd.cut(ages,bins)</span><br><span class="line">cats <span class="comment"># 特殊的Categorical对象</span></span><br></pre></td></tr></table></figure>

<p>返回值：一个特殊的Categorical对象，可当作表示箱名字的字符串数组，在内部包含一个categories（类别）数组，指定了不同的类别名称以及codes属性的ages（年龄）数据标签</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cats.codes</span><br><span class="line"><span class="comment"># array([0, 0, 0, 1, 0, 0, 2, 1, 3, 2, 2, 1], dtype=int8)</span></span><br><span class="line">cats.categories</span><br><span class="line"><span class="comment"># IntervalIndex([(18, 25], (25, 35], (35, 60], (60, 100]], dtype=&#x27;interval[int64, right]&#x27;)</span></span><br><span class="line">pd.value_counts(cats) <span class="comment"># 对pandas.cut的结果中的箱数量的计数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>小括号表示边开放，中括号表示封闭；通过传递right&#x3D;False来改变哪一边是封闭的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.cut(ages,[<span class="number">18</span>,<span class="number">26</span>,<span class="number">36</span>,<span class="number">61</span>,<span class="number">100</span>],right=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>向labels选项传递一个列表或数组来传入自定义的箱名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">group_names = [<span class="string">&#x27;Youth&#x27;</span>, <span class="string">&#x27;YoungAdult&#x27;</span>, <span class="string">&#x27;MiddleAged&#x27;</span>, <span class="string">&#x27;Senior&#x27;</span>]</span><br><span class="line">pd.cut(ages, bins, labels=group_names)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[18, 26), [18, 26), [18, 26), [26, 36), [18, 26), ..., [26, 36), [61, 100), [36, 61), [36, 61), [26, 36)]</span></span><br><span class="line"><span class="string">Length: 12</span></span><br><span class="line"><span class="string">Categories (4, interval[int64, left]): [[18, 26) &lt; [26, 36) &lt; [36, 61) &lt; [61, 100)]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传给cut整数个的箱来代替显示的箱边，自动根据数据最值计算等长的箱</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 均匀分布的数据被切成四份</span></span><br><span class="line">data = np.random.rand(<span class="number">20</span>)</span><br><span class="line">pd.cut(data,<span class="number">4</span>,precision=<span class="number">2</span>) <span class="comment"># precision=2将十进制精度限制在两位</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>qcut基于样本分位数进行分箱，可以使用qcut获得等长的箱</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = np.random.randn(<span class="number">1000</span>)  <span class="comment"># Normally distributed</span></span><br><span class="line">cats = pd.qcut(data, <span class="number">4</span>)  <span class="comment"># Cut into quartiles</span></span><br><span class="line">cats</span><br><span class="line">pd.value_counts(cats) <span class="comment"># 每个箱数量都是250</span></span><br></pre></td></tr></table></figure>

<p>可以传入自定义的分位数（0和1之间的数据，包括边）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.qcut(data, [<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">0.9</span>, <span class="number">1.</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="检测和过滤异常值"><a href="#检测和过滤异常值" class="headerlink" title="检测和过滤异常值"></a>检测和过滤异常值</h3><ul>
<li><p>举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 具有正态分布数据的DataFrame</span></span><br><span class="line">data = pd.DataFrame(np.random.randn(<span class="number">1000</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment"># 假设你想要找出一列中绝对值大于三的值</span></span><br><span class="line">col = data[<span class="number">2</span>]</span><br><span class="line">col[np.<span class="built_in">abs</span>(col) &gt; <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 选出所有值大于3或小于-3的行，对布尔值DataFrame使用any方法</span></span><br><span class="line">data[(np.<span class="built_in">abs</span>(data)&gt;<span class="number">3</span>).<span class="built_in">any</span>(<span class="number">1</span>)]</span><br><span class="line"><span class="comment"># 限制-3到3之间的数值</span></span><br><span class="line">data[np.<span class="built_in">abs</span>(data)&gt;<span class="number">3</span>] = np.sign(data) * <span class="number">3</span></span><br><span class="line">data.describe()</span><br></pre></td></tr></table></figure>
</li>
<li><p>np.sign(data)根据数据中的值的正负分别生成1和-1的数值：<code>np.sign(data).head()</code></p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329185902275.png" alt="image-20220329185902275" style="zoom:50%;" /></li>
</ul>
<h3 id="置换和随机抽样"><a href="#置换和随机抽样" class="headerlink" title="置换和随机抽样"></a>置换和随机抽样</h3><blockquote>
<p>使用numpy.random.permutation对DataFrame中的Series或行进行置换（随机重排序）是非常方便的</p>
</blockquote>
<ul>
<li><p>调用permutation时可根据轴长度产生一个新顺序的整数数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(np.arange(<span class="number">5</span>*<span class="number">4</span>).reshape((<span class="number">5</span>,<span class="number">4</span>)))</span><br><span class="line">sampler = np.random.permutation(<span class="number">5</span>)</span><br><span class="line">sampler <span class="comment"># array([1, 4, 3, 2, 0])</span></span><br><span class="line"><span class="comment"># 整数数组可以用在基于iloc的索引或等价的take函数中</span></span><br><span class="line">df.take(sampler)</span><br></pre></td></tr></table></figure>
</li>
<li><p>选出不含有替代值的随机子集，可以使用sample方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.sample(n=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 生成带有替代值的样本（允许有重复选择），将replace=True传入sample方法</span></span><br><span class="line">choices = pd.Series([<span class="number">5</span>,<span class="number">7</span>,-<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>])</span><br><span class="line">draws = choices.sample(n=<span class="number">10</span>,replace=<span class="literal">True</span>)</span><br><span class="line">draws</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="计算指标、虚拟变量"><a href="#计算指标、虚拟变量" class="headerlink" title="计算指标、虚拟变量"></a>计算指标、虚拟变量</h3><blockquote>
<p>将分类变量转换为“虚拟”或“指标”矩阵</p>
</blockquote>
<ul>
<li><p>如果DataFrame中的一列有k个不同的值，则可以衍生一个k列的值为1和0的矩阵或DataFrame（pandas有一个<strong>get_dummies函数</strong>用于实现该功能）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">6</span>)&#125;)</span><br><span class="line">pd.get_dummies(df[<span class="string">&#x27;key&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在指标DataFrame的列上加入前缀，然后与其他数据合并</span></span><br><span class="line">dummies = pd.get_dummies(df[<span class="string">&#x27;key&#x27;</span>], prefix=<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">df_with_dummy = df[[<span class="string">&#x27;data1&#x27;</span>]].join(dummies)</span><br><span class="line">df_with_dummy</span><br></pre></td></tr></table></figure>

<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329194222196.png" alt="image-20220329194222196" style="zoom:50%;" /><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329194345505.png" alt="image-20220329194345505" style="zoom:50%;" /></p>
</li>
<li><p>多成员构建指标变量</p>
<ul>
<li><p>DataFrame中的一行属于多个类别，则情况略为复杂</p>
<ul>
<li><p>每个电影流派添加指标变量</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329202000815.png" alt="image-20220329202000815" style="zoom:50%;" />
</li>
<li><p>取出所有不同的流派的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_genres = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> movies.genres:</span><br><span class="line">    all_genres.extend(x.split(<span class="string">&#x27;|&#x27;</span>))</span><br><span class="line">genres = pd.unique(all_genres)</span><br><span class="line">genres</span><br></pre></td></tr></table></figure>
</li>
<li><p>用全0的DataFrame构建指标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zero_matrix = np.zeros((<span class="built_in">len</span>(movies),<span class="built_in">len</span>(genres)))</span><br><span class="line">dummies = pd.DataFrame(zero_matrix,columns=genres)</span><br><span class="line"><span class="comment"># 遍历每一部电影，将dummies每一行的条目设置为1</span></span><br><span class="line"><span class="comment"># 使用dummies.columns来计算每一个流派的列指标</span></span><br><span class="line">gen = movies.genres[<span class="number">0</span>]</span><br><span class="line">gen.split(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">dummies.columns.get_indexer(gen.split(<span class="string">&#x27;|&#x27;</span>))</span><br><span class="line"><span class="comment"># array([0, 1, 2], dtype=int64)</span></span><br><span class="line"><span class="keyword">for</span> i,gen <span class="keyword">in</span> <span class="built_in">enumerate</span>(movies.genres):</span><br><span class="line">    indices = dummies.columns.get_indexer(gen.split(<span class="string">&#x27;|&#x27;</span>))</span><br><span class="line">    dummies.iloc[i,indices] = <span class="number">1</span></span><br><span class="line"><span class="comment"># 将结果与movies进行联合</span></span><br><span class="line">movies_windic = movies.join(dummies.add_prefix(<span class="string">&#x27;Genre_&#x27;</span>))</span><br><span class="line">movies_windic.iloc[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329203834522.png" alt="image-20220329203834522" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>对于大数据的快速方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接将数据写为NumPy数组的底层函数，然后将结果封装进DataFrame</span></span><br><span class="line"><span class="comment"># get_dummies与cut等离散化函数结合使用</span></span><br><span class="line">np.random.seed(<span class="number">12345</span>) <span class="comment"># 置随机种子以确保示例的确定性</span></span><br><span class="line">values = np.random.rand(<span class="number">10</span>)</span><br><span class="line">values</span><br><span class="line"><span class="comment"># array([0.92961609, 0.31637555, 0.18391881, 0.20456028, 0.56772503,</span></span><br><span class="line"><span class="comment">#       0.5955447 , 0.96451452, 0.6531771 , 0.74890664, 0.65356987])</span></span><br><span class="line">bins = [<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1</span>]</span><br><span class="line">pd.get_dummies(pd.cut(values, bins))</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329195456052.png" alt="image-20220329195456052" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<h2 id="7-3-字符串操作"><a href="#7-3-字符串操作" class="headerlink" title="7.3 字符串操作"></a>7.3 字符串操作</h2><blockquote>
<p>pandas允许你将字符串和正则表达式简洁地应用到整个数组上</p>
<p>还能处理缺失值带来的困扰</p>
</blockquote>
<h3 id="字符串对象方法"><a href="#字符串对象方法" class="headerlink" title="字符串对象方法"></a>字符串对象方法</h3><ul>
<li><p>一个逗号分隔的字符串可以使用split方法拆分成多块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">val = <span class="string">&#x27;a,b, guido&#x27;</span></span><br><span class="line">val.split(<span class="string">&#x27;,&#x27;</span>) <span class="comment">#val = &#x27;a,b, guido&#x27;a</span></span><br></pre></td></tr></table></figure>

<p>split常和strip一起使用，用于清除空格（包括换行）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">val = <span class="string">&#x27;a,b, guido&#x27;</span></span><br><span class="line">val.split(<span class="string">&#x27;,&#x27;</span>) <span class="comment">#val = &#x27;a,b, guido&#x27;a</span></span><br><span class="line">pieces = [x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> val.split(<span class="string">&#x27;,&#x27;</span>)]</span><br><span class="line">pieces <span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;guido&#x27;]</span></span><br><span class="line"><span class="comment"># 子字符串可以使用加法与两个冒号分隔符连接在一起</span></span><br><span class="line">first ,second , third=pieces</span><br><span class="line">first+<span class="string">&#x27;::&#x27;</span>+second+<span class="string">&#x27;::&#x27;</span>+third <span class="comment"># &#x27;a::b::guido&#x27;</span></span><br><span class="line"><span class="comment"># 更通用方法</span></span><br><span class="line"><span class="string">&#x27;::&#x27;</span>.join(pieces)</span><br></pre></td></tr></table></figure>
</li>
<li><p>尽管index和find也可，Python的in关键字是检测子字符串的最佳方法</p>
<blockquote>
<p>index在字符串没有找到时会抛出一个异常（而find是返回-1）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;guido&#x27;</span> <span class="keyword">in</span> val <span class="comment"># True</span></span><br><span class="line">val.index(<span class="string">&#x27;,&#x27;</span>) <span class="comment"># 1</span></span><br><span class="line">val.find(<span class="string">&#x27;:&#x27;</span>) <span class="comment"># -1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>count返回子字符串出现的次数：<code>val.count(‘,’)</code></p>
</li>
<li><p>replace将用一种模式替代另一种模式。它通常也用于传入空字符串来<strong>删除某个模式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">val.replace(<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;::&#x27;</span>) <span class="comment"># &#x27;a::b:: guido&#x27;</span></span><br><span class="line">val.replace(<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27; &#x27;</span>)  <span class="comment"># &#x27;a b  guido&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Python内建字符串方法</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_95" alt="img" style="zoom:50%;" /></li>
</ul>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><blockquote>
<p>一种在文本中灵活查找或匹配（通常更为复杂的）字符串模式的方法。单个表达式通常被称为regex，是根据正则表达式语言形成的字符串.</p>
</blockquote>
<ul>
<li><p>Python的re模块是将正则表达式应用到字符串上的库</p>
<ul>
<li><p>re模块的三个主题</p>
<ul>
<li>模式匹配</li>
<li>替代</li>
<li>拆分</li>
</ul>
</li>
<li><p>描述<strong>一个或多个空白字符</strong>的正则表达式是<strong>\s+</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># # 将含有多种空白字符（制表符、空格、换行符）的字符串拆分开</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">&quot;foo    bar\t baz  \tqux&quot;</span></span><br><span class="line">re.split(<span class="string">&#x27;\s+&#x27;</span>, text) <span class="comment"># [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;, &#x27;qux&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用<strong>re.compile</strong>自行编译，形成一个<strong>可复用</strong>的正则表达式对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">regex = re.<span class="built_in">compile</span>(<span class="string">&#x27;\s+&#x27;</span>)</span><br><span class="line">regex.split(text) <span class="comment"># [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;, &#x27;qux&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<strong>findall</strong>获得所有匹配正则表达式模式的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">regex.findall(text)</span><br><span class="line"><span class="comment"># [&#x27;    &#x27;, &#x27;\t &#x27;, &#x27;  \t&#x27;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在正则表达式中避免转义符\的影响，可以使用原生字符串语法，比如<code>r&#39;C:\x&#39;</code>或者用等价的<code>’C:\\x&#39;</code></p>
</li>
<li><p>使用re.compile创建一个正则表达式对象，可以将相同的表达式应用到多个字符串上，这样有利于节约CPU周期</p>
</li>
<li><p>match、search、findall</p>
<ul>
<li><p>findall返回字符串中所有匹配项</p>
</li>
<li><p>search仅返回第一个匹配项</p>
</li>
<li><p>match更为严格，只在字符串的起始位置进行匹配</p>
</li>
<li><p>例子：识别大部分电子邮件地址的正则表达式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&quot;&quot;&quot;Dave dave@google.com</span></span><br><span class="line"><span class="string">Steve steve@gmail.com</span></span><br><span class="line"><span class="string">Rob rob@gmail.com</span></span><br><span class="line"><span class="string">Ryan ryan@yahoo.com</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">pattern = <span class="string">r&#x27;[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]&#123;2,4&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># re.IGNORECASE makes the regex case-insensitive</span></span><br><span class="line">regex = re.<span class="built_in">compile</span>(pattern, flags=re.IGNORECASE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用findall会生成一个电子邮件地址的列表</span></span><br><span class="line">regex.findall(text)</span><br><span class="line"><span class="comment"># [&#x27;dave@google.com&#x27;, &#x27;steve@gmail.com&#x27;, &#x27;rob@gmail.com&#x27;, &#x27;ryan@yahoo.com&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># search返回第一个匹配到的电子邮件地址</span></span><br><span class="line">m =regex.search(text)</span><br><span class="line">m <span class="comment"># &lt;re.Match object; span=(5, 20), match=&#x27;dave@google.com&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 匹配对象只能告诉我们模式在字符串中起始和结束的位置</span></span><br><span class="line">text[m.start():m.end()] <span class="comment"># &#x27;dave@google.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># regex.match只在模式出现于字符串起始位置时进行匹配，如果没有匹配到，返回None</span></span><br><span class="line"><span class="built_in">print</span>(regex.match(text)) <span class="comment"># None</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>sub会返回一个新的字符串，原字符串会被新的字符串替代</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(regex.sub(<span class="string">&#x27;REDACTED&#x27;</span>,text))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Dave REDACTED</span></span><br><span class="line"><span class="string">Steve REDACTED</span></span><br><span class="line"><span class="string">Rob REDACTED</span></span><br><span class="line"><span class="string">Ryan REDACTED</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将电子邮件地址分为三个部分：用户名、域名和域名后缀，可以用<strong>括号</strong>将模式包起来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pattern = <span class="string">r&#x27;([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\.([A-Z]&#123;2,4&#125;)&#x27;</span></span><br><span class="line">regex = re.<span class="built_in">compile</span>(pattern, flags=re.IGNORECASE)</span><br><span class="line"><span class="comment"># 使用修改后的对象的groups方法，返回的是模式组件的元组</span></span><br><span class="line">m = regex.match(<span class="string">&#x27;wesm@bright.net&#x27;</span>)</span><br><span class="line">m.groups() <span class="comment"># (&#x27;wesm&#x27;, &#x27;bright&#x27;, &#x27;net&#x27;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>模式可以分组时，findall返回的是包含元组的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">regex.findall(text)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[(&#x27;dave&#x27;, &#x27;google&#x27;, &#x27;com&#x27;),</span></span><br><span class="line"><span class="string"> (&#x27;steve&#x27;, &#x27;gmail&#x27;, &#x27;com&#x27;),</span></span><br><span class="line"><span class="string"> (&#x27;rob&#x27;, &#x27;gmail&#x27;, &#x27;com&#x27;),</span></span><br><span class="line"><span class="string"> (&#x27;ryan&#x27;, &#x27;yahoo&#x27;, &#x27;com&#x27;)]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>sub也可以使用特殊符号，如\1和\2，访问每个匹配对象中的分组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(regex.sub(<span class="string">r&#x27;Username: \1,Domain: \2,Suffix: \3&#x27;</span>,text))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Dave Username: dave,Domain: google,Suffix: com</span></span><br><span class="line"><span class="string">Steve Username: steve,Domain: gmail,Suffix: com</span></span><br><span class="line"><span class="string">Rob Username: rob,Domain: gmail,Suffix: com</span></span><br><span class="line"><span class="string">Ryan Username: ryan,Domain: yahoo,Suffix: com</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>正则表达式方法</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329225833993.png" alt="image-20220329225833993" style="zoom:67%;" /></li>
</ul>
<h3 id="pandas中的向量化字符串函数"><a href="#pandas中的向量化字符串函数" class="headerlink" title="pandas中的向量化字符串函数"></a>pandas中的向量化字符串函数</h3><ul>
<li><p>包含字符串的列有时会含有缺失数据</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220329224259419.png" alt="image-20220329224259419" style="zoom:67%;" />

<p>可以使用<strong>data.map</strong>将字符串和有效的正则表达式方法（以lambda或其他函数的方式传递）应用到每个值上，但是<strong>在NA（null）值上会失败</strong></p>
</li>
<li><p>Series有面向数组的方法用于跳过NA值的字符串操作。这些方法通过Series的str属性进行调用</p>
<ul>
<li>str.contains来检查每个电子邮件地址是否含有’gmail’：<code>data.str.contains(‘gmail’)</code></li>
</ul>
</li>
<li><p>正则表达式也可以结合任意的re模块选项使用，例如IGNORECASE</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pattern</span><br><span class="line">data.<span class="built_in">str</span>.findall(pattern, flags=re.IGNORECASE)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Dave     [(dave, google, com)]</span></span><br><span class="line"><span class="string">Steve    [(steve, gmail, com)]</span></span><br><span class="line"><span class="string">Rob        [(rob, gmail, com)]</span></span><br><span class="line"><span class="string">Wes                        NaN</span></span><br><span class="line"><span class="string">dtype: object</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>进行向量化元素检查</p>
<ul>
<li><p>使用str.get或在str属性内部索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matches = data.<span class="built_in">str</span>.match(pattern,flags=re.IGNORECASE)</span><br></pre></td></tr></table></figure>
</li>
<li><p>要访问嵌入式列表中的元素,将索引传递给这些函数中的任意一个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matches.<span class="built_in">str</span>.get(<span class="number">1</span>)</span><br><span class="line">matches.<span class="built_in">str</span>[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用字符串切片的类似语法进行向量化切片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.<span class="built_in">str</span>[<span class="number">5</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Dave     dave@</span></span><br><span class="line"><span class="string">Steve    steve</span></span><br><span class="line"><span class="string">Rob      rob@g</span></span><br><span class="line"><span class="string">Wes        NaN</span></span><br><span class="line"><span class="string">dtype: object</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>部分向量化字符串方法列表</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_99" alt="img" style="zoom:50%;" /></li>
</ul>
]]></content>
      <categories>
        <category>机器学习： 数据分析</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>五、Pandas入门——《利用Python进行数据分析》</title>
    <url>/2022/03/28/%E4%BA%94%E3%80%81Pandas%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/</url>
    <content><![CDATA[<h1 id="第五章-Pandas入门"><a href="#第五章-Pandas入门" class="headerlink" title="第五章 Pandas入门"></a>第五章 Pandas入门</h1><ul>
<li>pandas经常是和其他数值计算工具，比如NumPy和SciPy，以及数据可视化工具比如matplotlib一起使用。</li>
<li>pandas支持大部分NumPy的数组计算，尤其是<strong>数组函数</strong>以及没<strong>有for循环</strong>的各种数据处理。</li>
<li>pandas处理表格型或异质型数据，NumPy处理同质型的数值类数组数据</li>
<li>常用的类：Series和DataFrame</li>
</ul>
<h2 id="5-1-pandas数据结构介绍"><a href="#5-1-pandas数据结构介绍" class="headerlink" title="5.1 pandas数据结构介绍"></a>5.1 pandas数据结构介绍</h2><h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h3><ul>
<li><p>Series是一种一维的数组型对象，它包含了一个值序列，并且包含了数据标签，称为索引（index）。</p>
</li>
<li><p>默认生成索引从0到N-1（N是数据的长度），通过values属性和index属性分别获得Series对象的值和索引。</p>
</li>
<li><p>通常会创建一个索引序列，用标签标识每个数据点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">obj2 = pd.Series([<span class="number">4</span>,<span class="number">7</span>,-<span class="number">5</span>,<span class="number">3</span>],index=[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">obj2</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">d    4</span></span><br><span class="line"><span class="string">b    7</span></span><br><span class="line"><span class="string">a   -5</span></span><br><span class="line"><span class="string">c    3</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj2.index <span class="comment"># Index([&#x27;d&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;], dtype=&#x27;object&#x27;)</span></span><br><span class="line"><span class="comment"># 使用标签进行索引</span></span><br><span class="line">obj2[<span class="string">&#x27;a&#x27;</span>] <span class="comment"># -5</span></span><br><span class="line">obj2[[<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]] <span class="comment"># 包含的不是数字而是字符串，作为索引列表</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">c    3</span></span><br><span class="line"><span class="string">a   -5</span></span><br><span class="line"><span class="string">d    4</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用类似NumPy的风格操作：比如使用布尔值数组进行过滤，与标量相乘，或是应用数学函数，这些操作将保存索引值连接。</p>
</li>
<li><p>Series是一个<strong>长度固定且有序的字典</strong>，在你可能会使用字典的上下文中，也可以使用Series。</p>
</li>
<li><p>使用字典可以生成Series：<code>pd.Series(字典对象)</code></p>
<ul>
<li><p>可以将字典排序后生成Series</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sdata = &#123;<span class="string">&#x27;Ohio&#x27;</span>: <span class="number">35000</span>, <span class="string">&#x27;Texas&#x27;</span>: <span class="number">71000</span>, <span class="string">&#x27;Oregon&#x27;</span>: <span class="number">16000</span>, <span class="string">&#x27;Utah&#x27;</span>:<span class="number">5000</span>&#125;</span><br><span class="line">states = [<span class="string">&#x27;California&#x27;</span>,<span class="string">&#x27;Ohio&#x27;</span>,<span class="string">&#x27;Oregon&#x27;</span>,<span class="string">&#x27;Texas&#x27;</span>]</span><br><span class="line">obj4= pd.Series(sdata,index=states)</span><br><span class="line">obj4</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">California        NaN  # not a number pandas标记缺失值</span></span><br><span class="line"><span class="string">Ohio          35000.0</span></span><br><span class="line"><span class="string">Oregon        16000.0</span></span><br><span class="line"><span class="string">Texas         71000.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>pandas中使用isnull和notnull函数来检查缺失数据，“缺失”或“NA”表示缺失数据</p>
<ul>
<li><code>pd.isnull(obj4)</code></li>
<li><code>pd.notnull(obj4)</code></li>
<li>isnull和notnull也是Series的实例方法：<code>obj4.isnull()</code></li>
</ul>
</li>
<li><p>Series可用来在数学操作中自动对齐</p>
</li>
<li><p>Series<strong>对象自身</strong>和其<strong>索引</strong>都有name属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj4.name = <span class="string">&#x27;population&#x27;</span></span><br><span class="line">obj4.index.name = <span class="string">&#x27;state&#x27;</span></span><br><span class="line">obj4</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">state</span></span><br><span class="line"><span class="string">California        NaN</span></span><br><span class="line"><span class="string">Ohio          35000.0</span></span><br><span class="line"><span class="string">Oregon        16000.0</span></span><br><span class="line"><span class="string">Texas         71000.0</span></span><br><span class="line"><span class="string">Name: population, dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>改变Series的索引：按位置赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: obj</span><br><span class="line">Out[<span class="number">41</span>]:</span><br><span class="line"><span class="number">0</span>     <span class="number">4</span></span><br><span class="line"><span class="number">1</span>     <span class="number">7</span></span><br><span class="line"><span class="number">2</span>    -<span class="number">5</span></span><br><span class="line"><span class="number">3</span>     <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line">In [<span class="number">42</span>]: obj.index = [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Jeff&#x27;</span>, <span class="string">&#x27;Ryan&#x27;</span>]</span><br><span class="line">In [<span class="number">43</span>]: obj</span><br><span class="line">Out[<span class="number">43</span>]:</span><br><span class="line">Bob       <span class="number">4</span></span><br><span class="line">Steve     <span class="number">7</span></span><br><span class="line">Jeff     -<span class="number">5</span></span><br><span class="line">Ryan      <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><blockquote>
<p>DataFrame是矩阵的数据表，它包含已排序的列集合，每一列可以是不同的值类型（数值、字符串、布尔值等）。</p>
<p>DataFrame既有行索引也有列索引，它可以被视为一个共享相同索引的Series的字典。</p>
<p>分层索引是pandas中一种更为高级的数据处理特性。</p>
</blockquote>
<p><strong>构建DataFrame</strong></p>
<ul>
<li><p>利用等长度列表或NumPy数组的字典来形成DataFrame</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = &#123;<span class="string">&#x27;state&#x27;</span>: [<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;year&#x27;</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2003</span>],</span><br><span class="line">        <span class="string">&#x27;pop&#x27;</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>,<span class="number">3.6</span>,<span class="number">2.4</span>,<span class="number">2.9</span>,<span class="number">3.2</span>]&#125;</span><br><span class="line">frame = pd.DataFrame(data)</span><br><span class="line">frame</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">state	year	pop</span></span><br><span class="line"><span class="string">0	Ohio	2000	1.5</span></span><br><span class="line"><span class="string">1	Ohio	2001	1.7</span></span><br><span class="line"><span class="string">2	Ohio	2002	3.6</span></span><br><span class="line"><span class="string">3	Nevada	2001	2.4</span></span><br><span class="line"><span class="string">4	Nevada	2002	2.9</span></span><br><span class="line"><span class="string">5	Nevada	2003	3.2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>一些常用操作</strong></p>
<ul>
<li><p>大型DataFrame，head方法会选出头部的五行</p>
</li>
<li><p>指定列顺序后，DataFrame的列将会按照指定顺序排列；列不包含在字典中时，结果会出现缺失值</p>
</li>
<li><p>DataFrame中的一列，可以按字典型标记或属性那样检索为Series：<code>frame2[&#39;state&#39;]</code>，<code>frame2.year</code></p>
<blockquote>
<p>frame2[colunm]对于任意列名均有效，但是frame2.column只在列名是有效的Python变量名时有效</p>
</blockquote>
<ul>
<li>返回的Series与原DataFrame有相同的索引，且Series的name属性也会被合理地设置。</li>
<li>通过位置或特殊属性loc进行选取：<code>frame2.loc[&#39;three&#39;]</code></li>
</ul>
</li>
<li><p>列的引用是可以修改的，例如，空的’debt’列可以赋值为标量值或值数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame2[<span class="string">&#x27;debt&#x27;</span>] = <span class="number">16.5</span></span><br><span class="line">frame2[<span class="string">&#x27;debt&#x27;</span>] = np.arange(<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>将列表或数组赋值给一个列时，值的长度必须和DataFrame的长度相匹配</p>
</li>
<li><p>将Series赋值给一列时，Series的索引将会按照DataFrame的索引重新排列，并在空缺的地方填充缺失值</p>
</li>
<li><p>如果被赋值的列并不存在，则会生成一个新的列</p>
</li>
<li><p>del关键字可以删除DataFrame列（像在字典中）</p>
</li>
<li><p>向DataFrame中增加一列</p>
<ul>
<li>&#96;&#96;&#96;python<h1 id="增加一列布尔值，判断条件是state是否为’ohio’"><a href="#增加一列布尔值，判断条件是state是否为’ohio’" class="headerlink" title="增加一列布尔值，判断条件是state是否为’ohio’"></a>增加一列布尔值，判断条件是state是否为’ohio’</h1>frame2[‘eastern’] &#x3D; frame2.state &#x3D;&#x3D; ‘Ohio’<h1 id="注意：-frame2-eastern的语法无法创建新的列"><a href="#注意：-frame2-eastern的语法无法创建新的列" class="headerlink" title="注意： frame2.eastern的语法无法创建新的列"></a>注意： frame2.eastern的语法无法创建新的列</h1><h1 id="del移除之前新建的列"><a href="#del移除之前新建的列" class="headerlink" title="del移除之前新建的列"></a>del移除之前新建的列</h1>del frame2[‘eastern’]<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &gt; 从DataFrame中选取的列是数据的视图，而不是拷贝</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 对Series的修改会映射到DataFrame中，需要复制显示使用Series的copy方法</span><br><span class="line"></span><br><span class="line">**包含字典的嵌套字典**</span><br><span class="line"></span><br><span class="line">- 将嵌套字典赋值给DataFrame，Pandas会将字典的键作为列，将内部字典的键作为行索引</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  pop = &#123;&#x27;Nevada&#x27;: &#123;2001: 2.4, 2002: 2.9&#125;, &#x27;Ohio&#x27;: &#123;2000: 1.5,2001:1.7,2002:3.6&#125;&#125;</span><br><span class="line">  frame3 = pd.DataFrame(pop)</span><br><span class="line">  frame3</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  	Nevada	Ohio</span><br><span class="line">  2001	2.4	1.7</span><br><span class="line">  2002	2.9	3.6</span><br><span class="line">  2000	NaN	1.5</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  # 使用类似NumPy语法进行转置操作</span><br><span class="line">  frame3.T</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  2001	2002	2000</span><br><span class="line">  Nevada	2.4	2.9	NaN</span><br><span class="line">  Ohio	1.7	3.6	1.5</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  # 显示指明索引，内部字典的键不会排序</span><br><span class="line">  pd.DataFrame(pop,index=[2001,2002,2003])</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  Nevada	Ohio</span><br><span class="line">  2001	2.4	1.7</span><br><span class="line">  2002	2.9	3.6</span><br><span class="line">  2003	NaN	NaN</span><br><span class="line">  &quot;&quot;&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>DataFrame构造函数的有效输入</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_69" alt="img" style="zoom: 50%;" />
</li>
<li><p>DataFrame的索引和列拥有name属性，则这些name属性也会被显示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame3.index.name=<span class="string">&#x27;year&#x27;</span></span><br><span class="line">frame3.columns.name = <span class="string">&#x27;state&#x27;</span></span><br><span class="line">frame3</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">state	Nevada	Ohio</span></span><br><span class="line"><span class="string">year		</span></span><br><span class="line"><span class="string">2001	2.4	1.7</span></span><br><span class="line"><span class="string">2002	2.9	3.6</span></span><br><span class="line"><span class="string">2000	NaN	1.5</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>DataFrame的values属性会将包含在DataFrame中的数据以<strong>二维ndarray</strong>的形式返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame3.values</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[2.4, 1.7],</span></span><br><span class="line"><span class="string">       [2.9, 3.6],</span></span><br><span class="line"><span class="string">       [nan, 1.5]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>DataFrame的列是不同的dtypes，则values的dtype会自动选择适合所有列的类型</p>
</blockquote>
</li>
</ul>
<h3 id="索引对象"><a href="#索引对象" class="headerlink" title="索引对象"></a>索引对象</h3><blockquote>
<p>用于存储轴标签和其他元数据的（例如轴名称或标签）</p>
<p>构造Series或DataFrame时，你所使用的任意数组或标签序列都可以转换为索引对象</p>
</blockquote>
<ul>
<li><p>索引对象不可修改，分享更为安全</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = pd.Series(<span class="built_in">range</span>(<span class="number">3</span>),index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">index = obj.index</span><br><span class="line">index <span class="comment"># Index([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], dtype=&#x27;object&#x27;)</span></span><br><span class="line">index[<span class="number">1</span>:] <span class="comment"># Index([&#x27;b&#x27;, &#x27;c&#x27;], dtype=&#x27;object&#x27;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>pandas索引对象是一个<strong>固定大小的集合</strong>，但是它可以<strong>包含重复标签</strong></p>
</li>
<li><p>一些索引对象的方法和属性</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_71" alt="img" style="zoom:50%;" /></li>
</ul>
<h2 id="5-2-基本功能"><a href="#5-2-基本功能" class="headerlink" title="5.2 基本功能"></a>5.2 基本功能</h2><h3 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h3><ul>
<li><p>reindex是pandas对象的重要方法，用于创建一个符合新索引的新对象，并进行排列，如果某个索引值之前并不存在，则会引入缺失值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">obj = pd.Series([<span class="number">4.5</span>,<span class="number">7.2</span>,-<span class="number">5.3</span>,<span class="number">3.6</span>],index=[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">obj</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">d    4.5</span></span><br><span class="line"><span class="string">b    7.2</span></span><br><span class="line"><span class="string">a   -5.3</span></span><br><span class="line"><span class="string">c    3.6</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj2 = obj.reindex([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">obj2</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a   -5.3</span></span><br><span class="line"><span class="string">b    7.2</span></span><br><span class="line"><span class="string">c    3.6</span></span><br><span class="line"><span class="string">d    4.5</span></span><br><span class="line"><span class="string">e    NaN #如果某个索引值之前并不存在，则会引入缺失值</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重建顺序数据（时间序列等）索引时可能需要进行插值或填值</p>
<ul>
<li><p>method可选参数可使用ffill等方法在重建索引时插值，向前填充</p>
</li>
<li><p>&#96;&#96;&#96;python<br>obj3 &#x3D; pd.Series([‘blue’,’purple’,’yellow’],index&#x3D;[0,2,4])<br>obj3<br>“””<br>0      blue<br>2    purple<br>4    yellow<br>dtype: object<br>“””<br>obj3.reindex(range(6),method&#x3D;’ffill’)<br>“””<br>0      blue<br>1      blue<br>2    purple<br>3    purple<br>4    yellow<br>5    yellow<br>dtype: object<br>“””</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**DataFrame中的reindex**</span><br><span class="line"></span><br><span class="line">- reindex可以改变行索引、列索引或同时改变二者。当仅传入一个序列时，结果中的行会重建索引</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  frame = pd.DataFrame(np.arange(9).reshape((3,3)),</span><br><span class="line">                      index=[&#x27;a&#x27;,&#x27;c&#x27;,&#x27;d&#x27;],</span><br><span class="line">                      columns=[&#x27;Ohio&#x27;,&#x27;Texas&#x27;,&#x27;California&#x27;])</span><br><span class="line">  frame</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  Ohio	Texas	California</span><br><span class="line">  a	0	1	2</span><br><span class="line">  c	3	4	5</span><br><span class="line">  d	6	7	8</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  frame2 = frame.reindex([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;])</span><br><span class="line">  frame2</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  Ohio	Texas	California</span><br><span class="line">  a	0.0	1.0	2.0</span><br><span class="line">  b	NaN	NaN	NaN</span><br><span class="line">  c	3.0	4.0	5.0</span><br><span class="line">  d	6.0	7.0	8.0</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  # 列可以使用columns关键字重建索引</span><br><span class="line">  states = [&#x27;Texas&#x27;,&#x27;Utah&#x27;,&#x27;Califormia&#x27;]</span><br><span class="line">  frame.reindex(columns=states)</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  	Texas	Utah	Califormia</span><br><span class="line">  a	1	NaN	NaN</span><br><span class="line">  c	4	NaN	NaN</span><br><span class="line">  d	7	NaN	NaN</span><br><span class="line">  &quot;&quot;&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>reindex的<strong>index</strong>参数：新建作为索引的序列，可以是索引实例或任意其他序列型Python数据结构，索引使用时无须复制</p>
</li>
</ul>
<h3 id="轴向上删除条目"><a href="#轴向上删除条目" class="headerlink" title="轴向上删除条目"></a>轴向上删除条目</h3><ul>
<li><p>drop方法会返回一个含有指示值或轴向上删除值的新对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = pd.Series(np.arange(<span class="number">5.</span>),index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">obj</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    0.0</span></span><br><span class="line"><span class="string">b    1.0</span></span><br><span class="line"><span class="string">c    2.0</span></span><br><span class="line"><span class="string">d    3.0</span></span><br><span class="line"><span class="string">e    4.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj.drop([<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    0.0</span></span><br><span class="line"><span class="string">b    1.0</span></span><br><span class="line"><span class="string">e    4.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>DataFrame中的drop</strong></p>
<ul>
<li><p>调用drop时默认删除行标签（轴0）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),</span><br><span class="line">                    index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>],</span><br><span class="line">                    columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line">data</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	one	two	three	four</span></span><br><span class="line"><span class="string">Ohio	0	1	2	3</span></span><br><span class="line"><span class="string">Colorado	4	5	6	7</span></span><br><span class="line"><span class="string">Utah	8	9	10	11</span></span><br><span class="line"><span class="string">New York	12	13	14	15</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">data.drop([<span class="string">&#x27;Colorado&#x27;</span>,<span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">one	two	three	four</span></span><br><span class="line"><span class="string">Utah	8	9	10	11</span></span><br><span class="line"><span class="string">New York	12	13	14	15</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 传递axis=1或axis=&#x27;columns’来从列中删除值</span></span><br><span class="line">data.drop(<span class="string">&#x27;two&#x27;</span>,axis=<span class="number">1</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">one	three	four</span></span><br><span class="line"><span class="string">Ohio	0	2	3</span></span><br><span class="line"><span class="string">Colorado	4	6	7</span></span><br><span class="line"><span class="string">Utah	8	10	11</span></span><br><span class="line"><span class="string">New York	12	14	15</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>drop，会修改Series或DataFrame的尺寸或形状；直接操作原对象而不是返回新对象</p>
</li>
<li><p>【注意】inplace属性：会清除被删除的数据：<code>obj.drop(‘c’,inplace=True)</code></p>
</li>
</ul>
<h3 id="索引、选择与过滤"><a href="#索引、选择与过滤" class="headerlink" title="索引、选择与过滤"></a>索引、选择与过滤</h3><ul>
<li><p>Series的索引与NumPy数组类似，但是不仅可以索引整数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = pd.Series(np.arange(<span class="number">4.</span>),index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">obj</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    0.0</span></span><br><span class="line"><span class="string">b    1.0</span></span><br><span class="line"><span class="string">c    2.0</span></span><br><span class="line"><span class="string">d    3.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj[<span class="string">&#x27;b&#x27;</span>] <span class="comment"># 1.0</span></span><br><span class="line">obj[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">c    2.0</span></span><br><span class="line"><span class="string">d    3.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj[[<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b    1.0</span></span><br><span class="line"><span class="string">a    0.0</span></span><br><span class="line"><span class="string">d    3.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj[[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b    1.0</span></span><br><span class="line"><span class="string">d    3.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj[obj&lt;<span class="number">2</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    0.0</span></span><br><span class="line"><span class="string">b    1.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Series切片（不同于Python切片）</p>
<ul>
<li>使用切片修改值会修改Series的相应部分：<code>obj[‘b’ : ‘c’]</code></li>
<li>使用单个值或序列，可以从DataFrame中索引出一个或多个列</li>
<li>可根据布尔值数组切片选择数据<ul>
<li><code>data[:2]</code> # 选前两行</li>
<li><code>data[data[‘three’]&gt;5]</code></li>
</ul>
</li>
</ul>
</li>
<li><p>使用布尔值DataFrame进行索引，可以和标量比较产生</p>
<ul>
<li><code>data &lt; 5</code> (data是DataFrame类型)</li>
<li><code>data[data&lt;5] = 0</code> （小于5的数赋值为0）</li>
</ul>
</li>
</ul>
<p><strong>使用loc和iloc选择数据</strong></p>
<blockquote>
<p>DataFrame允许你使用轴标签（loc）或整数标签（iloc）以NumPy风格的语法从DataFrame中选出数组的行和列的子集</p>
</blockquote>
<ul>
<li><p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.loc[<span class="string">&#x27;Colorado&#x27;</span>,[<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>]]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">two      5</span></span><br><span class="line"><span class="string">three    6</span></span><br><span class="line"><span class="string">Name: Colorado, dtype: int32</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 整数标签iloc进行类似的数据选择</span></span><br><span class="line">data.iloc[<span class="number">2</span>,[<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">four    11</span></span><br><span class="line"><span class="string">one      8</span></span><br><span class="line"><span class="string">two      9</span></span><br><span class="line"><span class="string">Name: Utah, dtype: int32</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>所以用于切片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.loc[:<span class="string">&#x27;Utah&#x27;</span>,<span class="string">&#x27;two&#x27;</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Ohio        1</span></span><br><span class="line"><span class="string">Colorado    5</span></span><br><span class="line"><span class="string">Utah        9</span></span><br><span class="line"><span class="string">Name: two, dtype: int32</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">data.iloc[:,:<span class="number">3</span>][data.three &gt;<span class="number">5</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">one	two	three</span></span><br><span class="line"><span class="string">Colorado	4	5	6</span></span><br><span class="line"><span class="string">Utah	8	9	10</span></span><br><span class="line"><span class="string">New York	12	13	14</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>DataFrame索引选项</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_74" alt="epub_22739904_74" style="zoom:50%;" /></li>
</ul>
<h3 id="整数索引"><a href="#整数索引" class="headerlink" title="整数索引"></a>整数索引</h3><ul>
<li><p>在pandas对象上使用整数索引会产生歧义，非整数索引不会有潜在的歧义</p>
</li>
<li><p>使用<strong>loc</strong>（用于标签）或<strong>iloc</strong>（用于整数）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ser = pd.Series(np.arange(<span class="number">3.</span>))</span><br><span class="line">ser</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0    0.0</span></span><br><span class="line"><span class="string">1    1.0</span></span><br><span class="line"><span class="string">2    2.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">ser[:<span class="number">1</span>] </span><br><span class="line"><span class="comment"># 0    0.0</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br><span class="line">ser.loc[:<span class="number">1</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0    0.0</span></span><br><span class="line"><span class="string">1    1.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">ser.iloc[:<span class="number">1</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0    0.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="算术和数据对齐"><a href="#算术和数据对齐" class="headerlink" title="算术和数据对齐"></a>算术和数据对齐</h3><ul>
<li><p>对象相加时，索引对不相同，返回结果的索引将是索引对的<strong>并集</strong>，类似于数据库的<strong>自动外连接（Outer join）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = pd.Series([<span class="number">7.3</span>,-<span class="number">2.5</span>,<span class="number">3.4</span>,<span class="number">1.5</span>],index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">s2 = pd.Series([-<span class="number">2.1</span>,<span class="number">3.6</span>,-<span class="number">1.5</span>,<span class="number">4</span>,<span class="number">3.1</span>],index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>])</span><br><span class="line">s1 +s2</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    5.2</span></span><br><span class="line"><span class="string">c    1.1</span></span><br><span class="line"><span class="string">d    NaN</span></span><br><span class="line"><span class="string">e    0.0</span></span><br><span class="line"><span class="string">f    NaN</span></span><br><span class="line"><span class="string">g    NaN</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将DataFrame对象加在一起，返回一个DataFrame，它的索引、列是每个DataFrame的索引、列的并集。</p>
<ul>
<li>两个行或列完全不同的DataFrame对象相加，结果将全部为空</li>
</ul>
</li>
</ul>
<p><strong>使用填充值的算术方法</strong></p>
<ul>
<li><p>两个DataFrame对象相加时，一些不重叠的位置会出现NA值，举例：填充0：<code>df1.add(df2,fill_value=0)</code></p>
</li>
<li><p>灵活算术方法</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_75" alt="epub_22739904_75" style="zoom:50%;" />

<p>以r开头的副本方法的参数是翻转的，1&#x2F;df1和df1.rdiv(1)等价</p>
</li>
</ul>
<p><strong>DataFrame和Series间的操作</strong></p>
<blockquote>
<p>和NumPy中不同维度数组间的操作类似</p>
</blockquote>
<ul>
<li><p>考虑二维数组和其中一行的区别，<strong>广播机制</strong>：减法在每一行都进行了操作（<strong>对列进行匹配，并广播到各行</strong>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">arr[<span class="number">0</span>] <span class="comment"># array([0., 1., 2., 3.])</span></span><br><span class="line">arr - arr[<span class="number">0</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">       [4., 4., 4., 4.],</span></span><br><span class="line"><span class="string">       [8., 8., 8., 8.]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在列上进行广播，在行上匹配，必须使用算术方法的一种：<code>frame.sub(series3,axis=‘index’)</code>，使用axis&#x3D;‘index’或axis&#x3D;0</p>
</li>
</ul>
<h3 id="函数应用和映射"><a href="#函数应用和映射" class="headerlink" title="函数应用和映射"></a>函数应用和映射</h3><ul>
<li><p>NumPy的通用函数（逐元素数组方法）对pandas对象也有效：<code>np.abs(frame)</code></p>
</li>
<li><p>DataFrame的apply方法将函数应用到<strong>一行或一列（默认）</strong>的一维数组上</p>
<ul>
<li><p>举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = pd.DataFrame(np.random.randn(<span class="number">4</span>,<span class="number">3</span>),columns=<span class="built_in">list</span>(<span class="string">&#x27;bde&#x27;</span>),</span><br><span class="line">                    index=[<span class="string">&#x27;Utah&#x27;</span>,<span class="string">&#x27;Ohio&#x27;</span>,<span class="string">&#x27;Texas&#x27;</span>,<span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"><span class="comment"># 函数f，可以计算Series最大值和最小值的差，会被frame中的每一列调用一次</span></span><br><span class="line"><span class="comment"># 结果是一个以frame的列作为索引的Series</span></span><br><span class="line">f =  <span class="keyword">lambda</span> x:x.<span class="built_in">max</span>() - x.<span class="built_in">min</span>()</span><br><span class="line">frame.apply(f)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b    3.071398</span></span><br><span class="line"><span class="string">d    2.095664</span></span><br><span class="line"><span class="string">e    2.016091</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 函数每行被调用一次</span></span><br><span class="line">frame.apply(f,axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Utah      2.410035</span></span><br><span class="line"><span class="string">Ohio      0.303477</span></span><br><span class="line"><span class="string">Texas     0.808933</span></span><br><span class="line"><span class="string">Oregon    1.718999</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>大部分最常用的数组统计（sum和mean）都是DataFrame的方法，<strong>apply不是必需的</strong></p>
</li>
<li><p>传递给apply的不一定要返回一个标量值，也可以返回带有多个值的Series</p>
</li>
</ul>
</li>
<li><p>可以使用逐元素的Python函数，举例：根据frame总的每个浮点数计算一个格式化字符串，可以使用<strong>applymap</strong>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">format</span> = <span class="keyword">lambda</span> x: <span class="string">&#x27;%.2f&#x27;</span> % x</span><br><span class="line">frame.applymap(<span class="built_in">format</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b	d	e</span></span><br><span class="line"><span class="string">Utah	-0.86	1.53	0.19</span></span><br><span class="line"><span class="string">Ohio	0.25	0.46	-1.16</span></span><br><span class="line"><span class="string">Texas	-0.59	-0.60	-1.08</span></span><br><span class="line"><span class="string">Oregon	-1.09	0.36	-0.19</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>用applymap作为函数名是因为Series有map方法</p>
<p>将逐元素应用到Series上：frame[‘e’].map(format)</p>
</blockquote>
</li>
</ul>
<h3 id="排序和排名"><a href="#排序和排名" class="headerlink" title="排序和排名"></a>排序和排名</h3><p><strong>排序</strong></p>
<ul>
<li>按行或列索引进行字典型排序，使用<strong>sort_index</strong>方法，返回一个新的、排序好的对象<ul>
<li>默认升序，也可以降序排序：ascending&#x3D;False</li>
<li>对DataFrame进行排序时，使用一列或多列作为排序键，通过给<strong>sort_values的可选参数by</strong>实现<ul>
<li><code>frame.sort_values(by=‘b’)</code></li>
<li><code>frame.sort_values(by = [‘a’,’b])</code></li>
</ul>
</li>
</ul>
</li>
<li>使用<strong>sort_values</strong>方法根据Series的值进行排序<ul>
<li>默认所有的缺失值都会被排序至Series的尾部</li>
</ul>
</li>
</ul>
<p><strong>排名</strong></p>
<blockquote>
<p>排名是指对数组从1到有效数据点总数分配名次的操作</p>
</blockquote>
<ul>
<li><p>Series和DataFrame的<strong>rank方法</strong>是实现排名的方法。</p>
<ul>
<li><p>默认通过平均排名分配到每个组来打破平级关系。</p>
</li>
<li><p>也可以根据他们在数据中的观察顺序进行分配</p>
<ul>
<li>对条目0和2设置的名次为6和7，而不是之前的平均排名6.5，是因为在数据中标签0在标签2的前面。</li>
</ul>
</li>
<li><p>按降序排名：<code>obj.rank(ascending=False,method=‘max’)</code></p>
</li>
<li><p>排名中的平级关系打破方法</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_76" alt="img" style="zoom:50%;" />
</li>
<li><p>DataFrame可以对行或列计算排名：frame.rank(axis &#x3D; ‘columns’)</p>
</li>
</ul>
</li>
</ul>
<h3 id="含有重复标签的轴索引"><a href="#含有重复标签的轴索引" class="headerlink" title="含有重复标签的轴索引"></a>含有重复标签的轴索引</h3><ul>
<li><p>轴索引并不是强制唯一性，但pandas函数（比如reindex）需要的标签是唯一的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = pd.Series(<span class="built_in">range</span>(<span class="number">5</span>),index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">obj</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    0</span></span><br><span class="line"><span class="string">a    1</span></span><br><span class="line"><span class="string">b    2</span></span><br><span class="line"><span class="string">b    3</span></span><br><span class="line"><span class="string">c    4</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>索引的is_unique属性：标签是否唯一</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj.index.is_unique <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有重复索引时，标签索引多个条目会返回一个<strong>序列</strong>，单个条目会返回<strong>标量值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    0</span></span><br><span class="line"><span class="string">a    1</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj[<span class="string">&#x27;c&#x27;</span>] <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重复索引会使代码更复杂，因为来自索引的输出类型可能因标签是否重复而有所不同</p>
</li>
</ul>
</li>
</ul>
<h2 id="5-3-描述性统计的概述与计算"><a href="#5-3-描述性统计的概述与计算" class="headerlink" title="5.3 描述性统计的概述与计算"></a>5.3 描述性统计的概述与计算</h2><ul>
<li><p>Pandas对象封装了常用数学、统计学方法的集合，大部分属于<strong>规约或汇总统计</strong>的类别。</p>
<ul>
<li><p>从DataFrame的行或列中抽取一个Series或一系列值的单个值（如总和或平均值）</p>
</li>
<li><p>内建了处理缺失值的功能</p>
</li>
<li><p>传入axis&#x3D;’columns’或axis&#x3D;1，则会将<strong>一行上各个列</strong>的值相加：<code>df.sum(axis=‘columns’)</code></p>
</li>
<li><p>NA值会被自动排除（除非全都是），可以通过禁用skipna来实现不排除NA值</p>
</li>
<li><p>规约方法可选参数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_77" alt="img" style="zoom:50%;" />
</li>
<li><p>有一些方法返回间接统计信息：比如最小值或最大值的索引值：比如idxmin和idxmax</p>
</li>
</ul>
</li>
<li><p>积累型方法：<code>df.cumsum()</code></p>
</li>
<li><p>describe方法：<strong>一次产生多个汇总统计</strong>，既不是规约方法也不是积累型方法。</p>
<ul>
<li>describe方法也可以描述非数值型数据</li>
</ul>
</li>
<li><p>描述性统计和汇总统计方法</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_78" alt="img" style="zoom:50%;" /></li>
</ul>
<h3 id="相关性和协方差"><a href="#相关性和协方差" class="headerlink" title="相关性和协方差"></a>相关性和协方差</h3><ul>
<li>Series的corr方法计算的是两个Series中重叠的、非NA的、按索引对齐的值的相关性。相应地，cov计算的是协方差。<ul>
<li><code>returns[‘MSFT’].corr(returns[‘IBM’])</code></li>
<li><code>returns.MSFT.corr(returns.IBM)</code>，MSFT是一个有效的Python属性</li>
<li>以DataFrame的形式返回相关性和协方差矩阵</li>
</ul>
</li>
<li>DataFrame的<strong>corrwith方法</strong>：DataFrame中的行或列与另一个序列或DataFrame的相关性<ul>
<li>传入一个Series时，会返回一个含有为每列计算相关性值的Series</li>
<li>传入一个DataFrame时，会计算匹配到列名的相关性数值</li>
<li>传入axis&#x3D;’columns’会逐行地进行计算</li>
</ul>
</li>
</ul>
<h3 id="唯一值、计数和成员属性"><a href="#唯一值、计数和成员属性" class="headerlink" title="唯一值、计数和成员属性"></a>唯一值、计数和成员属性</h3><blockquote>
<p>另一类相关的方法可以从一维Series包含的数值中提取信息</p>
</blockquote>
<ul>
<li><p>unique：给出Series中的唯一值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">obj = pd.Series([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">uniques = obj.unique()</span><br><span class="line">uniques <span class="comment"># array([&#x27;c&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;b&#x27;], dtype=object)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>排序：<code>uniques.sort()</code></li>
</ul>
</li>
<li><p>计算Series包含值的个数：<code>value_counts()</code></p>
<ul>
<li>按照数量降序排序：<code>pd.value_counts(obj.values,sort=False)</code></li>
</ul>
</li>
<li><p>isin执行向量化的成员属性检查，将数据集以Series或DataFrame一列的形式过滤为数据集的值子集。</p>
<ul>
<li><p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0    c</span></span><br><span class="line"><span class="string">1    a</span></span><br><span class="line"><span class="string">2    d</span></span><br><span class="line"><span class="string">3    a</span></span><br><span class="line"><span class="string">4    a</span></span><br><span class="line"><span class="string">5    b</span></span><br><span class="line"><span class="string">6    b</span></span><br><span class="line"><span class="string">7    c</span></span><br><span class="line"><span class="string">8    c</span></span><br><span class="line"><span class="string">dtype: object</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">mask = obj.isin([<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">mask</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0     True</span></span><br><span class="line"><span class="string">1    False</span></span><br><span class="line"><span class="string">2    False</span></span><br><span class="line"><span class="string">3    False</span></span><br><span class="line"><span class="string">4    False</span></span><br><span class="line"><span class="string">5     True</span></span><br><span class="line"><span class="string">6     True</span></span><br><span class="line"><span class="string">7     True</span></span><br><span class="line"><span class="string">8     True</span></span><br><span class="line"><span class="string">dtype: bool</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj[mask]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0    c</span></span><br><span class="line"><span class="string">5    b</span></span><br><span class="line"><span class="string">6    b</span></span><br><span class="line"><span class="string">7    c</span></span><br><span class="line"><span class="string">8    c</span></span><br><span class="line"><span class="string">dtype: object</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>isin相关的Index.get_indexer方法：提供一个索引数组可以将可能非唯一值数组转换为另一个唯一值数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">to_match = pd.Series([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">unique_vals = pd.Series([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">pd.Index(unique_vals).get_indexer(to_match)</span><br><span class="line"><span class="comment"># array([0, 2, 1, 1, 0, 2], dtype=int64)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>唯一值、计数和集合成员属性方法</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_80" alt="img" style="zoom:50%;" />
</li>
<li><p>计算DataFrame多个相关列的直方图</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="无标题" style="zoom:50%;" />

<p>这里，结果中的行标签是所有列中出现的不同值，数值则是这些不同值在每个列中出现的次数。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习： 数据分析</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>九、绘图与可视化——《利用Python进行数据分析》</title>
    <url>/2022/04/04/%E4%B9%9D%E3%80%81%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/</url>
    <content><![CDATA[<h1 id="第九章-绘图与可视化"><a href="#第九章-绘图与可视化" class="headerlink" title="第九章 绘图与可视化"></a>第九章 绘图与可视化</h1><blockquote>
<p>关注matplotlib和以它为基础的库</p>
<p>seaborn底层绘图</p>
</blockquote>
<p>在Jupyter notebook中使用交互式绘图，执行以下语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib notebook</span><br></pre></td></tr></table></figure>

<h2 id="9-1-简明matplotlib-API入门"><a href="#9-1-简明matplotlib-API入门" class="headerlink" title="9.1 简明matplotlib API入门"></a>9.1 简明matplotlib API入门</h2><ul>
<li><p>导入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
</li>
<li><p>matplotlib的<strong>可视化作品库</strong>和<strong>文档</strong>是学习高级功能的最佳资源</p>
</li>
</ul>
<h3 id="图片与子图"><a href="#图片与子图" class="headerlink" title="图片与子图"></a>图片与子图</h3><ul>
<li><p>绘制的图位于图片（Figure）对象中，plt.figure生成一个新的图片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br></pre></td></tr></table></figure>
</li>
<li><p>add_subplot创建一个或多个子图（subplot），返回Axes Subplot对象；可以使用这些对象进行画图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 图片摆放是2*2的，这是选择四个图形中的第一个</span></span><br><span class="line">ax1 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 使用对象画图</span></span><br><span class="line">_ = ax1.hist(np.random.randn(<span class="number">100</span>), bins=<span class="number">20</span>, color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.3</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><blockquote>
<p>复杂的图表操作放在单个的notebook单元格中，因为每个单元格运行后，图表被重置</p>
</blockquote>
</li>
<li><p>使用子网格图创建图片：plt.subplots</p>
<ul>
<li><p>返回包含子图对象的NumPy数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">axes</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[&lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;],</span></span><br><span class="line"><span class="string">       [&lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;]], dtype=object)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组axes可以像二维数组一样方便地进行索引，axes[0,1]</p>
</li>
<li><p>pyplot.subplots选项</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_114" alt="epub_22739904_114" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<p><strong>调整子图周围的间距</strong></p>
<ul>
<li><p>使用图对象上的<strong>subplots_adjust</strong>方法更改间距，也可以用作顶层函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wspace控制图片宽度比</span></span><br><span class="line"><span class="comment"># hspace控制图片高度比</span></span><br><span class="line">subplots_adjust(left=<span class="literal">None</span>, bottom=<span class="literal">None</span>, right=<span class="literal">None</span>,top=<span class="literal">None</span>, wspace=<span class="literal">None</span>, hspace=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>颜色、标记和线类型</strong></p>
<ul>
<li><p>matplotlib的主函数plot接收带有x和y轴的数组以及一些可选的字符串缩写参数来指明颜色和线类型，也可用<strong>十六进制颜色代码</strong>来指定颜色</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用绿色破折号绘制x对y的线</span></span><br><span class="line">ax.plot(x, y, linestyle=<span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"><span class="comment"># 简化版</span></span><br><span class="line">ax.plot(x, y, <span class="string">&#x27;g--&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>折线图用标记凸显实际数据点</p>
<ul>
<li><p>标记可以是样式字符串的一部分</p>
</li>
<li><p>线类型、标记类型必须跟在颜色后面</p>
</li>
<li><p>折线图举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</span><br><span class="line">plt.plot(randn(<span class="number">30</span>).cumsum(), <span class="string">&#x27;ko--&#x27;</span>)</span><br><span class="line"><span class="comment"># 分开写</span></span><br><span class="line"><span class="comment"># plot(randn(30).cumsum(), color=&#x27;k&#x27;,linestyle=&#x27;dashed&#x27;, marker=&#x27;o&#x27;)</span></span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/output.png" alt="output" style="zoom:50%;" />
</li>
<li><p>使用drawstyle改变内插新式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(data, <span class="string">&#x27;k-&#x27;</span>, drawstyle=<span class="string">&#x27;steps-post&#x27;</span>,label=<span class="string">&#x27;steps-post&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_117" alt="img" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>使用<strong>plt.legend</strong>为每条线生成一个用于区分的图例</p>
<blockquote>
<p>无论你在用数据绘图时是否传递了lebel选项，你都必须调用plt.legend （如果你有轴的引用，也可以用ax.legend）来生成图例</p>
</blockquote>
</li>
</ul>
<h3 id="刻度、标签和图例"><a href="#刻度、标签和图例" class="headerlink" title="刻度、标签和图例"></a>刻度、标签和图例</h3><ul>
<li><p>两种修饰图表的方式</p>
<ul>
<li><p>程序性的matplotlib.pyplot接口</p>
<ul>
<li><p>包含了像xlim（绘图范围）、xticks（刻度位置）和xticklabels（刻度标签）等</p>
</li>
<li><p>使用方法</p>
<ul>
<li><strong>没有函数参数</strong>调用：返回当前的参数值（例如plt.xlim()返回当前的x轴绘图范围）</li>
<li><strong>传入函数参数</strong>调用，并<strong>设置参数值</strong>：（例如plt.xlim（[0, 10]）会将x轴的范围设置为0到10）</li>
</ul>
<blockquote>
<p>会在最近的AxesSubplot上生效</p>
<p>xlim对应子图自身两个方法：ax.get_lim和ax.set_lim</p>
<p>可以更显式地使用subplot子图方法</p>
</blockquote>
</li>
</ul>
</li>
<li><p>面向对象的原生matplotlib API</p>
</li>
</ul>
</li>
</ul>
<p><strong>设置标题、轴标签、刻度和刻度标签</strong></p>
<ul>
<li><p>改变轴刻度</p>
<ul>
<li><p>set_xticks：在数据范围内设定刻度的位置，默认刻度有标签</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ticks = ax.set_xticks([<span class="number">0</span>, <span class="number">250</span>, <span class="number">500</span>, <span class="number">750</span>, <span class="number">1000</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>set_xticklabels：为标签赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">labels = ax.set_xticklabels([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>],rotation=<span class="number">30</span>, fontsize=<span class="string">&#x27;small&#x27;</span>)</span><br><span class="line"><span class="comment"># rotation将x轴的刻度标签旋转30度</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>设置轴名称：<code>set_xlabel()</code></p>
</li>
<li><p>设置子图标题：<code>set_title()</code></p>
</li>
<li><p>批量设置绘图属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">props = &#123;</span><br><span class="line">    <span class="string">&#x27;title&#x27;</span>:<span class="string">&#x27;my first matplotlib plot&#x27;</span></span><br><span class="line">    <span class="string">&#x27;xlabel&#x27;</span>:<span class="string">&#x27;Stages&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">ax.<span class="built_in">set</span>(**props)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>添加图例</strong></p>
<ul>
<li><p>添加每个图表时传递label参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</span><br><span class="line">fig = plt.figure(); ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k&#x27;</span>, label=<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k--&#x27;</span>, label=<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k.&#x27;</span>, label=<span class="string">&#x27;three&#x27;</span>)</span><br><span class="line"><span class="comment"># 调用ax.legend()或plt.legend自动生成图例</span></span><br><span class="line"><span class="comment"># loc参数告诉matplotlib在哪里放置图表</span></span><br><span class="line">ax.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/le.png" alt="le" style="zoom:50%;" />
</li>
<li><p>取消图例：不要传入label参数或者传入<code>label=&#39;_nolegend_&#39;</code></p>
</li>
</ul>
<h3 id="注释与子图加工"><a href="#注释与子图加工" class="headerlink" title="注释与子图加工"></a>注释与子图加工</h3><ul>
<li><p>使用text、arrow和annote方法来添加注释和文本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在给定坐标(x,y)上绘制文本</span></span><br><span class="line">ax.text(x, y, <span class="string">&#x27;Hello world!&#x27;</span>,family=<span class="string">&#x27;monospace&#x27;</span>, fontsize=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>ax.annotate方法可以在指定的x和y坐标上绘制标签</p>
</li>
<li><p>matplotlib的<strong>图形全集位于matplotlib.patches</strong>，但是一些常见图形可在matplotlib.pyplot中找到。</p>
</li>
<li><p>在图表中添加图形</p>
<ul>
<li><p>生成patch（补丁）对象shp</p>
</li>
<li><p>调用<code>ax.add_patch （shp）</code>将它加入到子图中</p>
</li>
<li><p>示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>)); ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">rect = plt.Rectangle((<span class="number">0.2</span>, <span class="number">0.75</span>), <span class="number">0.4</span>, <span class="number">0.15</span>, color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">circ = plt.Circle((<span class="number">0.7</span>, <span class="number">0.2</span>), <span class="number">0.15</span>, color=<span class="string">&#x27;b&#x27;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">pgon = plt.Polygon([[<span class="number">0.15</span>, <span class="number">0.15</span>], [<span class="number">0.35</span>, <span class="number">0.4</span>], [<span class="number">0.2</span>, <span class="number">0.6</span>]],</span><br><span class="line">                   color=<span class="string">&#x27;g&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">ax.add_patch(rect)</span><br><span class="line">ax.add_patch(circ)</span><br><span class="line">ax.add_patch(pgon)</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果展示</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/tutu.png" alt="tutu" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<h3 id="将图片保存到文件"><a href="#将图片保存到文件" class="headerlink" title="将图片保存到文件"></a>将图片保存到文件</h3><ul>
<li><p>使用plt.savefig将图片保存到文件，文件类型根据扩展名推断</p>
<ul>
<li><p>.pdf：PDF文件</p>
</li>
<li><p>.dpi：控制每英寸点数的分辨率</p>
</li>
<li><p>bbox_inches：修剪实际图形的空白</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PNG图片，拥有最小的空白</span></span><br><span class="line">plt.savefig(<span class="string">&#x27;figpath.png&#x27;</span>, dpi=<span class="number">400</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>figure.savefig选项</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_124" alt="img" style="zoom: 50%;" /></li>
</ul>
</li>
<li><p>savefig可以写到所有文件对象中，如BytesIO()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">buffer = BytesIO()</span><br><span class="line">plt.savefig(buffer)</span><br><span class="line">plot_data = buffer.getvalue()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="matplotlib设置"><a href="#matplotlib设置" class="headerlink" title="matplotlib设置"></a>matplotlib设置</h3><blockquote>
<p>matplotlib中的配色方案和默认设置可以通过广泛的全局参数来定制</p>
</blockquote>
<ul>
<li><p>使用<strong>rc方法</strong>修改Python编程配置</p>
<ul>
<li><p>第一个参数为想要自定义的组件，比如’figure’、’axes’、’xtick’、’ytick’、’grid’、’legend’等等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rc(<span class="string">&#x27;figure&#x27;</span>, figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用字典按照关键字参数的序列指定新参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">font_options = &#123;<span class="string">&#x27;family&#x27;</span> : <span class="string">&#x27;monospace&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;weight&#x27;</span> : <span class="string">&#x27;bold&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;size&#x27;</span>   : <span class="string">&#x27;small&#x27;</span>&#125;</span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>, **font_options)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>更深入的定制和参看全量选项</p>
<ul>
<li>参考matplotlib的设置文件matplotlibrc，该文件位于matplotlib&#x2F;mpl-data路径</li>
<li>定制文件后放在home路径下并且将文件命名为．matplotlibrc，则每次你使用matplotlib时都会读取该文件。</li>
</ul>
</li>
</ul>
<h2 id="9-2-使用pandas和seaborn绘图"><a href="#9-2-使用pandas和seaborn绘图" class="headerlink" title="9.2 使用pandas和seaborn绘图"></a>9.2 使用pandas和seaborn绘图</h2><blockquote>
<p>seaborn简化了常用可视化类型，会修改默认的matplotlib配色方案和绘图样式，提高可读性和美观性</p>
</blockquote>
<h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><ul>
<li><p>Series和DataFrame都有一个<strong>plot属性</strong>，用于绘制基本图形，默认是折线图</p>
<ul>
<li>Series的索引会作为x轴，可以传入<code>use_index=False</code>来禁用这个功能</li>
<li>DataFrame的plot方法在同一个子图中将<strong>每一列</strong>绘制为不同的折线，并自动生成图例</li>
<li>plot属性包含了不同绘图类型的方法族。例如，<code>df.plot()</code>等价于<code>df.plot.line()</code></li>
</ul>
</li>
<li><p>Series.plot方法参数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_129" alt="img" style="zoom:50%;" />
</li>
<li><p>DataFrame的plot参数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_130" alt="img" style="zoom:50%;" /></li>
</ul>
<h3 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h3><ul>
<li><p>plot.bar():垂直柱状图；plot.barh()：水平柱状图</p>
<ul>
<li><p>Series或DataFrame的索引将会被用作x轴刻度（bar）或y轴刻度（barh）</p>
</li>
<li><p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">data = pd.Series(np.random.rand(<span class="number">16</span>), index=<span class="built_in">list</span>(<span class="string">&#x27;abcdefghijklmnop&#x27;</span>))</span><br><span class="line">data.plot.bar(ax=axes[<span class="number">0</span>], color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line">data.plot.barh(ax=axes[<span class="number">1</span>], color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.7</span>)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/bar.png" alt="bar" style="zoom: 67%;" /></li>
</ul>
</li>
<li><p>在DataFrame中，柱状图将每一行中的值分组到并排的柱子中的一组</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220404173916617.png" alt="image-20220404173916617" style="zoom: 50%;" />
</li>
<li><p>堆积柱状图：传递<code>stacked=True</code></p>
</li>
</ul>
<blockquote>
<p>使用value_counts: s.value_counts().plot.bar()可以有效地对Series值频率进行可视化</p>
</blockquote>
<ul>
<li><p>使用seaborn绘制需要聚合和汇总的数据会更简单：seaborn.barplot</p>
<ul>
<li>data参数：可以是pandas的DataFrame</li>
<li>hue参数：通过一个额外的分类值将数据分离</li>
</ul>
</li>
<li><p>设置seaborn外观：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.<span class="built_in">set</span>(style=<span class="string">&quot;whitegrid&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="直方图和密度图"><a href="#直方图和密度图" class="headerlink" title="直方图和密度图"></a>直方图和密度图</h3><p><strong>直方图</strong></p>
<ul>
<li>定义：直方图是一种条形图，用于给出值频率的离散显示。数据点被分成离散的，均匀间隔的箱，并且绘制每个箱中数据点的数量。</li>
<li>使用Series的plot.hist方法可以绘制直方图</li>
</ul>
<p><strong>密度图</strong></p>
<ul>
<li><p>定义：通过计算可能产生观测数据的连续概率分布估计而产生，密度图也被称为内核密度估计图（KDE）。</p>
</li>
<li><p>plot.kde使用传统法定混合法估计绘制密度图</p>
</li>
<li><p>distplot方法可以绘制直方图和连续密度估计</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">comp1 = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, size=<span class="number">200</span>)</span><br><span class="line">comp2 = np.random.normal(<span class="number">10</span>, <span class="number">2</span>, size=<span class="number">200</span>)</span><br><span class="line">values = pd.Series(np.concatenate([comp1, comp2]))</span><br><span class="line">sns.distplot(values, bins=<span class="number">100</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/nn.png" alt="nn" style="zoom:50%;" /></li>
</ul>
<h3 id="散点图或点图"><a href="#散点图或点图" class="headerlink" title="散点图或点图"></a>散点图或点图</h3><blockquote>
<p>点图或散点图可以用于检验两个一维数据序列之间的关系</p>
</blockquote>
<ul>
<li><p>seaborn的regplot方法 绘制散点图并拟合一条线性回归线</p>
</li>
<li><p>seaborn的pairplot方法：支持在对角线上放置每个变量的直方图和密度估计值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># plot_kws参数能够将配置选项传递给非对角元素上的各个绘图调用</span></span><br><span class="line">sns.pairplot(trans_data, diag_kind=<span class="string">&#x27;kde&#x27;</span>, plot_kws=&#123;<span class="string">&#x27;alpha&#x27;</span>: <span class="number">0.2</span>&#125;)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_143" alt="epub_22739904_143" style="zoom: 33%;" /></li>
</ul>
<h3 id="分面网格和分类数据"><a href="#分面网格和分类数据" class="headerlink" title="分面网格和分类数据"></a>分面网格和分类数据</h3><blockquote>
<p>使用分面网格是利用多种分组变量对数据进行可视化的方式</p>
</blockquote>
<ul>
<li><p>sns.factorplot()：可以简化多种分面绘图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.factorplot(x=<span class="string">&#x27;day&#x27;</span>, y=<span class="string">&#x27;tip_pct&#x27;</span>, hue=<span class="string">&#x27;time&#x27;</span>, col=<span class="string">&#x27;smoker&#x27;</span>,kind=<span class="string">&#x27;bar&#x27;</span>, data=tips[tips.tip_pct &lt; <span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_144" alt="epub_22739904_144" style="zoom:50%;" />
</li>
<li><p>可以使用seaborn.FaceGrid创建自己的分面网格图</p>
</li>
</ul>
<h2 id="9-3-其他Python可视化工具"><a href="#9-3-其他Python可视化工具" class="headerlink" title="9.3 其他Python可视化工具"></a>9.3 其他Python可视化工具</h2><ul>
<li>创建web交互式<ul>
<li>Bokeh（<a href="http://bokeh.pydata.org/%EF%BC%89">http://bokeh.pydata.org/）</a></li>
<li>Plotly（<a href="https://github.com/plotly/plotly.py%EF%BC%89">https://github.com/plotly/plotly.py）</a></li>
</ul>
</li>
<li>印刷或静态网页<ul>
<li>matplotlib</li>
<li>pandas</li>
<li>seaborn</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习： 数据分析</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>二、Python语言基础、IPython及Jupytermotebook——《利用Python进行数据分析》</title>
    <url>/2022/03/28/%E4%BA%8C%E3%80%81Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E3%80%81IPython%E5%8F%8AJupytermotebook%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/</url>
    <content><![CDATA[<h1 id="第二章-Python语言基础、IPython及Jupyternotebook"><a href="#第二章-Python语言基础、IPython及Jupyternotebook" class="headerlink" title="第二章 Python语言基础、IPython及Jupyternotebook"></a>第二章 Python语言基础、IPython及Jupyternotebook</h1><p>推荐使用IPython命令行和Jupyter notebook来实验代码示例，以及探索各种类型、函数和方法的文档。</p>
<p>和其他键盘控制的命令行环境一样，练就常用命令的肌肉记忆也是学习曲线的一部分。</p>
<p><strong>优秀Python书籍推荐</strong></p>
<ul>
<li>《Python Cookbook》（第3版），作者为David Beazley和Brian K.Jones（O’Reilly）</li>
<li>《Fluent Python》，作者为Luciano Ramalho（O’Reilly）</li>
<li>《Fluent Python》，作者为Luciano Ramalho（O’Reilly）</li>
</ul>
<h2 id="2-1-Python解释器"><a href="#2-1-Python解释器" class="headerlink" title="2.1 Python解释器"></a>2.1 Python解释器</h2><ul>
<li><p>标准的交互式Python解释器可以通过在命令行输入python命令来启动</p>
</li>
<li><p>在命令行中看到的&gt;&gt;&gt;提示符是你键入代码的地方</p>
</li>
<li><p>退出Python解释器回到命令行提示符，可以输入exit()或者按下Ctrl-D</p>
</li>
<li><p>运行Python文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python hello_world.py</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用%run命令，IPython会在同一个进程内执行指定文件中的代码，可以立即看到结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In[1]:%run hello_world.py</span><br><span class="line">Hello world</span><br><span class="line">In[2]:  #IPython默认提示符用类似In[2]风格，而不是&gt;&gt;&gt;提示符</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-2-IPython基础"><a href="#2-2-IPython基础" class="headerlink" title="2.2 IPython基础"></a>2.2 IPython基础</h2><p><strong>运行IPython命令行</strong></p>
<ul>
<li>输入ipython命令启动IPython命令行</li>
<li>在IPython中仅输入一个变量名，会返回一个表示该对象的字符串</li>
</ul>
<p><strong>运行Jupyter notebook</strong></p>
<ul>
<li><p>Python的Jupyter内核使用IPython系统进行内部活动</p>
</li>
<li><p>启动Jupyter时，在终端中运行jupyter notebook命令</p>
</li>
<li><p>在很多平台上，Jupyter会自动打开你的默认网络浏览器（除非你使用了–no-browser命令），也可以通过http地址来浏览notebook，地址是<a href="http://localhost:8888/">http://localhost:8888/</a></p>
</li>
<li><p>Jupyter可以部署在服务器远端</p>
</li>
</ul>
<p><strong>Tab补全</strong></p>
<ul>
<li><p>IPython的提升之一就是tab补全功能，当在命令行输入表达式时，按下Tab键即可为任意变量（对象、函数等）搜索命名空间，与你目前已输入的字符进行匹配</p>
</li>
<li><p>在输入英文的句号之后，按下tab，对方法、属性的名称进行补全，模块也可以通过相同的方式补全。</p>
</li>
<li><blockquote>
<p>在Jupyter notebook和新版的IPython（5.0及以上）中，自动补全是在下拉选项中展现，而不是文本输出。</p>
<p>IPython默认情况下隐藏了以下划线开始的方法和属性，诸如魔术方法、内部“私有”方法和属性，以避免杂乱的显示（使新手混淆）。先输入下划线也可以在tab补全时找到它们。想要直接看到，要修改IPython配置。</p>
</blockquote>
</li>
<li><p>当输入任意路径（甚至是Python字符串）时，按下Tab键将补全你的计算机文件系统中匹配你输入内容的值，与%run命令搭配使用，该功能将为你节省大量键盘输入。</p>
</li>
<li><p>tab补全可以在函数的关键字参数（包含&#x3D;号）中节约时间</p>
</li>
</ul>
<p><strong>内省</strong></p>
<ul>
<li><p>在一个变量名的前后使用问号（?）可以显示一些关于该对象的概要信息</p>
</li>
<li><p>如果对象是一个函数或实例方法且文档字符串已经写好，则文档字符串会显示出来。</p>
</li>
<li><p>使用双问号？？可以显示函数的源代码</p>
</li>
<li><p>？的终极用途：把一些字符和通配符（星号*）结合在一起，会显示所有匹配通配符表达式的命名。</p>
<figure class="highlight ipython"><table><tr><td class="code"><pre><span class="line">In[<span class="number">13</span>]:np.*load*?</span><br><span class="line">np.__loader__</span><br><span class="line">np.load</span><br><span class="line">np.loads</span><br><span class="line">np.loadtxt</span><br><span class="line">np.pkgload</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>%run命令</strong></p>
<ul>
<li><p>在IPython会话中使用%run命令运行任意的Python程序文件，这个行为与在命令行中使用python script.py来运行程序相同。文件中定义的所有变量（导入的、函数中的、全局定义的）在运行后，可以在IPython命令行中使用（除非出现某种异常）。</p>
</li>
<li><p>一个Python脚本需要命令行提供参数（通过sys.argv获得）</p>
</li>
<li><blockquote>
<p>如果你想让待运行的脚本使用交互式IPython命名空间中已有的变量，请使用%run -i替代普通的%run命令。</p>
</blockquote>
</li>
<li><p>在Jupyter notebook中，使用%load魔术函数将脚本导入一个代码单元</p>
</li>
</ul>
<p><strong>中断运行中的代码</strong></p>
<ul>
<li><p>在任意代码运行时按下Ctrl-C，都将引起KeyboardInterrupt，Python程序会立即停止运行。</p>
</li>
<li><blockquote>
<p> 当一段Python代码被其他已经编译的扩展模块调用时，按下Ctrl-C并不会让程序立即停止运行。在这些情况下，你需要等到控制流重新返回Python解释器，在更糟糕的情况下可能要强制结束Python进程。</p>
</blockquote>
</li>
</ul>
<p><strong>执行剪贴板中的程序</strong></p>
<ul>
<li>%paste和%cpaste魔术函数<ul>
<li>%paste会获得剪贴板中的所有文本，并在命令行中作为一个代码块去执行</li>
<li>%cpaste与之类似，只不过它会给出一个特殊的提示符，让你粘贴代码</li>
<li>如果你发现粘贴的代码有误，可以按下Ctrl-C来中断%cpaste提示符</li>
</ul>
</li>
</ul>
<p><strong>终端快捷键</strong></p>
<ul>
<li><p>IPython快捷键</p>
<ul>
<li><p>标准IPython快捷键</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220315151517435.png" alt="image-20220315151517435" style="zoom:80%;" />
</li>
<li><p>Ipython命令行的部分快捷键</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220315151539406.png" alt="image-20220315151539406" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>Jupyter Notebook有一个独立的快捷键集合用于导航和编辑，快捷键的更新比IPython更为频繁，可以在菜单栏中的帮助系统进行学习。</p>
</li>
</ul>
<p><strong>关于魔术命令</strong></p>
<ul>
<li><p>IPython的特殊命令（没有内建到Python自身中去）被称为“魔术”命令，前缀符号为%，例如使用%timeit来检查Python语句的执行时间。</p>
</li>
<li><p>魔术命令可以看作是IPython系统内部的命令行程序，大多数魔术命令可以使用？查看额外的“命令行”选项。</p>
</li>
<li><p>魔术函数也可以不加百分号%就使用，只要没有变量被定义为与魔术函数相同的名字即可。这种特性被称为自动魔术，通过%automagic进行启用&#x2F;禁用关。</p>
</li>
<li><p>一些魔术函数也像Python函数一样，其输出可以赋给一个变量。</p>
</li>
<li><p>建议使用%quickref或者%magic探索所有的特殊命令</p>
</li>
<li><p>一些常用的魔术命令</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220315151616242.png" alt="image-20220315151616242" style="zoom:80%;" /></li>
</ul>
<p><strong>matplotlib集成</strong></p>
<ul>
<li><p>%matplotlib魔术函数可以设置matplotlib与IPython命令行或Jupyter notebook的集成。</p>
</li>
<li><p>IPython命令行，运行%matplotlib命令生成多个绘图窗口，而不干扰控制台的会话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In[26]:%matplotlib</span><br><span class="line">Using matplotlib backend:Qt4Agg</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Jupyter中，命令会有不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In[26]:%matplotlib inline</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-3-Python语言基础"><a href="#2-3-Python语言基础" class="headerlink" title="2.3 Python语言基础"></a>2.3 Python语言基础</h2><h3 id="语言语义"><a href="#语言语义" class="headerlink" title="语言语义"></a>语言语义</h3><p><strong>缩进，而不是大括号</strong></p>
<ul>
<li>一个冒号代表一个缩进代码块的开始，单个代码块要保持相同的缩进，直到代码块结束</li>
<li>使用四个空格来缩进</li>
<li>Python语句不以分号结尾，但可以用于在一行内进行多条语句之间的分隔，但是一行有多条语句，代码可读性会变差</li>
</ul>
<p><strong>一切皆为对象</strong></p>
<ul>
<li>每一个数值、字符串、数据结构、函数、类、模块以及所有存在于Python解释器中的事物，都是Python对象。</li>
</ul>
<p><strong>注释</strong></p>
<ul>
<li>“#”用来注释</li>
</ul>
<p><strong>函数和对象方法的调用</strong></p>
<ul>
<li>几乎所有的Python对象都有内部函数，称为方法，可以访问到对象内部的内容</li>
<li>函数传参既可以是位置参数也可以是关键字参数</li>
</ul>
<p><strong>变量和参数传递</strong></p>
<ul>
<li><p>在Python中对一个变量（或者变量名）赋值时，你就创建了一个指向等号右边对象的引用</p>
</li>
<li><p>&#96;&#96;&#96;python<br>In[8]:a&#x3D;[1,2,3]<br>In[9]:b&#x3D;a   #此时a和b指向同一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &gt; 赋值也被称为绑定，这是因为我们将一个变量名绑定到了一个对象上。已被赋值的变量名有时也会被称为被绑定变量</span><br><span class="line"></span><br><span class="line">- 可以更换可变参数的内部值</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  In[27]:data=[1,2,3]</span><br><span class="line">  In[28]:append_element(data,4)</span><br><span class="line">  In[29]:data</span><br><span class="line">  Out[29]:[1,2,3,4]</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>动态引用，强类型</strong></p>
<ul>
<li><p>变量对于对象来说只是特定命名空间中的名称；类型信息是存储在对象自身之中的</p>
</li>
<li><p>Python被认为是强类型语言，这意味着所有的对象都拥有一个指定的类型（或类），隐式的转换只在某些特定、明显的情况下发生</p>
</li>
<li><p>可以使用isinstance函数来检查一个对象是否是特定类型的实例，它也接受包含一个类型的元组，可以检查对象的类型是否在元组的类型中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[<span class="number">21</span>]:a=<span class="number">5</span></span><br><span class="line">In[<span class="number">22</span>]:<span class="built_in">isinstance</span>(a,<span class="built_in">int</span>)</span><br><span class="line">Out[<span class="number">22</span>]:<span class="literal">True</span></span><br><span class="line">In[<span class="number">23</span>]:a=<span class="number">5</span>;b=<span class="number">4.5</span></span><br><span class="line">In[<span class="number">24</span>]:<span class="built_in">isinstance</span>(a,(<span class="built_in">int</span>,<span class="built_in">float</span>))</span><br><span class="line">Out[<span class="number">24</span>]:<span class="literal">True</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>属性和方法</strong></p>
<ul>
<li><p>属性和方法可以用obj.attribute_name进行调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: a = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: a.&lt;Press Tab&gt;</span><br><span class="line">a.capitalize  a.<span class="built_in">format</span>      a.isupper     a.rindex      a.strip</span><br><span class="line">a.center      a.index       a.join        a.rjust       a.swapcase</span><br><span class="line">a.count       a.isalnum     a.ljust       a.rpartition  a.title</span><br><span class="line">a.decode      a.isalpha     a.lower       a.rsplit      a.translate</span><br><span class="line">a.encode      a.isdigit     a.lstrip      a.rstrip      a.upper</span><br><span class="line">a.endswith    a.islower     a.partition   a.split       a.zfill</span><br><span class="line">a.expandtabs  a.isspace     a.replace     a.splitlines</span><br><span class="line">a.find        a.istitle     a.rfind       a.startswith</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性和方法也可以通过getattr函数获得</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[<span class="number">27</span>]:<span class="built_in">getattr</span>(a,<span class="string">&#x27;split&#x27;</span>)</span><br><span class="line">Out[<span class="number">28</span>]:&lt;function <span class="built_in">str</span>.split&gt;</span><br></pre></td></tr></table></figure>

<p>在其他的语言中，通过变量名访问对象通常被称为“反射”,它们可以用来高效地编写通用、可复用的代码。</p>
</li>
</ul>
<p><strong>鸭子类型</strong></p>
<ul>
<li><p>“鸭子类型”的说法源于“一个东西走起来像鸭子叫起来像鸭子，那它就是鸭子”。例如，你可以验证一个对象如果实现了迭代器协议，那它一定是可以迭代的。</p>
</li>
<li><p>当一个函数接受多种输入类型时，可以使用isiterable函数。比如：写接受任意序列类型（列表、元组、n维数组），甚至是一个迭代器的函数时使用这项功能。你可以先检查对象是否是一个列表（或者一个NumPy数组），如果不是就把它转换为列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x, <span class="built_in">list</span>) <span class="keyword">and</span> isiterable(x): </span><br><span class="line">	x = <span class="built_in">list</span>(x)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>导入</strong></p>
<ul>
<li>模块：在Python中，模块就是以．py为后缀名并包含Python代码的文件。</li>
</ul>
<p><strong>二元运算符和比较运算</strong></p>
<ul>
<li><p>检查两个引用是否指向同一个对象，可以使用is关键字，不是可以用is not。</p>
</li>
<li><p>is和&#x3D;&#x3D;是不同的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[<span class="number">1</span>]:a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">In[<span class="number">2</span>]:c=<span class="built_in">list</span>(a)</span><br><span class="line">In[<span class="number">3</span>]:a <span class="keyword">is</span> <span class="keyword">not</span> c  <span class="comment"># list函数总是创建一个新的Python列表（即一份拷贝）</span></span><br><span class="line">Out[<span class="number">1</span>]:<span class="literal">True</span></span><br><span class="line">In[<span class="number">4</span>]:a==c</span><br><span class="line">Out[<span class="number">2</span>]:<span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>is和is not的常用之处是检查一个变量是否为None</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[<span class="number">1</span>]:a=<span class="literal">None</span></span><br><span class="line">In[<span class="number">2</span>]:a <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">Out[<span class="number">1</span>]:<span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>二元操作符<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220313170604994.png" alt="image-20220313170604994" style="zoom:50%;" /></p>
</li>
</ul>
<p><strong>可变对象和不可变对象</strong></p>
<ul>
<li>Python中的大部分对象，例如列表、字典、NumPy数组都是可变对象，大多数用户定义的类型（类）也是可变的。可变对象中包含的对象和值是可以被修改的。</li>
<li>字符串和元组是不可变对象。</li>
<li>修改行为会有副作用，建议使用不可变性，尽量不可变对象中也可能包含可变对象。</li>
</ul>
<h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><ul>
<li>Python的标准库中拥有一个小的内建类型集合，用来处理数值数据、字符串、布尔值（True或False）以及日期和时间。这类的“单值”类型有时被称为标量类型，我们在本书中称之为标量。</li>
<li>标准库中含有datetime模块，日期和时间的处理将单独讨论</li>
<li>标准Python标量类型        <img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220313233326774.png" alt="image-20220313233326774"></li>
</ul>
<p><strong>数值类型</strong></p>
<ul>
<li>基础的Python数字类型就是int和float，int可以存储任意大小数字，浮点数是双精度64位数值（可以用科学计数法表示）</li>
<li>整数除法结果会自动转型为浮点数</li>
<li>只保留整数部分，使用“&#x2F;&#x2F;”</li>
</ul>
<p><strong>字符串</strong></p>
<ul>
<li><p>字符串可以用单引号和双引号表示</p>
</li>
<li><p>对于含有换行的多行字符串，你可以使用三个单引号’’’或三个双引号”””</p>
</li>
<li><p>Python中字符串不可变，无法修改</p>
</li>
<li><pre><code class="python">c = &quot;&quot;&quot;
This is a longer string that
spans multiple lines
&quot;&quot;&quot;
# c中有三个回车符
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  c实际上包含了四行文本；&quot;&quot;&quot;后的换行和lines后的换行都是包含在字符串中的</span><br><span class="line"></span><br><span class="line">- Python对象可以通过str函数转成字符串</span><br><span class="line"></span><br><span class="line">- 字符串是Unicode字符的序列，因此可以被看作是除了列表和元组外的另一种序列</span><br><span class="line"></span><br><span class="line">- 转义字符：\</span><br><span class="line"></span><br><span class="line">- 加前缀符号r表示字符是原生字符(r是raw的简写，表示原生的)</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  In[1]:s = r&#x27;this\has\no\special\characters&#x27;</span><br><span class="line">  In[2]:s</span><br><span class="line">  Out[1]:&#x27;this\has\no\special\characters&#x27;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>字符串格式化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[<span class="number">1</span>]:template = <span class="string">&#x27;&#123;0:.2f&#125; &#123;1:s&#125; are worth US$&#123;2:d&#125;&#x27;</span></span><br><span class="line">In[<span class="number">2</span>]:template.<span class="built_in">format</span>(<span class="number">4.5560</span>, <span class="string">&#x27;Argentine Pesos&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">Out[<span class="number">1</span>]:<span class="string">&#x27;4.56 Argentine Pesos are worth US$1&#x27;</span></span><br></pre></td></tr></table></figure>

<p>字符串官方文档：<a href="https://docs.python.org/3.6/library/string.html">https://docs.python.org/3.6/library/string.html</a></p>
</li>
</ul>
<p><strong>字节与Unicode</strong></p>
<ul>
<li><p>Python 3.0及以上,Unicode成为字符串类型的一等类，用于更好地兼容处理ASCII和非ASCII文本。以前的Unicode编码完全是字节。</p>
</li>
<li><p>使用enocde方法将这个Unicode字符串转换为UTF-8字节，decode方法进行解码。</p>
</li>
<li><p>在字符串前加前缀b来定义字符文本（用法很少）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bytes_val = <span class="string">b&#x27;this is bytes&#x27;</span></span><br><span class="line">bytes_val</span><br><span class="line">decoded = bytes_val.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">decoded  <span class="comment"># this is str (Unicode) now</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>布尔值</strong></p>
<ul>
<li>Python中的布尔值写作True和False，可以与and和or关键字合用。</li>
</ul>
<p><strong>类型转换</strong></p>
<ul>
<li>str、bool、int和float既是数据类型，同时也是可以将其他数据转换为这些类型的函数</li>
</ul>
<p><strong>None</strong></p>
<ul>
<li><p>None是Python的null值类型</p>
</li>
<li><p>如果一个函数没有显式地返回值，则它会隐式地返回None</p>
</li>
<li><p>None还可以作为一个常用的函数参数默认值</p>
</li>
<li><p>从技术角度来说，None不仅是一个关键字，它还是NoneType类型的唯一实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[<span class="number">1</span>]:<span class="built_in">type</span>(<span class="literal">None</span>)</span><br><span class="line">Out[<span class="number">1</span>]:NoneType</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>日期和时间</strong></p>
<ul>
<li><p>datetime模块：提供了datetime、data和time类型，包含日期和时间信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[<span class="number">1</span>]:<span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, date, time</span><br><span class="line">In[<span class="number">2</span>]:dt = datetime(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">21</span>)</span><br><span class="line">In[<span class="number">3</span>]:dt.day</span><br><span class="line">Out[<span class="number">1</span>]:<span class="number">29</span></span><br><span class="line">In[<span class="number">4</span>]:dt.minute</span><br><span class="line">Out[<span class="number">2</span>]:<span class="number">30</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取date和time对象：date和time方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[<span class="number">5</span>]:dt.date()</span><br><span class="line">Out[<span class="number">3</span>]:datetime.date(<span class="number">2011</span>,<span class="number">10</span>,<span class="number">29</span>)</span><br><span class="line">In[<span class="number">6</span>]:dt.time()</span><br><span class="line">Out[<span class="number">4</span>]:datetime.time(<span class="number">20</span>,<span class="number">30</span>,<span class="number">21</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>strftime方法将datetime转换为字符串</p>
</li>
<li><p>字符串可以通过strptime函数转换为datetime对象</p>
</li>
<li><p>使用replace替换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dt.replace(minute=<span class="number">0</span>,second=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>datetime.datetime是不可变类型，以上的方法都是产生新的对象</p>
</blockquote>
</li>
<li><p>两个不同的datetime对象会产生一个datatime.timedelta类型的对象，表示时间间隔；将timedelta加到一个datetime上将产生一个新的对象。</p>
</li>
<li><p>Datetime格式化详细说明（ISO C89兼容）</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220314002530605.png" alt="image-20220314002530605" style="zoom:50%;" /></li>
</ul>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p><strong>if、elif和else</strong></p>
<ul>
<li>一个if语句可以接多个elif代码块和一个else代码块，如果所有的elif条件均为False，则执行else代码块。</li>
<li>当使用and和or进行混合条件判断时，条件判断是从左到右的并且在and或or两侧的条件会有“短路”现象</li>
<li>if中允许有链式比较</li>
</ul>
<p><strong>for循环</strong></p>
<ul>
<li>for循环用于遍历一个集合（例如列表或元组）或一个迭代器</li>
<li>使用continue关键字可以跳过conitnue后面的代码进入下一次循环</li>
<li>使用break关键字可以结束一个for循环</li>
</ul>
<blockquote>
<p>​        break关键字只结束最内层的for循环；外层的for循环会继续运行</p>
</blockquote>
<p><strong>while循环</strong></p>
<blockquote>
<ul>
<li>while循环会在条件符合时一直执行代码块，直到条件判断为False或显式地以break结尾时才结束</li>
</ul>
</blockquote>
<p><strong>pass</strong></p>
<ul>
<li>pass在Python中表示什么都不做，可以作为没有实现的代码占位符</li>
</ul>
<p><strong>range</strong></p>
<ul>
<li><p>range函数返回一个迭代器，该迭代器生成一个等差整数序列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[<span class="number">1</span>]:<span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">1</span>]:<span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">In[<span class="number">2</span>]:<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">Out[<span class="number">2</span>]:[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>起始、结尾、步进（可以是负的）可以传参给range函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[<span class="number">1</span>]:<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>,<span class="number">0</span>,-<span class="number">1</span>))</span><br><span class="line">Out[<span class="number">1</span>]:[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>range产生的整数包含起始但不包含结尾，常用于遍历序列</p>
</blockquote>
</li>
</ul>
<p><strong>三元表达式</strong></p>
<ul>
<li><p>将一个if-else代码块联合起来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = true-expr <span class="keyword">if</span> condition <span class="keyword">else</span> false-expr</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以压缩代码量，但是牺牲可读性</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习： 数据分析</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>八、数据规整：连接、联合与重塑——《利用Python进行数据分析》</title>
    <url>/2022/04/03/%E5%85%AB%E3%80%81%E6%95%B0%E6%8D%AE%E8%A7%84%E6%95%B4%EF%BC%9A%E8%BF%9E%E6%8E%A5%E3%80%81%E8%81%94%E5%90%88%E4%B8%8E%E9%87%8D%E5%A1%91%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/</url>
    <content><![CDATA[<h1 id="第八章-数据规整：连接、联合与重塑"><a href="#第八章-数据规整：连接、联合与重塑" class="headerlink" title="第八章 数据规整：连接、联合与重塑"></a>第八章 数据规整：连接、联合与重塑</h1><h2 id="8-1-分层索引"><a href="#8-1-分层索引" class="headerlink" title="8.1 分层索引"></a>8.1 分层索引</h2><blockquote>
<p>分层索引允许在一个轴向上拥有多个（两个或两个以上）索引层级</p>
</blockquote>
<p><strong>Series分层索引</strong></p>
<ul>
<li><p>创建</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.Series(np.random.randn(<span class="number">9</span>),</span><br><span class="line">                 index=[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">                        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="string">&quot;&quot;&quot;输出</span></span><br><span class="line"><span class="string">a  1   -0.204708</span></span><br><span class="line"><span class="string">   2    0.478943</span></span><br><span class="line"><span class="string">   3   -0.519439</span></span><br><span class="line"><span class="string">b  1   -0.555730</span></span><br><span class="line"><span class="string">   3    1.965781</span></span><br><span class="line"><span class="string">c  1    1.393406</span></span><br><span class="line"><span class="string">   2    0.092908</span></span><br><span class="line"><span class="string">d  2    0.281746</span></span><br><span class="line"><span class="string">   3    0.769023</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>各种索引方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以MultiIndex作为索引的Series的美化视图</span></span><br><span class="line">data.index</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">MultiIndex([(&#x27;a&#x27;, 1),</span></span><br><span class="line"><span class="string">            (&#x27;a&#x27;, 2),</span></span><br><span class="line"><span class="string">            (&#x27;a&#x27;, 3),</span></span><br><span class="line"><span class="string">            (&#x27;b&#x27;, 1),</span></span><br><span class="line"><span class="string">            (&#x27;b&#x27;, 3),</span></span><br><span class="line"><span class="string">            (&#x27;c&#x27;, 1),</span></span><br><span class="line"><span class="string">            (&#x27;c&#x27;, 2),</span></span><br><span class="line"><span class="string">            (&#x27;d&#x27;, 2),</span></span><br><span class="line"><span class="string">            (&#x27;d&#x27;, 3)],</span></span><br><span class="line"><span class="string">           )</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 分层索引</span></span><br><span class="line">data[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">data[<span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">data.loc[[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b  1   -0.555730</span></span><br><span class="line"><span class="string">   3    1.965781</span></span><br><span class="line"><span class="string">d  2    0.281746</span></span><br><span class="line"><span class="string">   3    0.769023</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 在“内部”层级中进行选择</span></span><br><span class="line">data.loc[:, <span class="number">2</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    0.478943</span></span><br><span class="line"><span class="string">c    0.092908</span></span><br><span class="line"><span class="string">d    0.281746</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>DataFrame分层索引</strong></p>
<ul>
<li><p>unstack重新排列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.unstack() <span class="comment"># 将数据在DataFrame中重新排列</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1	2	3</span></span><br><span class="line"><span class="string">a	-0.204708	0.478943	-0.519439</span></span><br><span class="line"><span class="string">b	-0.555730	NaN	1.965781</span></span><br><span class="line"><span class="string">c	1.393406	0.092908	NaN</span></span><br><span class="line"><span class="string">d	NaN	0.281746	0.769023</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">data.unstack().stack()  <span class="comment"># unstack反操作</span></span><br><span class="line"><span class="comment"># 输出结果为原来模样</span></span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403103053939.png" alt="image-20220403103053939" style="zoom:50%;" />
</li>
<li><p><em>在DataFrame中每一层都可以拥有分层索引</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),</span><br><span class="line">                     index=[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]],</span><br><span class="line">                     columns=[[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>],</span><br><span class="line">                              [<span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Red&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>]])</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403100304726.png" alt="image-20220403100304726" style="zoom:50%;" /></li>
</ul>
<p><strong>分层索引名称</strong></p>
<ul>
<li><p><em>分层的层级可以有名称（字符串或Python对象）</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame.index.names = [<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>]</span><br><span class="line">frame.columns.names = [<span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;color&#x27;</span>]</span><br><span class="line"></span><br><span class="line">frame[<span class="string">&#x27;Ohio&#x27;</span>]</span><br></pre></td></tr></table></figure>



<p><img src="C:/Users/TSY/Desktop/无标题.png" alt="无标题"></p>
</li>
<li><p>MultiIndex对象可以使用其<strong>自身的构造函数</strong>创建并复用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.MultiIndex.from_arrays([[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>], [<span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Red&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>]],</span><br><span class="line">                       names=[<span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;color&#x27;</span>])</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">MultiIndex([(    &#x27;Ohio&#x27;, &#x27;Green&#x27;),</span></span><br><span class="line"><span class="string">            (    &#x27;Ohio&#x27;,   &#x27;Red&#x27;),</span></span><br><span class="line"><span class="string">            (&#x27;Colorado&#x27;, &#x27;Green&#x27;)],</span></span><br><span class="line"><span class="string">           names=[&#x27;state&#x27;, &#x27;color&#x27;])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="重排序和层级排序"><a href="#重排序和层级排序" class="headerlink" title="重排序和层级排序"></a>重排序和层级排序</h3><blockquote>
<p>重新排列轴上的层级顺序</p>
<p>按照特定层级的值对数据进行排序</p>
</blockquote>
<ul>
<li><p>swaplevel接收两个<strong>层级序号</strong>或<strong>层级名称</strong>，返回进行层级变更的<strong>新对象</strong>（但是数据是不变的）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame.swaplevel(<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403102450286.png" alt="image-20220403102450286" style="zoom:50%;" />
</li>
<li><p>sort_index只能在<strong>单一层级</strong>上进行排序，在层级变换时，可以按照层级进行<strong>字典排序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame.sort_index(level=<span class="number">1</span>)</span><br><span class="line">frame.swaplevel(<span class="number">0</span>, <span class="number">1</span>).sort_index(level=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/1.png" alt="1" style="zoom:50%;" />

<blockquote>
<p>按照字典最外层开始排序数据选择效果更好，调用sort_index(level&#x3D;0)或sort_index可以实现</p>
</blockquote>
</li>
</ul>
<h3 id="按层级进行汇总统计"><a href="#按层级进行汇总统计" class="headerlink" title="按层级进行汇总统计"></a>按层级进行汇总统计</h3><ul>
<li><p>在描述性和汇总性统计中使用<strong>level选项</strong>实现在特定轴上进行聚合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># level要被弃用，使用group代替</span></span><br><span class="line">frame.<span class="built_in">sum</span>(level=<span class="string">&#x27;key2&#x27;</span>)</span><br><span class="line"><span class="comment"># frame.groupby(level=&#x27;key2&#x27;).sum()</span></span><br><span class="line">frame.<span class="built_in">sum</span>(level=<span class="string">&#x27;color&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># frame.groupby(level=&#x27;color&#x27;,axis=1).sum()</span></span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/22.png" alt="22" style="zoom:50%;" /></li>
</ul>
<h3 id="使用DataFrame的列进行索引"><a href="#使用DataFrame的列进行索引" class="headerlink" title="使用DataFrame的列进行索引"></a>使用DataFrame的列进行索引</h3><ul>
<li><p>DataFrame数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>), <span class="string">&#x27;b&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>, <span class="number">0</span>, -<span class="number">1</span>),</span><br><span class="line">                      <span class="string">&#x27;c&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">                      <span class="string">&#x27;d&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403105650872.png" alt="image-20220403105650872" style="zoom:50%;" />
</li>
<li><p>DataFrame的<strong>set_index</strong>函数和<strong>reset_index</strong>函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame2 = frame.set_index([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">frame2</span><br><span class="line"></span><br><span class="line"><span class="comment"># set_index函数会生成一个新的DataFrame，新的DataFrame使用一个或多个列作为索引</span></span><br><span class="line"><span class="comment"># 默认这些列会从DataFrame中移除</span></span><br><span class="line">frame.set_index([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], drop=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># reset_index是set_index的反操作，分层索引的索引层级会被移动到列中</span></span><br><span class="line">frame2.reset_index()</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/re_set.png" alt="re_set" style="zoom:50%;" /></li>
</ul>
<h2 id="8-2-联合与合并数据集"><a href="#8-2-联合与合并数据集" class="headerlink" title="8.2 联合与合并数据集"></a>8.2 联合与合并数据集</h2><p><strong>pandas数据联合方式</strong></p>
<ul>
<li>pandas.merge根据一个或多个键将行进行连接，数据库的连接操作</li>
<li>pandas.concat使对象在轴向上进行黏合或“堆叠”</li>
<li>combine_first实例方法允许将重叠的数据拼接在一起，以使用一个对象中的值填充另一个对象中的缺失值</li>
</ul>
<h3 id="数据库风格的DataFrame连接"><a href="#数据库风格的DataFrame连接" class="headerlink" title="数据库风格的DataFrame连接"></a>数据库风格的DataFrame连接</h3><ul>
<li><p><strong>pandas.merge</strong>函数：将各种join操作运用在数据上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">                    <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>)&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">                    <span class="string">&#x27;data2&#x27;</span>: <span class="built_in">range</span>(<span class="number">3</span>)&#125;)</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  key  data1</span></span><br><span class="line"><span class="string">0   b      0</span></span><br><span class="line"><span class="string">1   b      1</span></span><br><span class="line"><span class="string">2   a      2</span></span><br><span class="line"><span class="string">3   c      3</span></span><br><span class="line"><span class="string">4   a      4</span></span><br><span class="line"><span class="string">5   a      5</span></span><br><span class="line"><span class="string">6   b      6</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(df2)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  key  data2</span></span><br><span class="line"><span class="string">0   a      0</span></span><br><span class="line"><span class="string">1   b      1</span></span><br><span class="line"><span class="string">2   d      2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用merge进行多对一连接</p>
<ul>
<li><p>简单示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># merge会自动将重叠列名作为连接的键</span></span><br><span class="line">pd.merge(df1, df2)</span><br><span class="line"></span><br><span class="line">pd.merge(df1, df2, on=<span class="string">&#x27;key&#x27;</span>) <span class="comment"># 显示指定键</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">key	data1	data2</span></span><br><span class="line"><span class="string">0	b	0	1</span></span><br><span class="line"><span class="string">1	b	1	1</span></span><br><span class="line"><span class="string">2	b	6	1</span></span><br><span class="line"><span class="string">3	a	2	0</span></span><br><span class="line"><span class="string">4	a	4	0</span></span><br><span class="line"><span class="string">5	a	5	0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>merge默认内连接，只出现表的交集；有可选项’left’、’right’和’outer’（外连接是键的并集）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df3 = pd.DataFrame(&#123;<span class="string">&#x27;lkey&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">                    <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>)&#125;)</span><br><span class="line">df4 = pd.DataFrame(&#123;<span class="string">&#x27;rkey&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">                    <span class="string">&#x27;data2&#x27;</span>: <span class="built_in">range</span>(<span class="number">3</span>)&#125;)</span><br><span class="line"><span class="built_in">print</span>(df3)</span><br><span class="line"><span class="built_in">print</span>(df4)</span><br><span class="line"><span class="comment"># 指定列名</span></span><br><span class="line">pd.merge(df3, df4, left_on=<span class="string">&#x27;lkey&#x27;</span>, right_on=<span class="string">&#x27;rkey&#x27;</span>) <span class="comment"># 内连接</span></span><br><span class="line"></span><br><span class="line">pd.merge(df1, df2, how=<span class="string">&#x27;outer&#x27;</span>) <span class="comment"># 外连接</span></span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/%E5%86%85%E5%A4%96.png" alt="内外" style="zoom:50%;" />
</li>
<li><p>how参数的不同连接类型</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_103" alt="epub_22739904_103" style="zoom:67%;" /></li>
</ul>
</li>
<li><p>使用merge进行多对多连接</p>
<ul>
<li><p>多对多连接是行的笛卡尔积</p>
</li>
<li><p>使用多个键进行合并时，传入一个列名的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.merge(left, right, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>], how=<span class="string">&#x27;outer&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p>当你在进行列-列连接时，传递的DataFrame索引对象会被丢弃</p>
</blockquote>
<ul>
<li><p><strong>重叠列名</strong></p>
<ul>
<li><p>手动重命名轴标签</p>
</li>
<li><p><strong>merge的suffixes</strong>后缀选项：在左右两边有重叠列名时指定需要添加的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.merge(left, right, on=<span class="string">&#x27;key1&#x27;</span>, suffixes=(<span class="string">&#x27;_left&#x27;</span>, <span class="string">&#x27;_right&#x27;</span>))</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403114948604.png" alt="image-20220403114948604" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>merge函数参数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_105" alt="img" style="zoom: 40%;" /></li>
</ul>
<h3 id="根据索引合并"><a href="#根据索引合并" class="headerlink" title="根据索引合并"></a>根据索引合并</h3><ul>
<li><p>合并的键是它的索引，可以传递left_index&#x3D;True或right_index&#x3D;True（或者都传）来表示索引需要用来作为合并的键。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left1 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">                      <span class="string">&#x27;value&#x27;</span>: <span class="built_in">range</span>(<span class="number">6</span>)&#125;)</span><br><span class="line">right1 = pd.DataFrame(&#123;<span class="string">&#x27;group_val&#x27;</span>: [<span class="number">3.5</span>, <span class="number">7</span>]&#125;, index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">left1</span><br><span class="line">right1</span><br><span class="line"><span class="comment"># 默认：连键相交</span></span><br><span class="line">pd.merge(left1, right1, left_on=<span class="string">&#x27;key&#x27;</span>,right_index=<span class="literal">True</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	key	value	group_val</span></span><br><span class="line"><span class="string">0	a	0	3.5</span></span><br><span class="line"><span class="string">2	a	2	3.5</span></span><br><span class="line"><span class="string">3	a	3	3.5</span></span><br><span class="line"><span class="string">1	b	1	7.0</span></span><br><span class="line"><span class="string">4	b	4	7.0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用外键进行合并</span></span><br><span class="line">pd.merge(left1, right1, left_on=<span class="string">&#x27;key&#x27;</span>, right_index=<span class="literal">True</span>, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">key	value	group_val</span></span><br><span class="line"><span class="string">0	a	0	3.5</span></span><br><span class="line"><span class="string">2	a	2	3.5</span></span><br><span class="line"><span class="string">3	a	3	3.5</span></span><br><span class="line"><span class="string">1	b	1	7.0</span></span><br><span class="line"><span class="string">4	b	4	7.0</span></span><br><span class="line"><span class="string">5	c	5	NaN</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多层索引数据：隐式的多键合并</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 必须以列表的方式指明合并所需多个列（请注意使用how=&#x27;outer’处理重复的索引值）</span></span><br><span class="line"><span class="comment"># 在多层索引数据的情况下，在索引上连接是一个隐式的多键合并</span></span><br><span class="line">pd.merge(lefth, righth, left_on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>], right_index=<span class="literal">True</span>)</span><br><span class="line">pd.merge(lefth, righth, left_on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>],</span><br><span class="line">        right_index=<span class="literal">True</span>, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line"><span class="comment"># 使用两边的索引进行合并</span></span><br><span class="line">pd.merge(left2, right2, how=<span class="string">&#x27;outer&#x27;</span>, left_index=<span class="literal">True</span>, right_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/333.png" alt="333" style="zoom:50%;" />

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/444.png" alt="444" style="zoom:50%;" />
</li>
<li><p>DataFrame的<strong>join</strong>方法：用于按照索引合并，也可用于合并<strong>多个索引相同或相似但没有重叠列</strong>的DataFrame对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left2.join(right2, how=<span class="string">&#x27;outer&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>join方法进行<strong>左连接</strong>，完全保留左边DataFrame的行索引；支持在连接上<strong>传递索引</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left1.koin(right1,one=<span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引-索引，向join方法传入DataFrame列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># concat方法更为通用</span></span><br><span class="line">left2.join([right2, another], how=<span class="string">&#x27;outer&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="沿轴向连接"><a href="#沿轴向连接" class="headerlink" title="沿轴向连接"></a>沿轴向连接</h3><ul>
<li><p>NumPy的concatenate函数在NumPy数组上实现拼接、绑定或堆叠</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">arr</span><br><span class="line">np.concatenate([arr, arr], axis=<span class="number">1</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[ 0,  1,  2,  3,  0,  1,  2,  3],</span></span><br><span class="line"><span class="string">       [ 4,  5,  6,  7,  4,  5,  6,  7],</span></span><br><span class="line"><span class="string">       [ 8,  9, 10, 11,  8,  9, 10, 11]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>pandas的concat函数</p>
<ul>
<li><p>假设存在三个索引不存在重叠的Series</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = pd.Series([<span class="number">0</span>, <span class="number">1</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">s2 = pd.Series([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">s3 = pd.Series([<span class="number">5</span>, <span class="number">6</span>], index=[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>])</span><br><span class="line"><span class="comment"># 使用concat连接 ，默认沿着axis=0的轴向生效的</span></span><br><span class="line">pd.concat([s1, s2, s3])</span><br><span class="line"><span class="comment"># 传递axis=1，返回的结果则是一个DataFrame（axis=1时是列）</span></span><br><span class="line">pd.concat([s1, s2, s3], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/heb.png" alt="heb" style="zoom:50%;" />
</li>
<li><p>有重叠轴</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s4 = pd.concat([s1, s3])</span><br><span class="line">pd.concat([s1, s4], axis=<span class="number">1</span>)</span><br><span class="line">pd.concat([s1, s4], axis=<span class="number">1</span>, join=<span class="string">&#x27;inner&#x27;</span>) <span class="comment"># 标签f和g消失</span></span><br><span class="line">s4</span><br><span class="line"><span class="string">&quot;&quot;&quot;s4</span></span><br><span class="line"><span class="string">a    0</span></span><br><span class="line"><span class="string">b    1</span></span><br><span class="line"><span class="string">f    5</span></span><br><span class="line"><span class="string">g    6</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在连接轴上建立<strong>多层索引</strong>，使用参数<strong>keys</strong>来实现：区分连接前的各部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = pd.concat([s1, s1, s3], keys=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])</span><br><span class="line">result</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">one    a    0</span></span><br><span class="line"><span class="string">       b    1</span></span><br><span class="line"><span class="string">two    a    0</span></span><br><span class="line"><span class="string">       b    1</span></span><br><span class="line"><span class="string">three  f    5</span></span><br><span class="line"><span class="string">       g    6</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>沿着轴向axis&#x3D;1连接Series的时候，keys则成为DataFrame的列头</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.concat([s1, s2, s3], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403140431340.png" alt="image-20220403140431340" style="zoom:50%;" />
</li>
<li><p>Series扩展到DataFrame对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1 = pd.DataFrame(np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>, <span class="number">2</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">                   columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame(<span class="number">5</span> + np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>, <span class="number">2</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">                   columns=[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">pd.concat([df1, df2], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;level1&#x27;</span>, <span class="string">&#x27;level2&#x27;</span>])</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403140557533.png" alt="image-20220403140557533" style="zoom:50%;" />
</li>
<li><p>如果传递字典，字典的键会用于keys选项</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.concat(&#123;<span class="string">&#x27;level1&#x27;</span>: df1, <span class="string">&#x27;level2&#x27;</span>: df2&#125;, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用names参数生成轴层级</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.concat([df1, df2], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;level1&#x27;</span>, <span class="string">&#x27;level2&#x27;</span>],names=[<span class="string">&#x27;upper&#x27;</span>, <span class="string">&#x27;lower&#x27;</span>])</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403140811873.png" alt="image-20220403140811873" style="zoom:50%;" />
</li>
<li><p>行索引中不包含任何相关数据的DataFrame，传入<code>ignore_index = True</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>concat函数的参数（join_axes好像已经弃用）</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_106" alt="img" style="zoom:50%;" /></li>
</ul>
<h3 id="联合重叠数据"><a href="#联合重叠数据" class="headerlink" title="联合重叠数据"></a>联合重叠数据</h3><p>展示几种数据有重叠部分的情况</p>
<ul>
<li><p>NumPy的where函数，面向数组的if-else等价操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = pd.Series([np.nan, <span class="number">2.5</span>, np.nan, <span class="number">3.5</span>, <span class="number">4.5</span>, np.nan],</span><br><span class="line">              index=[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">b = pd.Series(np.arange(<span class="built_in">len</span>(a), dtype=np.float64),</span><br><span class="line">              index=[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">b[-<span class="number">1</span>] = np.nan</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">np.where(pd.isnull(a), b, a)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403142053075.png" alt="image-20220403142053075" style="zoom:50%;" />
</li>
<li><p>Series的<strong>combine_first</strong>方法，类似于pandas常见的数据对齐逻辑的轴向操作；针对DataFrame逐列做相同的操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b.combine_first(a)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-3-重塑和透视"><a href="#8-3-重塑和透视" class="headerlink" title="8.3 重塑和透视"></a>8.3 重塑和透视</h2><blockquote>
<p>重排列表格型数据的操作被称为重塑或透视</p>
</blockquote>
<h3 id="使用多层索引进行重塑"><a href="#使用多层索引进行重塑" class="headerlink" title="使用多层索引进行重塑"></a>使用多层索引进行重塑</h3><p><strong>两个基础操作</strong></p>
<ul>
<li>**stack(堆叠)**：该操作会“旋转”或将列中的数据透视到行</li>
<li>**unstack(拆堆)**：该操作会将行中的数据透视到列</li>
</ul>
<p><strong>例子说明</strong></p>
<ul>
<li><p>效果演示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.DataFrame(np.arange(<span class="number">6</span>).reshape((<span class="number">2</span>, <span class="number">3</span>)),</span><br><span class="line">                    index=pd.Index([<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>], name=<span class="string">&#x27;state&#x27;</span>),</span><br><span class="line">                    columns=pd.Index([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">                    name=<span class="string">&#x27;number&#x27;</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">number	one	two	three</span></span><br><span class="line"><span class="string">state			</span></span><br><span class="line"><span class="string">Ohio	0	1	2</span></span><br><span class="line"><span class="string">Colorado	3	4	5</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 用stack方法会将列透视到行，产生一个新的Series</span></span><br><span class="line">result = data.stack()</span><br><span class="line">result</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">state     number</span></span><br><span class="line"><span class="string">Ohio      one       0</span></span><br><span class="line"><span class="string">          two       1</span></span><br><span class="line"><span class="string">          three     2</span></span><br><span class="line"><span class="string">Colorado  one       3</span></span><br><span class="line"><span class="string">          two       4</span></span><br><span class="line"><span class="string">          three     5</span></span><br><span class="line"><span class="string">dtype: int32</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 使用unstack方法将数据重排列后放入一个DataFrame中</span></span><br><span class="line">result.unstack() <span class="comment"># 还原</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>默认最内层是已拆堆的，可以传入<strong>层级序号或名称</strong>来拆分一个不同的层级</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result.unstack(<span class="number">0</span>) <span class="comment"># 传入序号来拆分不同的层级</span></span><br><span class="line">result.unstack(<span class="string">&#x27;state&#x27;</span>) <span class="comment"># 传入名称来拆分不同的层级</span></span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403174621301.png" alt="image-20220403174621301" style="zoom:50%;" />
</li>
<li><p>拆堆可能会引入缺失值，堆叠会过滤出缺失值，两个操作可逆</p>
</li>
<li><p>在DataFrame中拆堆时，被拆堆的层级会变为结果中最低的层级</p>
</li>
<li><p>在调用stack方法时，我们可以指明需要堆叠的轴向名称</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.unstack(<span class="string">&#x27;state&#x27;</span>).stack(<span class="string">&#x27;side&#x27;</span>)</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403175303626.png" alt="image-20220403175303626" style="zoom:50%;" /></li>
</ul>
<h3 id="将“长”透视为“宽”"><a href="#将“长”透视为“宽”" class="headerlink" title="将“长”透视为“宽”"></a>将“长”透视为“宽”</h3><blockquote>
<p>在数据库和CSV中存储多时间序列的方式就是所谓的长格式或堆叠格式</p>
</blockquote>
<ul>
<li><p>使用PeriodIndex将数据处理后形成Idata</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403183953595.png" alt="image-20220403183953595" style="zoom:50%;" />

<p>多时间序列的长格式，或具有两个或更多个键的数据（键date和item）</p>
</li>
<li><p>使用DataFrame的<strong>pivot方法</strong>将数据处理为按date列时间戳进行索引且每个不同的item独立为一列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前两个值是分别用作行和列索引的列</span></span><br><span class="line"><span class="comment"># 然后是可选的数值列以填充DataFrame</span></span><br><span class="line">pivoted = ldata.pivot(<span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;item&#x27;</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">pivoted</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403184419500.png" alt="image-20220403184419500" style="zoom:50%;" />
</li>
<li><p>同时重塑两个数值列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ldata[<span class="string">&#x27;value2&#x27;</span>] = np.random.randn(<span class="built_in">len</span>(ldata))</span><br><span class="line">ldata[:<span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403184717460.png" alt="image-20220403184717460" style="zoom:50%;" />

<p>遗漏最后一个参数，你会得到一个含有多层列的DataFrame</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pivoted = ldata.pivot(<span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;item&#x27;</span>)</span><br><span class="line">pivoted[:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403184906941.png" alt="image-20220403184906941" style="zoom:50%;" />
</li>
<li><p>pivot方法等价于使用set_index创建分层索引，然后调用unstack</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unstacked = ldata.set_index([<span class="string">&#x27;date&#x27;</span>,<span class="string">&#x27;item&#x27;</span>]).unstack(<span class="string">&#x27;item&#x27;</span>)</span><br><span class="line">unstacked[:<span class="number">7</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="将“宽”透视为“长”"><a href="#将“宽”透视为“长”" class="headerlink" title="将“宽”透视为“长”"></a>将“宽”透视为“长”</h3><blockquote>
<p>DataFrame的pivot方法的反操作：pandas.melt，将多列合并成一列，产生一个新的DataFrame</p>
</blockquote>
<ul>
<li><p>数据<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403190157927.png" alt="image-20220403190157927" style="zoom:50%;" /></p>
</li>
<li><p>‘key’列可以作为分组指标，其他列均为数据值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">melted = pd.melt(df, [<span class="string">&#x27;key&#x27;</span>])</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220403190300797.png" alt="image-20220403190300797" style="zoom:50%;" />
</li>
<li><p>使用pivot方法可以重回原来布局</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reshaped = melted.pivot(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;variable&#x27;</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line"><span class="comment"># pivot的结果根据作为行标签的列生成了索引</span></span><br><span class="line"><span class="comment"># 使用reset_index来将数据回移一列</span></span><br><span class="line">reshaped.reset_index()</span><br></pre></td></tr></table></figure>

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/1111.png" alt="1111" style="zoom:50%;" />
</li>
<li><p>可以指定列的子集作为值列，也可以无须任何分组指标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定列的子集作为值列</span></span><br><span class="line">pd.melt(df, id_vars=[<span class="string">&#x27;key&#x27;</span>], value_vars=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line"><span class="comment"># 无须任何分组指标直接使用</span></span><br><span class="line">pd.melt(df, value_vars=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>])</span><br><span class="line">pd.melt(df, value_vars=[<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>机器学习： 数据分析</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>六、数据载入、存储及文件格式《利用Python进行数据分析》</title>
    <url>/2022/03/29/%E5%85%AD%E3%80%81%E6%95%B0%E6%8D%AE%E8%BD%BD%E5%85%A5%E3%80%81%E5%AD%98%E5%82%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/</url>
    <content><![CDATA[<h1 id="第六章-数据载入、存储及文件格式"><a href="#第六章-数据载入、存储及文件格式" class="headerlink" title="第六章 数据载入、存储及文件格式"></a>第六章 数据载入、存储及文件格式</h1><h2 id="6-1-文本格式数据的读写"><a href="#6-1-文本格式数据的读写" class="headerlink" title="6.1 文本格式数据的读写"></a>6.1 文本格式数据的读写</h2><ul>
<li><p>将表格型数据读取为DataFrame对象：read_csv()和read_table()</p>
</li>
<li><p>Pandas的解析函数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_82" alt="img" style="zoom:50%;" />

<ul>
<li><p>可选参数</p>
<ul>
<li>索引：可以将<strong>一或多个列</strong>作为返回的DataFrame</li>
<li>类型推断和数据转换：包括用户自定义的值转换和自定义的缺失值符号列表。</li>
<li>日期时间解析：包括组合功能，包括将分散在多个列上的日期和时间信息组合成结果中的单个列</li>
<li>迭代：对大型文件的分块迭代</li>
<li>未清洗数据问题：跳过行、页脚、注释以及其他次要数据，比如使用逗号分隔千位的数字。</li>
</ul>
</li>
<li><p>一些数据载入函数（如pandas.read_csv等）会进行<strong>类型推断</strong>，因为列的数据类型并不是数据格式的一部分，不必指定那一列是数值、整数、布尔值或字符串。</p>
<ul>
<li><p>处理<strong>日期</strong>和<strong>自定义类型</strong>数据需要其他努力</p>
<ul>
<li><p>pandas默认分配列名，也可以自己指定列名：<code>pd.read_csv(‘examples/ex2.csv’,names=[‘a’,’b’,’c’,’d’,’message’])</code></p>
</li>
<li><p>将message列成为DataFrame索引，可以指定位置4的列为索引，或将‘message’传给参数index_col</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;message&#x27;</span>]</span><br><span class="line">pd.read_csv(<span class="string">&#x27;examples/ex2.csv&#x27;</span>, names=names, index_col=<span class="string">&#x27;message&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>从多个列形成分层索引：传入一个包含列序号或列名的列表：<code>pd.read_csv(‘examples/csv_mindex.cav’,index_col=[‘key1’,’key2’])</code></p>
</li>
</ul>
</li>
<li><p>表的分隔符不固定，使用空白或其他方式来分隔字段</p>
<ul>
<li><p>向read_table传入一个<strong>正则表达式</strong>作为分隔符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = pd.read_table(<span class="string">&#x27;examples/ex3.txt&#x27;</span>,sep=<span class="string">&#x27;\s+&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用skiprows来跳过某些行（例：第一行、第三行和第四行）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_csv(<span class="string">&#x27;examples/ex4.csv&#x27;</span>,skiprows=[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>缺失值处理</p>
<ul>
<li><p>缺失值<strong>不显示（空字符串）</strong>或用<strong>标识值</strong>显示（NA和Null等）</p>
</li>
<li><p><strong>na_values</strong>选项可以传入<strong>一个列表</strong>或<strong>一组字符串</strong>来处理缺失值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_csv(<span class="string">&#x27;examples/ex5.csv&#x27;</span>,na_values=[<span class="string">&#x27;NULL&#x27;</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>在字典中，每列可以指定不同的缺失值标识</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sentinels = &#123;<span class="string">&#x27;message&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;NA&#x27;</span>], <span class="string">&#x27;something&#x27;</span>:[<span class="string">&#x27;two&#x27;</span>]&#125;</span><br><span class="line">pd.read_csv(<span class="string">&#x27;examples/ex5.csv&#x27;</span>, na_values=sentinels)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>一些read_csv&#x2F;read_table函数常用参数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_84" alt="img" style="zoom:50%;" /></li>
</ul>
<h3 id="分块读入文本文件"><a href="#分块读入文本文件" class="headerlink" title="分块读入文本文件"></a>分块读入文本文件</h3><p>处理大型文件时，常需要读入文件的一个小片段或者按小块遍历文件</p>
<ul>
<li><p>在尝试大文件前，可先对pandas的显示设置进行调整，使之更为紧凑</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.options.display.max_rows = <span class="number">10</span></span><br><span class="line"><span class="comment"># 只读取文件的前五行</span></span><br><span class="line">result = pd.read_csv(<span class="string">&#x27;examples/ex6.csv&#x27;</span>,nrows=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置<strong>chunksize</strong>指定每个分块的行数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chunker = pd.read_csv(<span class="string">&#x27;examples/ex6.csv&#x27;</span>,chunksize=<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>read_csv返回TextParser对象，可根据chunksize遍历文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 遍历ex6.csv，并对’key’列聚合获得计数值</span></span><br><span class="line">chunker = pd.read_csv(<span class="string">&#x27;examples/ex6.csv&#x27;</span>,chunksize=<span class="number">1000</span>)</span><br><span class="line">tot = pd.Series([])</span><br><span class="line"><span class="keyword">for</span> piece <span class="keyword">in</span> chunker:</span><br><span class="line">    tot = tot.add(piece[<span class="string">&#x27;key&#x27;</span>].value_counts(),fill_value=<span class="number">0</span>)</span><br><span class="line">tot = tot.sort_values(ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>TextParser还具有get_chunk方法，允许你按照任意大小读取数据块</p>
</li>
</ul>
<h3 id="将数据写入文本格式"><a href="#将数据写入文本格式" class="headerlink" title="将数据写入文本格式"></a>将数据写入文本格式</h3><ul>
<li>DataFrame的<strong>to_csv方法</strong>：将数据导出为逗号分隔的文件，可以通过<strong>sep</strong>设置其他分隔符<ul>
<li>缺失值在输出时以<strong>空字符串</strong>出现，也可以用其他标识符对缺失值进行标注：<code>data.to_csv(sys.stdout,na_rep=‘NULL’)</code></li>
<li>默认列和标签都会被写入，可以禁止二者写入：<code>data.to_csv(sys.stdout,index=False,header=False)</code></li>
<li>按照指定顺序写入列的子集：<code>data.to_csv(sys.stdout,index=False,columns=[‘a’,’b’,’c’])</code></li>
<li>Series也有to_csv方法</li>
</ul>
</li>
</ul>
<h3 id="使用分隔格式"><a href="#使用分隔格式" class="headerlink" title="使用分隔格式"></a>使用分隔格式</h3><ul>
<li><p>read_table无法接收一个带有一行或多行错误的文件</p>
</li>
<li><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220328231634813.png" alt="image-20220328231634813" style="zoom:50%;" />
</li>
<li><p>使用Python的<strong>csv模块</strong>处理带有单字符分隔符的文件，将打开的文件型对象传给<strong>csv.reader</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;examples/ex7.csv&#x27;</span>)</span><br><span class="line">reader = csv.reader(f)</span><br><span class="line"><span class="comment"># 像遍历文件一样，遍历reader会产生元组</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">    <span class="built_in">print</span>(line)  <span class="comment"># 元组的值为删除了引号的字符</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 将文件读取为行的列表</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;examples/ex7.csv&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = <span class="built_in">list</span>(csv.reader(f))</span><br><span class="line"><span class="comment"># 将数据拆分为列名行和数据行</span></span><br><span class="line">header,values = lines[<span class="number">0</span>],lines[<span class="number">1</span>:]</span><br><span class="line"><span class="comment"># 使用字典推导式和表达式zip(*values)生成一个包含数据列的字典，字典中行转置成列</span></span><br><span class="line">data_dict = &#123;h: v <span class="keyword">for</span> h,v <span class="keyword">in</span> <span class="built_in">zip</span>(header,<span class="built_in">zip</span>(*values))&#125;</span><br><span class="line">data_dict</span><br><span class="line"><span class="comment"># &#123;&#x27;a&#x27;: (&#x27;1&#x27;, &#x27;1&#x27;), &#x27;b&#x27;: (&#x27;2&#x27;, &#x27;2&#x27;), &#x27;c&#x27;: (&#x27;3&#x27;, &#x27;3&#x27;)&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<strong>csv.Dialect</strong>定义子类处理不同风格的文件，比如不同的分隔符、字符串引用约定或行终止符等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">my_dialect</span>(csv.Dialect):</span><br><span class="line">    lineterminator = <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    delimiter = <span class="string">&#x27;;&#x27;</span></span><br><span class="line">    quotechar = <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    quoting = csv.QUOTE_MINIMAL</span><br><span class="line">reader = csv.reader(f,dialect=my_dialect)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不定义子类，直接将CSV方言参数传入csv.reader的关键字参数</span></span><br><span class="line">reader = csv.reader(f,delimiter=<span class="string">&#x27;|&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>csv.Dialect中的一些属性及其用途</p>
<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_85" alt="img"></p>
</li>
<li><blockquote>
<p>对于具有更复杂或固定的多字符分隔符的文件，你将无法使用csv模块.</p>
<p>使用字符串的split方法或正则表达式方法re.split进行拆分和其他清理工作</p>
</blockquote>
</li>
<li><p>使用csv.writer手动写入被分隔的文件</p>
<ul>
<li>接收 一个已打开可写入文件对象 和 csv.reader相同的CSV方言、格式选项</li>
<li><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220328233731729.png" alt="image-20220328233731729" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<h3 id="JSON数据"><a href="#JSON数据" class="headerlink" title="JSON数据"></a>JSON数据</h3><blockquote>
<p>JSON（JavaScript Object Notation的简写）已经成为Web浏览器和其他应用间通过HTTP请求发送数据的标准格式。</p>
</blockquote>
<ul>
<li><p>除空值null和一些细微差别（例如不允许列表末尾的逗号）之外，JSON非常接近Python。</p>
<ul>
<li>基本类型是对象（字典）、数组（列表）、字符串、数字、布尔值和空值</li>
<li>所有<strong>键</strong>都必须是<strong>字符串</strong></li>
</ul>
</li>
<li><p>JSON字符串和Python互相转换</p>
<ul>
<li><p>json.loads方法将JSON字符串转换为Python形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&quot;name&quot;: &quot;Wes&quot;,</span></span><br><span class="line"><span class="string"> &quot;places_lived&quot;: [&quot;United States&quot;, &quot;Spain&quot;, &quot;Germany&quot;],</span></span><br><span class="line"><span class="string"> &quot;pet&quot;: null,</span></span><br><span class="line"><span class="string"> &quot;siblings&quot;: [&#123;&quot;name&quot;: &quot;Scott&quot;, &quot;age&quot;: 30, &quot;pets&quot;: [&quot;Zeus&quot;, &quot;Zuko&quot;]&#125;,</span></span><br><span class="line"><span class="string">              &#123;&quot;name&quot;: &quot;Katie&quot;, &quot;age&quot;: 38,</span></span><br><span class="line"><span class="string">               &quot;pets&quot;: [&quot;Sixes&quot;, &quot;Stache&quot;, &quot;Cisco&quot;]&#125;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">result = json.loads(obj)</span><br><span class="line">result</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;name&#x27;: &#x27;Wes&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;places_lived&#x27;: [&#x27;United States&#x27;, &#x27;Spain&#x27;, &#x27;Germany&#x27;],</span></span><br><span class="line"><span class="string"> &#x27;pet&#x27;: None,</span></span><br><span class="line"><span class="string"> &#x27;siblings&#x27;: [&#123;&#x27;name&#x27;: &#x27;Scott&#x27;, &#x27;age&#x27;: 30, &#x27;pets&#x27;: [&#x27;Zeus&#x27;, &#x27;Zuko&#x27;]&#125;,</span></span><br><span class="line"><span class="string">  &#123;&#x27;name&#x27;: &#x27;Katie&#x27;, &#x27;age&#x27;: 38, &#x27;pets&#x27;: [&#x27;Sixes&#x27;, &#x27;Stache&#x27;, &#x27;Cisco&#x27;]&#125;]&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>json.dumps</strong>可以将Python对象转换回JSON：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">asjson = json.dumps(result)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>将JSON转换成其他数据结构，方便的是将字典构成的列表（之前是JSON对象）传入DataFrame构造函数，并选出数据字段的子集</p>
<ul>
<li>&#96;&#96;&#96;python<br>import pandas as pd<br>siblings &#x3D; pd.DataFrame(result[‘siblings’], columns&#x3D;[‘name’, ‘age’])<br>siblings<br>“””<br>name    age<br>0    Scott    30<br>1    Katie    38<br>“””<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - pandas.read_json可以自动将JSON数据集按照指定次序转换为Series或DataFrame。</span><br><span class="line"></span><br><span class="line">    - pandas.read_json默认JSON数组中的每个对象是表里的一行</span><br><span class="line"></span><br><span class="line">- 从pandas中将数据导出为JSON，对Series和DataFrame使用to_json方法</span><br><span class="line"></span><br><span class="line">### XML和HTML：网络抓取</span><br><span class="line"></span><br><span class="line">&gt; Python有很多针对HTML和XML格式进行读取、写入数据的库</span><br><span class="line">&gt;</span><br><span class="line">&gt; lxml（http://lxml.de）、Beautiful Soup、html5lib</span><br><span class="line">&gt;</span><br><span class="line">&gt; lxml更快，其他库操作更多</span><br><span class="line"></span><br><span class="line">**html**</span><br><span class="line"></span><br><span class="line">- pandas的内建函数**read_html**可以使用lxml和BeautifulSoup等库将HTML中的表自动解析为DataFrame对象</span><br><span class="line"></span><br><span class="line">  - 安装</span><br><span class="line"></span><br></pre></td></tr></table></figure>
conda install lxml<br>pip install beautifulsoup4 html5lib<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- pandas.read_html函数存在很多选项，默认搜索并尝试解析所有包含在&lt;table&gt;标签中的表格型数据，返回的结果是DataFrame对象的列表</span><br><span class="line"></span><br><span class="line">- 举例：从美国FDIC政府机构下载了显示银行倒闭数据的HTML文件（在pandas文档中使用）</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  tables = pd.read_html(&#x27;examples/fdic_failed_bank_list.html&#x27;)</span><br><span class="line">  len(tables) # 1</span><br><span class="line">  failures = tables[0] </span><br><span class="line">  failures.head()</span><br><span class="line">  # failures有很多列，pandas在行内插入了换行符\</span><br><span class="line">  # 计算每年银行倒闭的数量</span><br><span class="line">  close_timestamps = pd.to_datetime(failures[&#x27;Closing Date&#x27;])</span><br><span class="line">  close_timestamps.dt.year.value_counts()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>使用lxml.objectify解析XML</strong></p>
<blockquote>
<p>XML（eXtensible Markup Language）是结构化数据格式，它使用元数据支持分层、嵌套数据。</p>
</blockquote>
<p><strong>示例背景</strong>：纽约大都会交通局（MTA）发布了一份关于其公交、火车服务（<a href="http://www.mta.info/developers/down">http://www.mta.info/developers/down</a> loadhtml）的数据集。每个火车或公交服务都有一个不同的文件（例如Performance_MNR.xml代表地铁-北铁路），文件中以一系列XML记录的方式包含了按月的数据。</p>
<ul>
<li><p>使用<strong>lxml.objectify</strong>解析文件，用<strong>getroot</strong>获得XML文件根节点的引用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> objectify</span><br><span class="line">path = <span class="string">&#x27;datasets/mta_perf/Performance_MNR.xml&#x27;</span></span><br><span class="line">parsed = objectify.parse(<span class="built_in">open</span>(path))</span><br><span class="line">root= parsed.getroot()</span><br></pre></td></tr></table></figure>
</li>
<li><p>root.INDICATOR返回一个生成器，可以产生每一个<INDICATOR>XML元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root.INDICATOR返回一个生成器，可以产生每一个&lt;INDICATOR&gt;XML元素（不包括几个标签）</span></span><br><span class="line">data = []</span><br><span class="line"></span><br><span class="line">skip_fields = [<span class="string">&#x27;PARENT_SEQ&#x27;</span>, <span class="string">&#x27;INDICATOR_SEQ&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;DESIRED_CHANGE&#x27;</span>, <span class="string">&#x27;DECIMAL_PLACES&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> elt <span class="keyword">in</span> root.INDICATOR:</span><br><span class="line">    el_data = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> elt.getchildren():</span><br><span class="line">        <span class="keyword">if</span> child.tag <span class="keyword">in</span> skip_fields:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        el_data[child.tag] = child.pyval</span><br><span class="line">    data.append(el_data)</span><br></pre></td></tr></table></figure>
</li>
<li><p>XML标签可以更复杂，每个标签可以包含元数据。一个HYML连接标签，也是有效的XML</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line">tag = <span class="string">&#x27;&lt;a href=&quot;http://www.google.com&quot;&gt;Google&lt;/a&gt;&#x27;</span></span><br><span class="line">root = objectify.parse(StringIO(tag)).getroot()</span><br><span class="line"><span class="comment"># 现在可以访问标签或链接文本中的任何字段（如href）</span></span><br><span class="line">root <span class="comment"># &lt;Element a at 0x7f6b15817748&gt;</span></span><br><span class="line">root.get(<span class="string">&#x27;href&#x27;</span>) <span class="comment"># &#x27;http://www.google.com&#x27;</span></span><br><span class="line">root.text <span class="comment"># &#x27;Google&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-2-二进制格式"><a href="#6-2-二进制格式" class="headerlink" title="6.2 二进制格式"></a>6.2 二进制格式</h2><p><strong>pickle</strong></p>
<ul>
<li><p>使用Python内建的<strong>pickle</strong>序列化模块进行<strong>二进制格式操作</strong></p>
<ul>
<li><p>pandas对象使用<strong>to_pickle</strong>方法将数据以pickle格式写入硬盘</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = pd.read_csv(<span class="string">&#x27;examples/ex1.csv&#x27;</span>)</span><br><span class="line">frame.to_pickle(<span class="string">&#x27;examples/frame_pickle&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<strong>pandas.read_pickle</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_pickle(<span class="string">&#x27;examples/frame_pickle&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>pickle仅作为<strong>短期</strong>存储来使用，被pickle化的对象可能因为库版本更新而<strong>无法反序列化</strong></p>
</li>
</ul>
</li>
<li><p>Python支持的其他两个二进制格式：HDF5和MessagePack</p>
</li>
<li><p>pandas或NumPy其他存储格式</p>
<ul>
<li>bcolz（<a href="http://bcolz.blosc.org/%EF%BC%89%EF%BC%9A%E5%9F%BA%E4%BA%8EBlosc%E5%8E%8B%E7%BC%A9%E5%BA%93%E7%9A%84%E5%8F%AF%E5%8E%8B%E7%BC%A9%E5%88%97%E5%BC%8F%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A0%BC%E5%BC%8F">http://bcolz.blosc.org/）：基于Blosc压缩库的可压缩列式二进制格式</a></li>
<li>基于Blosc压缩库的可压缩列式二进制格式</li>
<li>R编程社区的Hadley Wickham（<a href="http://hadley.nz/%EF%BC%89%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%B7%A8%E8%AF%AD%E8%A8%80%E5%88%97%E5%BC%8F%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">http://hadley.nz/）设计的跨语言列式文件格式</a></li>
<li>Feather使用Apache箭头（<a href="http://arrow.apache.org)列式存储器格式/">http://arrow.apache.org）列式存储器格式</a></li>
</ul>
</li>
</ul>
<p><strong>使用HDF5格式</strong></p>
<blockquote>
<p>存储大量的科学数组数据，以C库的形式提供，有很多其他语言接口</p>
<p>用于处理不适合在内存中存储的超大型数据，可以仅高效读写一小块</p>
</blockquote>
<ul>
<li><p>“HDF”代表分层数据格式，每个HDF5文件可以存储多个数据集并且支持元数据。</p>
</li>
<li><p>HDF5支持多种压缩模式的即时压缩，重复模式的数据可以更高效地存储</p>
</li>
<li><p>可使用PyTables或h5py等库直接访问HDF5文件，但pandas提供高阶接口：<strong>HDFStore类</strong>，可以像字典一样处理细节，简化Series和DataFrame的存储。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: np.random.randn(<span class="number">100</span>)&#125;)</span><br><span class="line">store = pd.HDFStore(<span class="string">&#x27;mydata.h5&#x27;</span>)</span><br><span class="line">store[<span class="string">&#x27;obj1&#x27;</span>] = frame</span><br><span class="line">store[<span class="string">&#x27;obj1_col&#x27;</span>] = frame[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">store</span><br></pre></td></tr></table></figure>

<ul>
<li><p>包含在HDF5文件中的对象可以用字典型API进行检索</p>
</li>
<li><p>HDFStore支持两种存储模式，’fixed’和’table’（后者更慢，但支持一种特殊语法的查询操作）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># put是store [&#x27;obj2&#x27;]=frame方法的显式版本，但允许我们设置其他选项，如存储格式</span></span><br><span class="line">store.put(<span class="string">&#x27;obj2&#x27;</span>, frame, <span class="built_in">format</span>=<span class="string">&#x27;table&#x27;</span>)</span><br><span class="line">store.select(<span class="string">&#x27;obj2&#x27;</span>, where=[<span class="string">&#x27;index &gt;= 10 and index &lt;= 15&#x27;</span>])</span><br><span class="line">store.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p>pandas.read_hdf函数可以用作快捷方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame.to_hdf(<span class="string">&#x27;mydata.h5&#x27;</span>, <span class="string">&#x27;obj3&#x27;</span>, <span class="built_in">format</span>=<span class="string">&#x27;table&#x27;</span>)</span><br><span class="line">pd.read_hdf(<span class="string">&#x27;mydata.h5&#x27;</span>, <span class="string">&#x27;obj3&#x27;</span>, where=[<span class="string">&#x27;index &lt; 5&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>处理远程服务器上的数据时，使用专门为分布式存储而设计的二进制格式更为合适，比如Apache Parquet（<a href="http://parquet.apache.org)./">http://parquet.apache.org）。</a></p>
</li>
<li><p>处理大量本地数据时，尝试使用PyTables和h5py。</p>
</li>
<li><p>很多数据分析的困难在于I&#x2F;O密集（而不是CPU密集），使用类似HDF5可以加速</p>
</li>
</ul>
<blockquote>
<p>HDF5并不是数据库，它是一种适合一次写入多次读取的数据集.</p>
<p>多个写入者持续写入，文件可能会损坏</p>
</blockquote>
<p><strong>读取Microsoft Excel文件</strong></p>
<blockquote>
<p>pandas也支持通过ExcelFile类或pandas.read_excel函数来读取存储在Excel表格型数据</p>
<p>使用附加包xlrd和openpyxl来分别读取XLS和XLSX文件的</p>
</blockquote>
<ul>
<li><p>通过将xls或xlsx的路径传入ExcelFile，生成一个实例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xlsx = pd.ExcelFile(<span class="string">&#x27;examples/ex1.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>表格数据可以通过pandas.read_excel读取到DataFrame中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_excel(xlsx, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>含有多个表的文件，生成ExcelFile更快，但也可以更简便地将文件名传入pandas.read_excel</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = pd.read_excel(<span class="string">&#x27;examples/ex1.xlsx&#x27;</span>, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line">frame</span><br></pre></td></tr></table></figure>
</li>
<li><p>将pandas数据写入到Excel格式中</p>
<ul>
<li>先生成一个ExcelWriter</li>
<li>使用pandas对象的to_excel方法将数据写入</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">writer = pd.ExcelWriter(<span class="string">&#x27;examples/ex2.xlsx&#x27;</span>)</span><br><span class="line">frame.to_excel(writer, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line">writer.save()</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以将文件路径传给to_excel，避免直接调用ExcelWriter</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame.to_excel(<span class="string">&#x27;examples/ex2.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-3-与Web-API交互"><a href="#6-3-与Web-API交互" class="headerlink" title="6.3 与Web API交互"></a>6.3 与Web API交互</h2><blockquote>
<p>使用requests包（<a href="http://docs.python-requests.orgt)与web/">http://docs.python-requests.orgt）与Web</a> API交互更简单</p>
</blockquote>
<p>获取GitHub上最新的30条关于pandas的问题</p>
<ul>
<li><p>用附加库requests发送一个HTTP GET请求</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&#x27;https://api.github.com/repos/pandas-dev/pandas/issues&#x27;</span></span><br><span class="line">resp = requests.get(url)</span><br><span class="line">resp</span><br></pre></td></tr></table></figure>
</li>
<li><p>Response（响应）对象的json方法将返回一个包含解析为本地Python对象的JSON的字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># data中的每个元素都是一个包含GitHub问题页面上的所有数据的字典（注释除外）</span></span><br><span class="line">data = resp.json()</span><br><span class="line">data[<span class="number">0</span>][<span class="string">&#x27;title&#x27;</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>将data直接传给DataFrame，并提取感兴趣的字段</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">issues = pd.DataFrame(data, columns=[<span class="string">&#x27;number&#x27;</span>, <span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">                                     <span class="string">&#x27;labels&#x27;</span>, <span class="string">&#x27;state&#x27;</span>])</span><br><span class="line">issues</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-4-与数据库交互"><a href="#6-4-与数据库交互" class="headerlink" title="6.4 与数据库交互"></a>6.4 与数据库交互</h2><blockquote>
<p>业务场景中，基于SQL的关系型数据库（例如SQL Server、PostgreSQL和MySQL）使用广泛</p>
<p>pandas很多函数可以从SQL中将数据读取为DataFrame</p>
<p>SQLAlchemy项目（<a href="http://www.sqlalchemy.org/%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B5%81%E8%A1%8C%E7%9A%84PythonSQL%E5%B7%A5%E5%85%B7%E5%8C%85%EF%BC%8C%E6%8A%BD%E8%B1%A1%E5%8E%BB%E9%99%A4%E4%BA%86SQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E9%97%B4%E7%9A%84%E8%AE%B8%E5%A4%9A%E5%B8%B8%E8%A7%81%E5%B7%AE%E5%BC%82%E3%80%82">http://www.sqlalchemy.org/）是一个流行的PythonSQL工具包，抽象去除了SQL数据库之间的许多常见差异。</a></p>
</blockquote>
<ul>
<li><p>使用Python内建的<strong>sqlite3</strong>驱动来生成一个<strong>SQLite数据库</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line">query = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">CREATE TABLE test</span></span><br><span class="line"><span class="string">(a VARCHAR(20), b VARCHAR(20),</span></span><br><span class="line"><span class="string"> c REAL,        d INTEGER</span></span><br><span class="line"><span class="string">);&quot;&quot;&quot;</span></span><br><span class="line">con = sqlite3.connect(<span class="string">&#x27;mydata.sqlite&#x27;</span>)</span><br><span class="line">con.execute(query)</span><br><span class="line">con.commit()</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入几行数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [(<span class="string">&#x27;Atlanta&#x27;</span>, <span class="string">&#x27;Georgia&#x27;</span>, <span class="number">1.25</span>, <span class="number">6</span>),</span><br><span class="line">        (<span class="string">&#x27;Tallahassee&#x27;</span>, <span class="string">&#x27;Florida&#x27;</span>, <span class="number">2.6</span>, <span class="number">3</span>),</span><br><span class="line">        (<span class="string">&#x27;Sacramento&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="number">1.7</span>, <span class="number">5</span>)]</span><br><span class="line">stmt = <span class="string">&quot;INSERT INTO test VALUES(?, ?, ?, ?)&quot;</span></span><br><span class="line">con.executemany(stmt, data)</span><br><span class="line">con.commit()</span><br></pre></td></tr></table></figure>
</li>
<li><p>大部分Python的SQL驱动（PyODBC、psycopg2、MySQLdb、pymssql等）返回的是元组的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cursor = con.execute(<span class="string">&#x27;select * from test&#x27;</span>)</span><br><span class="line">rows = cursor.fetchall()</span><br><span class="line">rows</span><br></pre></td></tr></table></figure>
</li>
<li><p>将元组的列表传给DataFrame构造函数,要包含在游标的description属性中的列名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cursor.description</span><br><span class="line">pd.DataFrame(rows, columns=[x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> cursor.description])</span><br></pre></td></tr></table></figure>
</li>
<li><p>pandas中read_sql函数可以从通用的SQLAlchemy连接中轻松地读取数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用SQLAlchemy连接到相同的SQLite数据库，并从之前创建的表中读取数据</span></span><br><span class="line"><span class="keyword">import</span> sqlalchemy <span class="keyword">as</span> sqla</span><br><span class="line">db = sqla.create_engine(<span class="string">&#x27;sqlite:///mydata.sqlite&#x27;</span>)</span><br><span class="line">pd.read_sql(<span class="string">&#x27;select * from test&#x27;</span>, db)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>机器学习： 数据分析</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>四、Numpy基础：数组与向量化计算——《利用Python进行数据分析》</title>
    <url>/2022/03/28/%E5%9B%9B%E3%80%81Numpy%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%8E%E5%90%91%E9%87%8F%E5%8C%96%E8%AE%A1%E7%AE%97%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/</url>
    <content><![CDATA[<h1 id="第四章-NumPy基础：数组与向量化计算"><a href="#第四章-NumPy基础：数组与向量化计算" class="headerlink" title="第四章 NumPy基础：数组与向量化计算"></a>第四章 NumPy基础：数组与向量化计算</h1><ul>
<li>NumPy，是Numerical Python的简称，是目前Python数值计算中最重要的基础包，其数组对象作为数据交换的通用语</li>
<li>主要内容<ul>
<li>ndarray，一种高效多维数组，提供了基于数组的便捷算术操作以及灵活的广播功能。</li>
<li>对所有数据进行快速的矩阵计算，而无须编写循环程序。</li>
<li>对硬盘中数组数据进行读写的工具，并对内存映射文件进行操作。</li>
<li>线性代数、随机数生成以及傅里叶变换功能。</li>
<li>用于连接NumPy到C、C++和FORTRAN语言类库的C语言API。</li>
</ul>
</li>
<li>NumPy处理数组数据非常有效<ul>
<li>NumPy在内部将数据存储在连续的内存块上</li>
<li>NumPy可以针对全量数组进行复杂计算而不需要写Python循环</li>
</ul>
</li>
</ul>
<h2 id="4-1-NumPy-ndarray：多维数组对象"><a href="#4-1-NumPy-ndarray：多维数组对象" class="headerlink" title="4.1 NumPy ndarray：多维数组对象"></a>4.1 NumPy ndarray：多维数组对象</h2><ul>
<li>ndarray是一个通用的多维同类数据容器，包含的每一个元素均为相同类型<ul>
<li>shape属性：数组每一维度的数量</li>
<li>dtype属性：数据的类型</li>
</ul>
</li>
</ul>
<p><strong>生成ndarray</strong></p>
<ul>
<li><p>array函数：接收任意的序列型对象，也包括其他数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data1 = [<span class="number">6</span>,<span class="number">7.5</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">arr1 = np.array(data1)</span><br><span class="line">arr1  <span class="comment"># array([6. , 7.5, 8. , 0. , 1. ])</span></span><br><span class="line">data2 = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line">arr2 = np.array(data2)</span><br><span class="line">arr2</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[1, 2, 3, 4],</span></span><br><span class="line"><span class="string">       [5, 6, 7, 8]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">arr2.ndim <span class="comment"># 2</span></span><br><span class="line">arr2.shape <span class="comment"># (2, 4)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>除非显式地指定，np.array会自动推断生成数组的数据类型，数据类型被存储在特殊元数据dtype中</p>
</blockquote>
</li>
<li><p>其他方式创建数组</p>
<ul>
<li>zeros一次性创造全0数组</li>
<li>ones一次性创造全1数组</li>
<li>empty创建一个没有初始化数值的数组<ul>
<li>不要用np.empty来生成一个全0数组，有时候可能会返回未初始化的垃圾数值</li>
</ul>
</li>
<li>创建<strong>高维数组</strong>：为shape传递一个元组</li>
</ul>
</li>
<li><p>arange是Python内建函数range的数组版</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.arange(<span class="number">15</span>)</span><br><span class="line"><span class="comment"># array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>由于NumPy专注于数值计算，默认数据类型是float64</p>
</li>
<li><p>数组生成函数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220321202628260.png" alt="image-20220321202628260" style="zoom:67%;" /></li>
</ul>
<p><strong>ndarray的数据类型</strong></p>
<ul>
<li><p>数据类型<strong>dtype</strong>：元数据（表示数据的数据），一个特殊的对象，表示ndarray为某一种类型数据所申明的内存块信息</p>
</li>
<li><p>NumPy数据类型（需要在内存或硬盘上做更深入探索时需要了解）</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220321203307493.png" alt="image-20220321203307493" style="zoom:67%;" />


</li>
<li><p>使用astype方法转换数据类型</p>
<blockquote>
<p>使用astype会生成一个新的数组，与原来类型相同也会</p>
</blockquote>
<ul>
<li><p>使用astype方法显示转换    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">arr.dtype <span class="comment"># dtype(&#x27;int32&#x27;)</span></span><br><span class="line">float_arr = arr.astype(np.float64)</span><br><span class="line">float_arr.dtype <span class="comment"># dtype(&#x27;float64&#x27;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用另一个数组的dtype属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">int_array = np.arange(<span class="number">10</span>)</span><br><span class="line">calibers = np.array([<span class="number">.22</span>,<span class="number">.270</span>,<span class="number">.357</span>,<span class="number">.380</span>,<span class="number">.44</span>,<span class="number">.50</span>],dtype=np.float64)</span><br><span class="line">int_array.astype(calibers.dtype)</span><br><span class="line"><span class="comment"># array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用类型代码传入数据类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">empty_uint32 = np.empty(<span class="number">8</span>,dtype=<span class="string">&#x27;u4&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>NumPy修正numpy.string_类型作字符串的大小或删除输入时，可能不发生警告，<strong>Pandas在处理非数值数据时有更直观的开箱型操作</strong></p>
</li>
</ul>
<p><strong>NumPy数组算术</strong></p>
<ul>
<li><p>NumPy数组具有向量化特性，进行批量操作无须任何for循环。两个等尺寸数组之间的操作都应用元素操作的方式。</p>
</li>
<li><p>同尺寸数组之间比较，不同尺寸间的数组会用到广播机制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">arr2 = np.array([[<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>],[<span class="number">7</span>,<span class="number">2</span>,<span class="number">12</span>]])</span><br><span class="line">arr2 &gt; arr</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[False,  True, False],</span></span><br><span class="line"><span class="string">       [ True, False,  True]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>基础索引与切片</strong></p>
<ul>
<li><p>传数值给数组的切片，数值会被传递到整个切片</p>
</li>
<li><p>区别于Python的内建列表，<strong>数组的切片是原数组的视图</strong>，数据不是被复制，修改会体现到原数组上。（Numpy被设计处理非常大的数组，如果总是复制会引起很多内存问题）</p>
</li>
<li><p>想要拷贝不是数组视图：使用copy()方法，arr[5:8].copy()</p>
</li>
<li><p>获取元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2d[<span class="number">0</span>][<span class="number">2</span>] <span class="comment"># 3</span></span><br><span class="line">arr2d[<span class="number">0</span>,<span class="number">2</span>] <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组子集选择返回的都是视图</p>
</li>
<li><p><strong>数组的切片索引</strong></p>
<ul>
<li>多组切片</li>
<li>单独一个冒号表示选择整个轴上的数组</li>
<li>对切片表达式赋值时，整个切片都会重新赋值</li>
<li><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220321231413702.png" alt="image-20220321231413702" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
<p><strong>布尔索引</strong></p>
<ul>
<li><p>numpy.random中的randn函数生成随机正态分布数据</p>
</li>
<li><p>在索引数组时可以传入布尔值数组data[names &#x3D;&#x3D; ‘Bob’]</p>
<ul>
<li><p>布尔值数组的长度必须和数组轴索引长度一致。你甚至还可以用切片或整数值（或整数值的序列，后续会介绍）对布尔值数组进行混合和匹配</p>
</li>
<li><p>当布尔值数组的长度不正确时，不会报错，使用该特性要小心。</p>
</li>
<li><p>选择name &#x3D;&#x3D; ‘Bob’的行，并索引各列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[names == <span class="string">&#x27;Bob&#x27;</span>,<span class="number">2</span>:]</span><br><span class="line">data[names == <span class="string">&#x27;Bob&#x27;</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择除了‘Bob’以外的其他数据，可以使用!&#x3D;表达式，或者在表达式前用~取反</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name != <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">data[~(name == <span class="string">&#x27;Bob&#x27;</span>)]</span><br><span class="line"><span class="comment"># ～符号可以在你想要对一个通用条件进行取反时使用</span></span><br><span class="line">cond = names == <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">data[~cond]</span><br></pre></td></tr></table></figure>
</li>
<li><p>对多个布尔值条件进行联合，需要用&amp;和|</p>
</li>
</ul>
</li>
<li><p>用布尔值索引选择数据时，会生成数据的拷贝。</p>
</li>
<li><p>Python的关键字and和or对布尔值数组并没有用，请使用&amp;（and）和|（or）来代替。</p>
</li>
</ul>
<p><strong>神奇索引</strong></p>
<blockquote>
<p>神奇索引：NumPy中用于描述使用整数数组进行数据索引</p>
</blockquote>
<ul>
<li><p>选出符合特定顺序的子集，传递一个包含所需顺序的<strong>列表或数组</strong>来完成；使用负索引会从尾部进行</p>
</li>
<li><p>传递多个索引数组时会根据每个索引元组对应的元素选出一个<strong>一维数组</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line">arr</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">       [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="string">       [ 8,  9, 10, 11],</span></span><br><span class="line"><span class="string">       [12, 13, 14, 15],</span></span><br><span class="line"><span class="string">       [16, 17, 18, 19],</span></span><br><span class="line"><span class="string">       [20, 21, 22, 23],</span></span><br><span class="line"><span class="string">       [24, 25, 26, 27],</span></span><br><span class="line"><span class="string">       [28, 29, 30, 31]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">arr[[<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="comment"># 输出：array([ 4, 23, 29, 10])</span></span><br><span class="line"><span class="comment"># 输出的是(1,0),(5,3),(7,1),(2,2)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>神奇索引的结果总是一维的</p>
<p>神奇索引与切片不同，它会将数据复制一个新的数组</p>
</blockquote>
</li>
<li><p>通过选择矩阵中行列的子集所形成的矩形区域 用下面这种方式来完成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr[[<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>]][:,[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[ 4,  7,  5,  6],</span></span><br><span class="line"><span class="string">       [20, 23, 21, 22],</span></span><br><span class="line"><span class="string">       [28, 31, 29, 30],</span></span><br><span class="line"><span class="string">       [ 8, 11,  9, 10]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>数组转置和换轴</strong></p>
<ul>
<li><p>转置是一种特殊的数据重组形式，返回底层数据视图，无需复制</p>
</li>
<li><p>数组有transpose方法，也有特殊的T属性</p>
<ul>
<li><p>计算矩阵内积np.dot</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">6</span>,<span class="number">3</span>)</span><br><span class="line">arr</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[ 2.87744336,  0.42238688, -0.9002813 ],</span></span><br><span class="line"><span class="string">       [-0.01005598, -0.25550216, -0.44153358],</span></span><br><span class="line"><span class="string">       [-2.12971346,  0.03663679,  1.32297699],</span></span><br><span class="line"><span class="string">       [-0.19629232,  1.71053511,  0.13675151],</span></span><br><span class="line"><span class="string">       [ 1.04189789, -0.46177364,  0.52251651],</span></span><br><span class="line"><span class="string">       [-0.67053805,  0.96864843, -0.41905599]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">np.dot(arr.T,arr)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[ 2.82236803,  1.11445376, -0.67992213],</span></span><br><span class="line"><span class="string">       [ 1.11445376,  4.67568549, -2.74324947],</span></span><br><span class="line"><span class="string">       [-0.67992213, -2.74324947,  9.72932224]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>针对更高维的数组，transpose方法可以接收包含<strong>轴编号</strong>的元组，用于换轴</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">arr</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">        [ 4,  5,  6,  7]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       [[ 8,  9, 10, 11],</span></span><br><span class="line"><span class="string">        [12, 13, 14, 15]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 轴被重新排序</span></span><br><span class="line"><span class="comment"># 原先的第二个轴变为第一个，原先的第一个轴变成了第二个，最后一个轴并没有改变</span></span><br><span class="line">arr.transpose((<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">        [ 8,  9, 10, 11]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       [[ 4,  5,  6,  7],</span></span><br><span class="line"><span class="string">        [12, 13, 14, 15]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>T转置特殊案例：swapaxes方法接收一对轴编号作为参数，对轴进行调整用于重组数据(<strong>该方法返回视图，不复制</strong>)</p>
<blockquote>
<p>a.swapaxes(x,y)，是将n维数组中两个维度进行调换，其中x，y的值为a.shape值（2，3，4）元组中的索引值（下标）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">        [ 4,  5,  6,  7]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       [[ 8,  9, 10, 11],</span></span><br><span class="line"><span class="string">        [12, 13, 14, 15]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">arr.shape <span class="comment"># (2,2,4)</span></span><br><span class="line">arr.swapaxes(<span class="number">1</span>,<span class="number">2</span>).shape <span class="comment"># (2, 4, 2)</span></span><br><span class="line">arr.swapaxes(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[[ 0,  4],</span></span><br><span class="line"><span class="string">        [ 1,  5],</span></span><br><span class="line"><span class="string">        [ 2,  6],</span></span><br><span class="line"><span class="string">        [ 3,  7]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       [[ 8, 12],</span></span><br><span class="line"><span class="string">        [ 9, 13],</span></span><br><span class="line"><span class="string">        [10, 14],</span></span><br><span class="line"><span class="string">        [11, 15]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="4-2-通用函数：快速的逐元素数组函数"><a href="#4-2-通用函数：快速的逐元素数组函数" class="headerlink" title="4.2  通用函数：快速的逐元素数组函数"></a>4.2  通用函数：快速的逐元素数组函数</h2><blockquote>
<p>通用函数，ufunc，在ndarray数据中进行逐元素操作的函数，是对简单函数的向量化封装。</p>
</blockquote>
<ul>
<li><p>一元通用函数：sqrt和exp函数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_56" alt="epub_22739904_56" style="zoom:50%;" />
</li>
<li><p>二元通用函数：add和maximum，接收两个数组并返回一个数组作为结果</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_57" alt="epub_22739904_57" style="zoom: 50%;" />
</li>
<li><p>返回多个数组：比如modf，Python内建函数divmod的向量化版本，返回一个浮点值数组的小数部分和整数部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr = np.random.randn(<span class="number">7</span>) * <span class="number">5</span></span><br><span class="line">arr</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([-1.14629029,  1.38707903, -1.30572811, -4.18866457, -4.95329571,</span></span><br><span class="line"><span class="string">       -3.07819829,  2.87052789])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">remainder,whole_part = np.modf(arr)</span><br><span class="line">remainder</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([ 0.28959604,  0.54493711, -0.52703059,  0.92737401,  0.27334593,</span></span><br><span class="line"><span class="string">        0.22031531, -0.75180789])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">whole_part</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([ 6., -7., -2., -2., -0., -5.,  2.])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-3-使用数组进行面向对象数组编程"><a href="#4-3-使用数组进行面向对象数组编程" class="headerlink" title="4.3 使用数组进行面向对象数组编程"></a>4.3 使用数组进行面向对象数组编程</h2><ul>
<li>np.meshgrid函数接收两个一维数组，并根据两个数组的所有(x, y)对生成一个二维矩阵</li>
</ul>
<p><strong>将条件逻辑作为数组操作</strong></p>
<ul>
<li><p>numpy.where函数是三元表达式x if condition else y的向量化版本，不仅可以避免很多问题，速度更快。</p>
<ul>
<li><p>where的典型用法是根据一个数组来生成一个新的数组</p>
</li>
<li><p>&#96;&#96;&#96;python<br>xarr &#x3D; np.array([1.1,1.2,1.3,1.4,1.5])<br>yarr &#x3D; np.array([2.1,2.2,2.3,2.4,2.5])<br>cond &#x3D; np.array([True,False,True,True,False])<br>result &#x3D; [(x if c else y) for x,y,c in zip(xarr,yarr,cond)]<br>result # [1.1, 2.2, 1.3, 1.4, 2.5]</p>
<h1 id="使用np-where方法"><a href="#使用np-where方法" class="headerlink" title="使用np.where方法"></a>使用np.where方法</h1><p>result &#x3D; np.where(cond,xarr,yarr)<br>result # array([1.1, 2.2, 1.3, 1.4, 2.5])</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 传递给np.where的数组既可以是同等大小的数组，也可以是标量</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  # 将arr中所有正值替换为常数2</span><br><span class="line">  arr = np.random.randn(4,4)</span><br><span class="line">  np.where(arr&gt;2,2,arr)</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  array([[-1.54828495, -0.11515345,  0.64979016, 1.1025353],</span><br><span class="line">         [ 1.26570479, -0.38811792, -0.05638353, -0.23453037],</span><br><span class="line">         [ 0.26468309, -0.33101883, -0.30085075, -1.63699033],</span><br><span class="line">         [-0.5281036 ,  0.9839786 ,  0.64820938,  0.92989919]])</span><br><span class="line">  &quot;&quot;&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>数学和统计学方法</strong></p>
<ul>
<li><p>聚合函数：sum、mean和std</p>
<ul>
<li><p>可选参数axis：计算给定轴向上的统计值，形成下降一维度的数组</p>
<ul>
<li>arr.mean(1)表示“计算每一列的平均值”</li>
<li>arr.sum(0)表示“计算行轴向的累和”</li>
</ul>
</li>
<li><p>cumsum和cumprod不会聚合，产生一个中间结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line">arr</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[0, 1, 2],</span></span><br><span class="line"><span class="string">       [3, 4, 5],</span></span><br><span class="line"><span class="string">       [6, 7, 8]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">arr.cumsum(axis=<span class="number">0</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[ 0,  1,  2],</span></span><br><span class="line"><span class="string">       [ 3,  5,  7],</span></span><br><span class="line"><span class="string">       [ 9, 12, 15]], dtype=int32)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">arr.cumprod(axis=<span class="number">1</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[  0,   0,   0],</span></span><br><span class="line"><span class="string">       [  3,  12,  60],</span></span><br><span class="line"><span class="string">       [  6,  42, 336]], dtype=int32)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>基础数组统计方法</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_59" alt="img" style="zoom:50%;" /></li>
</ul>
<p><strong>布尔值数组的方法</strong></p>
<ul>
<li><p>any和all：any检查数组中是否至少有一个True，all检查是否每个值都是True</p>
<blockquote>
<p>也适用于非布尔值数组，所有的非0元素都是True</p>
</blockquote>
</li>
</ul>
<p><strong>排序</strong></p>
<ul>
<li>和Python内建列表相似，使用sort方法按位置排序<ul>
<li>在多维数组中传递axis值，沿着轴向对一个维度数据进行排序</li>
<li>顶层np.sort方法返回排好序的<strong>数组拷贝</strong></li>
</ul>
</li>
</ul>
<p><strong>唯一值与其他集合逻辑</strong></p>
<ul>
<li><p>NumPy包含一些针对一维ndarray的基础集合操作</p>
<ul>
<li><p>常用方法np.unique：返回数组中唯一值排序后形成的数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = np.array([<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Joe&#x27;</span>,<span class="string">&#x27;Will&#x27;</span>,<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Will&#x27;</span>,<span class="string">&#x27;Joe&#x27;</span>,<span class="string">&#x27;Joe&#x27;</span>])</span><br><span class="line">np.unique(names)</span><br><span class="line"><span class="comment"># array([&#x27;Bob&#x27;, &#x27;Joe&#x27;, &#x27;Will&#x27;], dtype=&#x27;&lt;U4&#x27;)</span></span><br><span class="line"><span class="comment"># 纯Python实现</span></span><br><span class="line"><span class="built_in">sorted</span>(<span class="built_in">set</span>(names)) <span class="comment"># [&#x27;Bob&#x27;, &#x27;Joe&#x27;, &#x27;Will&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>np.in1d：检查一个数组中的值是否在另外一个数组中，返回一个<strong>布尔值数组</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">values = np.array([<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">np.in1d(values,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>])</span><br><span class="line"><span class="comment"># array([ True, False, False,  True,  True, False,  True])</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>NumPy中集合函数的列表</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_60" alt="epub_22739904_60" style="zoom:50%;" /></li>
</ul>
<h2 id="4-4-使用数组进行文件输入和输出"><a href="#4-4-使用数组进行文件输入和输出" class="headerlink" title="4.4 使用数组进行文件输入和输出"></a>4.4 使用数组进行文件输入和输出</h2><ul>
<li><p>读取表格数据更多使用pandas</p>
</li>
<li><p>np.save和np.load是两大工具函数，默认以未压缩格式进行存储，后缀名是.npy</p>
</li>
<li><p>操作代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">np.save(<span class="string">&#x27;some_array&#x27;</span>,arr) <span class="comment"># .npy后缀名会被自动加上</span></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">np.load(<span class="string">&#x27;some_array.npy&#x27;</span>)</span><br><span class="line"><span class="comment"># array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br><span class="line"><span class="comment"># 用np.savez并将数组作为参数传递给该函数，用于在未压缩文件中保存多个数组</span></span><br><span class="line">np.savez(<span class="string">&#x27;array_archive.npz&#x27;</span>,a=arr,b=arr)</span><br><span class="line"><span class="comment"># 载入一个．npy文件，获得字典型对象，可以方便地载入单个数组</span></span><br><span class="line">arch = np.load(<span class="string">&#x27;array_archive.npz&#x27;</span>)</span><br><span class="line">arch[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="comment"># array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br><span class="line"><span class="comment"># 用numpy.savez_compressed将数据存入已经压缩的文件</span></span><br><span class="line">np.savez_compressed(<span class="string">&#x27;arrays_compressed.npz&#x27;</span>, a=arr, b=arr)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-5-线性代数"><a href="#4-5-线性代数" class="headerlink" title="4.5 线性代数"></a>4.5 线性代数</h2><ul>
<li><p>和Matlab等相比，NumPy的*是矩阵的逐元素乘积，而不是矩阵的点乘积</p>
</li>
<li><p>NumPy的数组方法和numpy命名空间中都有一个函数dot，用于矩阵的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">y = np.array([[<span class="number">6</span>,<span class="number">23</span>],[-<span class="number">1</span>,<span class="number">7</span>],[<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line"><span class="comment"># 下面两个函数结果相同</span></span><br><span class="line">x.dot(y)</span><br><span class="line">np.dot(x,y)</span><br><span class="line"><span class="comment"># 特殊符号@也作为中缀操作符，用于点乘矩阵操作</span></span><br><span class="line">np.ones(<span class="number">3</span>) <span class="comment"># array([1., 1., 1.])</span></span><br><span class="line">x @ np.ones(<span class="number">3</span>) <span class="comment"># array([ 6., 15.])</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>numpy.linalg</strong></p>
<ul>
<li><p>umpy.linalg拥有一个矩阵分解的标准函数集，以及其他常用函数，例如求逆和行列式求解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv,qr</span><br><span class="line">X = np.random.randn(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment"># X和它的转置矩阵X.T的点乘积</span></span><br><span class="line">mat = X.T.dot(X)</span><br><span class="line">inv(mat)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[ 0.68887032, -0.10901956,  1.11151606, -0.34320821, -0.03279823],</span></span><br><span class="line"><span class="string">       [-0.10901956,  0.2706275 ,  0.14261334,  0.00853147,  0.11737419],</span></span><br><span class="line"><span class="string">       [ 1.11151606,  0.14261334,  4.19833265, -1.61815629,  0.41947259],</span></span><br><span class="line"><span class="string">       [-0.34320821,  0.00853147, -1.61815629,  1.06411834, -0.21598402],</span></span><br><span class="line"><span class="string">       [-0.03279823,  0.11737419,  0.41947259, -0.21598402,  0.20790649]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">mat.dot(inv(mat))</span><br><span class="line">q,r = qr(mat)</span><br><span class="line">r</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[-5.07518215, -1.18301817,  1.8596161 ,  3.73253357,  5.72862095],</span></span><br><span class="line"><span class="string">       [ 0.        , -1.4987164 ,  2.27029981,  0.47419322,  2.88815351],</span></span><br><span class="line"><span class="string">       [ 0.        ,  0.        , -3.40688982, -1.45302848, -4.59955239],</span></span><br><span class="line"><span class="string">       [ 0.        ,  0.        ,  0.        , -0.56543743, -0.04838235],</span></span><br><span class="line"><span class="string">       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.97738804]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>常用的numpy.linalg函数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_61" alt="img" style="zoom:50%;" /></li>
</ul>
<h2 id="4-6-伪随机数生成"><a href="#4-6-伪随机数生成" class="headerlink" title="4.6 伪随机数生成"></a>4.6 伪随机数生成</h2><ul>
<li><p>Python内建的random模块一次只能生成一个值，numpy.random模块填补了这项不足，可以高效地生成多种概率分布下的完整样本值数组。</p>
<ul>
<li><p>生成的是<strong>伪随机数</strong>：因为它们是由具有确定性行为的算法根据随机数生成器中的随机数种子生成的</p>
</li>
<li><p>np.random.seed更改NumPy的随机数种子：<code>np.random.seed(1234)</code></p>
</li>
<li><p>numpy.random中的数据生成函数公用了一个全局的随机数种子，为了避免全局状态，可以使用<code>numpy.random.RandomState</code>生成一个随机数生成器，独立于其他的随机状态</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">1234</span>)</span><br><span class="line">rng.randn(<span class="number">10</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([ 0.47143516, -1.19097569,  1.43270697, -0.3126519 , -0.72058873,</span></span><br><span class="line"><span class="string">        0.88716294,  0.85958841, -0.6365235 ,  0.01569637, -2.24268495])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>numpy.random中的部分函数列表</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_62" alt="epub_22739904_62" style="zoom:50%;" /></li>
</ul>
<h2 id="4-7-示例：随机漫步"><a href="#4-7-示例：随机漫步" class="headerlink" title="4.7 示例：随机漫步"></a>4.7 示例：随机漫步</h2><ul>
<li><p>使用np.random模块随机漫步</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nsteps = <span class="number">1000</span></span><br><span class="line">draws = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,size=nsteps)</span><br><span class="line">steps = np.where(draws &gt; <span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line">walk = steps.cumsum()</span><br><span class="line"><span class="comment"># 统计漫步数据</span></span><br><span class="line">walk.<span class="built_in">min</span>() <span class="comment"># -28</span></span><br><span class="line"><span class="comment"># walk.max() # 23</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>找到第一次在某个方向连续走了10步的位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># np.abs(walk) &gt;= 10返回一个布尔值数组，表示是否连续在同一个方向走了10步</span></span><br><span class="line"><span class="comment"># argmax返回布尔值数组中最大值的第一个位置（True就是最大值）</span></span><br><span class="line"><span class="comment"># argmax效率不高，因为它总是完整的扫描整个数组</span></span><br><span class="line">(np.<span class="built_in">abs</span>(walk) &gt;= <span class="number">10</span>).argmax() <span class="comment"># 387</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>一次性模拟多次随机漫步</strong></p>
<ul>
<li><p>二维的抽取数组，一次性地跨行算出全部5,000个随机步的累积和</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nwalks = <span class="number">5000</span></span><br><span class="line">nsteps = <span class="number">1000</span></span><br><span class="line">draws = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,size=(nwalks,nsteps))</span><br><span class="line">steps = np.where(draws&gt;<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line">walks = steps.cumsum(<span class="number">1</span>)</span><br><span class="line">walks</span><br></pre></td></tr></table></figure>
</li>
<li><p>随机步中计算出30或-30的最小穿越时间</p>
<ul>
<li><p>any方法检查</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hits30 = (np.<span class="built_in">abs</span>(walks)&gt;=<span class="number">30</span>).<span class="built_in">any</span>(<span class="number">1</span>)</span><br><span class="line">hits30 <span class="comment"># array([False,  True,  True, ...,  True, False,  True])</span></span><br><span class="line">hits30.<span class="built_in">sum</span>() <span class="comment"># 达到30或-30的数字 3367</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用布尔值数组选出绝对步数超过30步所在的行，使用argmx从轴向1上获取穿越时间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">crossing_times = (np.<span class="built_in">abs</span>(walks[hits30])&gt;=<span class="number">30</span>).argmax(<span class="number">1</span>)</span><br><span class="line">crossing_times.mean()</span><br><span class="line"><span class="comment"># 508.3691713691714</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习： 数据分析</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>安装R语言环境和生物信息学包</title>
    <url>/2022/04/23/%E5%AE%89%E8%A3%85R%E8%AF%AD%E8%A8%80%E5%92%8C%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%8C%85/</url>
    <content><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>进入R语言官网：<a href="https://www.r-project.org/">R: The R Project for Statistical Computing (r-project.org)</a></p>
<p>点击download R</p>
<img src="https://cdn.jsdelivr.net/gh/tang-colorful/Images/Images/image-20220423094715316.png" alt="image-20220423094715316" style="zoom:50%;" />

<span id="more"></span>

<p>向下滚动找到中文版，选择清华镜像进行下载</p>
<img src="https://cdn.jsdelivr.net/gh/tang-colorful/Images/Images/image-20220423094906772.png" alt="image-20220423094906772" style="zoom: 33%;" />

<p>进行一系列适合自己电脑系统的选择</p>
<img src="https://cdn.jsdelivr.net/gh/tang-colorful/Images/Images/%E4%B8%8B%E8%BD%BDR%E8%AF%AD%E8%A8%80.png" alt="下载R语言" style="zoom: 50%;" />

<h1 id="安装R"><a href="#安装R" class="headerlink" title="安装R"></a>安装R</h1><p>将下载得到的文件移动到相应文件夹下，我的路径为：D:\Application\R</p>
<blockquote>
<p>安装路径最好为全英文，且中间不要用空格存在，这可能会影响到后续编程</p>
<p>最好不要安装在C盘下</p>
</blockquote>
<p>双击文件进行安装</p>
<img src="https://cdn.jsdelivr.net/gh/tang-colorful/Images/Images/image-20220423101352724.png" alt="image-20220423101352724" style="zoom: 67%;" />

<p>需要注意安装文件路径的问题</p>
<img src="https://cdn.jsdelivr.net/gh/tang-colorful/Images/Images/Snipaste_2022-04-23_10-11-08.png" alt="Snipaste_2022-04-23_10-11-08" style="zoom: 67%;" />

<p>安装成功后桌面会出现R语言快捷方式图标<img src="https://cdn.jsdelivr.net/gh/tang-colorful/Images/Images/image-20220423104231373.png" alt="image-20220423104231373" style="zoom:50%;" /></p>
<h1 id="安装生物信息学包"><a href="#安装生物信息学包" class="headerlink" title="安装生物信息学包"></a>安装生物信息学包</h1><blockquote>
<p>不需要本部分功能直接跳过</p>
</blockquote>
<h2 id="一般包的安装方法"><a href="#一般包的安装方法" class="headerlink" title="一般包的安装方法"></a>一般包的安装方法</h2><p>安装pheatmap包：输入语句：<code>install.packages(&quot;pheatmap&quot;)</code></p>
<p>选择兰州大学镜像，速度较快</p>
<img src="https://cdn.jsdelivr.net/gh/tang-colorful/Images/Images/%E9%95%9C%E5%83%8F.png" alt="镜像" style="zoom:50%;" />

<p>安装成功界面</p>
<img src="https://cdn.jsdelivr.net/gh/tang-colorful/Images/Images/%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" alt="安装成功" style="zoom: 50%;" />

<h2 id="安装bioconductor包"><a href="#安装bioconductor包" class="headerlink" title="安装bioconductor包"></a>安装bioconductor包</h2><p>有一些使用普通方法找不到的包，它可能包含在bioconductor中，可以利用bioconductor来安装，例如:limma</p>
<img src="https://cdn.jsdelivr.net/gh/tang-colorful/Images/Images/image-20220423105154194.png" alt="image-20220423105154194" style="zoom: 67%;" />

<p>搜索安装方式</p>
<img src="https://cdn.jsdelivr.net/gh/tang-colorful/Images/Images/image-20220423105441126.png" alt="image-20220423105441126" style="zoom: 50%;" />

<p>下滑网页，会给出对应的安装方式，复制代码到R中安装即可</p>
<img src="https://cdn.jsdelivr.net/gh/tang-colorful/Images/Images/image-20220423105620116.png" alt="image-20220423105620116" style="zoom: 50%;" />

<p>在安装过程中会询问是否更新一些包，有些包更新时间会很长，选择n不更新一样可以使用；也可以按照自己需求进行选择性更新</p>
<img src="https://cdn.jsdelivr.net/gh/tang-colorful/Images/Images/image-20220423110156044.png" alt="image-20220423110156044" style="zoom:50%;" />

<p>其他包在使用过程中采用上述方式安装即可</p>
]]></content>
      <tags>
        <tag>bioinformatics</tag>
        <tag>software</tag>
      </tags>
  </entry>
</search>
