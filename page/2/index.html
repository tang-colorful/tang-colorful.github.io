<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="The Journey Is the Reward">
<meta property="og:type" content="website">
<meta property="og:title" content="TT&#39;Blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="TT&#39;Blog">
<meta property="og:description" content="The Journey Is the Reward">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="TT">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>TT'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TT'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/28/%E4%BA%94%E3%80%81Pandas%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="TT">
      <meta itemprop="description" content="The Journey Is the Reward">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/28/%E4%BA%94%E3%80%81Pandas%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" class="post-title-link" itemprop="url">五、Pandas入门——《利用Python进行数据分析》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-28 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-28T00:00:00+08:00">2022-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 19:33:54" itemprop="dateModified" datetime="2023-09-13T19:33:54+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">机器学习： 数据分析</span></a>
                </span>
            </span>

          
            <span id="/2022/03/28/%E4%BA%94%E3%80%81Pandas%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" class="post-meta-item leancloud_visitors" data-flag-title="五、Pandas入门——《利用Python进行数据分析》" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/28/%E4%BA%94%E3%80%81Pandas%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/28/%E4%BA%94%E3%80%81Pandas%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第五章-Pandas入门"><a href="#第五章-Pandas入门" class="headerlink" title="第五章 Pandas入门"></a>第五章 Pandas入门</h1><ul>
<li>pandas经常是和其他数值计算工具，比如NumPy和SciPy，以及数据可视化工具比如matplotlib一起使用。</li>
<li>pandas支持大部分NumPy的数组计算，尤其是<strong>数组函数</strong>以及没<strong>有for循环</strong>的各种数据处理。</li>
<li>pandas处理表格型或异质型数据，NumPy处理同质型的数值类数组数据</li>
<li>常用的类：Series和DataFrame</li>
</ul>
<h2 id="5-1-pandas数据结构介绍"><a href="#5-1-pandas数据结构介绍" class="headerlink" title="5.1 pandas数据结构介绍"></a>5.1 pandas数据结构介绍</h2><h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h3><ul>
<li><p>Series是一种一维的数组型对象，它包含了一个值序列，并且包含了数据标签，称为索引（index）。</p>
</li>
<li><p>默认生成索引从0到N-1（N是数据的长度），通过values属性和index属性分别获得Series对象的值和索引。</p>
</li>
<li><p>通常会创建一个索引序列，用标签标识每个数据点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">obj2 = pd.Series([<span class="number">4</span>,<span class="number">7</span>,-<span class="number">5</span>,<span class="number">3</span>],index=[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">obj2</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">d    4</span></span><br><span class="line"><span class="string">b    7</span></span><br><span class="line"><span class="string">a   -5</span></span><br><span class="line"><span class="string">c    3</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj2.index <span class="comment"># Index([&#x27;d&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;], dtype=&#x27;object&#x27;)</span></span><br><span class="line"><span class="comment"># 使用标签进行索引</span></span><br><span class="line">obj2[<span class="string">&#x27;a&#x27;</span>] <span class="comment"># -5</span></span><br><span class="line">obj2[[<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]] <span class="comment"># 包含的不是数字而是字符串，作为索引列表</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">c    3</span></span><br><span class="line"><span class="string">a   -5</span></span><br><span class="line"><span class="string">d    4</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用类似NumPy的风格操作：比如使用布尔值数组进行过滤，与标量相乘，或是应用数学函数，这些操作将保存索引值连接。</p>
</li>
<li><p>Series是一个<strong>长度固定且有序的字典</strong>，在你可能会使用字典的上下文中，也可以使用Series。</p>
</li>
<li><p>使用字典可以生成Series：<code>pd.Series(字典对象)</code></p>
<ul>
<li><p>可以将字典排序后生成Series</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sdata = &#123;<span class="string">&#x27;Ohio&#x27;</span>: <span class="number">35000</span>, <span class="string">&#x27;Texas&#x27;</span>: <span class="number">71000</span>, <span class="string">&#x27;Oregon&#x27;</span>: <span class="number">16000</span>, <span class="string">&#x27;Utah&#x27;</span>:<span class="number">5000</span>&#125;</span><br><span class="line">states = [<span class="string">&#x27;California&#x27;</span>,<span class="string">&#x27;Ohio&#x27;</span>,<span class="string">&#x27;Oregon&#x27;</span>,<span class="string">&#x27;Texas&#x27;</span>]</span><br><span class="line">obj4= pd.Series(sdata,index=states)</span><br><span class="line">obj4</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">California        NaN  # not a number pandas标记缺失值</span></span><br><span class="line"><span class="string">Ohio          35000.0</span></span><br><span class="line"><span class="string">Oregon        16000.0</span></span><br><span class="line"><span class="string">Texas         71000.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>pandas中使用isnull和notnull函数来检查缺失数据，“缺失”或“NA”表示缺失数据</p>
<ul>
<li><code>pd.isnull(obj4)</code></li>
<li><code>pd.notnull(obj4)</code></li>
<li>isnull和notnull也是Series的实例方法：<code>obj4.isnull()</code></li>
</ul>
</li>
<li><p>Series可用来在数学操作中自动对齐</p>
</li>
<li><p>Series<strong>对象自身</strong>和其<strong>索引</strong>都有name属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">obj4.name = <span class="string">&#x27;population&#x27;</span></span><br><span class="line">obj4.index.name = <span class="string">&#x27;state&#x27;</span></span><br><span class="line">obj4</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">state</span></span><br><span class="line"><span class="string">California        NaN</span></span><br><span class="line"><span class="string">Ohio          35000.0</span></span><br><span class="line"><span class="string">Oregon        16000.0</span></span><br><span class="line"><span class="string">Texas         71000.0</span></span><br><span class="line"><span class="string">Name: population, dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>改变Series的索引：按位置赋值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">41</span>]: obj</span><br><span class="line">Out[<span class="number">41</span>]:</span><br><span class="line"><span class="number">0</span>     <span class="number">4</span></span><br><span class="line"><span class="number">1</span>     <span class="number">7</span></span><br><span class="line"><span class="number">2</span>    -<span class="number">5</span></span><br><span class="line"><span class="number">3</span>     <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line">In [<span class="number">42</span>]: obj.index = [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Jeff&#x27;</span>, <span class="string">&#x27;Ryan&#x27;</span>]</span><br><span class="line">In [<span class="number">43</span>]: obj</span><br><span class="line">Out[<span class="number">43</span>]:</span><br><span class="line">Bob       <span class="number">4</span></span><br><span class="line">Steve     <span class="number">7</span></span><br><span class="line">Jeff     -<span class="number">5</span></span><br><span class="line">Ryan      <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><blockquote>
<p>DataFrame是矩阵的数据表，它包含已排序的列集合，每一列可以是不同的值类型（数值、字符串、布尔值等）。</p>
<p>DataFrame既有行索引也有列索引，它可以被视为一个共享相同索引的Series的字典。</p>
<p>分层索引是pandas中一种更为高级的数据处理特性。</p>
</blockquote>
<p><strong>构建DataFrame</strong></p>
<ul>
<li><p>利用等长度列表或NumPy数组的字典来形成DataFrame</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">&#x27;state&#x27;</span>: [<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;year&#x27;</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2003</span>],</span><br><span class="line">        <span class="string">&#x27;pop&#x27;</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>,<span class="number">3.6</span>,<span class="number">2.4</span>,<span class="number">2.9</span>,<span class="number">3.2</span>]&#125;</span><br><span class="line">frame = pd.DataFrame(data)</span><br><span class="line">frame</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">state	year	pop</span></span><br><span class="line"><span class="string">0	Ohio	2000	1.5</span></span><br><span class="line"><span class="string">1	Ohio	2001	1.7</span></span><br><span class="line"><span class="string">2	Ohio	2002	3.6</span></span><br><span class="line"><span class="string">3	Nevada	2001	2.4</span></span><br><span class="line"><span class="string">4	Nevada	2002	2.9</span></span><br><span class="line"><span class="string">5	Nevada	2003	3.2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>一些常用操作</strong></p>
<ul>
<li><p>大型DataFrame，head方法会选出头部的五行</p>
</li>
<li><p>指定列顺序后，DataFrame的列将会按照指定顺序排列；列不包含在字典中时，结果会出现缺失值</p>
</li>
<li><p>DataFrame中的一列，可以按字典型标记或属性那样检索为Series：<code>frame2[&#39;state&#39;]</code>，<code>frame2.year</code></p>
<blockquote>
<p>frame2[colunm]对于任意列名均有效，但是frame2.column只在列名是有效的Python变量名时有效</p>
</blockquote>
<ul>
<li>返回的Series与原DataFrame有相同的索引，且Series的name属性也会被合理地设置。</li>
<li>通过位置或特殊属性loc进行选取：<code>frame2.loc[&#39;three&#39;]</code></li>
</ul>
</li>
<li><p>列的引用是可以修改的，例如，空的’debt’列可以赋值为标量值或值数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frame2[<span class="string">&#x27;debt&#x27;</span>] = <span class="number">16.5</span></span><br><span class="line">frame2[<span class="string">&#x27;debt&#x27;</span>] = np.arange(<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>将列表或数组赋值给一个列时，值的长度必须和DataFrame的长度相匹配</p>
</li>
<li><p>将Series赋值给一列时，Series的索引将会按照DataFrame的索引重新排列，并在空缺的地方填充缺失值</p>
</li>
<li><p>如果被赋值的列并不存在，则会生成一个新的列</p>
</li>
<li><p>del关键字可以删除DataFrame列（像在字典中）</p>
</li>
<li><p>向DataFrame中增加一列</p>
<ul>
<li>&#96;&#96;&#96;python<h1 id="增加一列布尔值，判断条件是state是否为’ohio’"><a href="#增加一列布尔值，判断条件是state是否为’ohio’" class="headerlink" title="增加一列布尔值，判断条件是state是否为’ohio’"></a>增加一列布尔值，判断条件是state是否为’ohio’</h1>frame2[‘eastern’] &#x3D; frame2.state &#x3D;&#x3D; ‘Ohio’<h1 id="注意：-frame2-eastern的语法无法创建新的列"><a href="#注意：-frame2-eastern的语法无法创建新的列" class="headerlink" title="注意： frame2.eastern的语法无法创建新的列"></a>注意： frame2.eastern的语法无法创建新的列</h1><h1 id="del移除之前新建的列"><a href="#del移除之前新建的列" class="headerlink" title="del移除之前新建的列"></a>del移除之前新建的列</h1>del frame2[‘eastern’]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &gt; 从DataFrame中选取的列是数据的视图，而不是拷贝</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 对Series的修改会映射到DataFrame中，需要复制显示使用Series的copy方法</span><br><span class="line"></span><br><span class="line">**包含字典的嵌套字典**</span><br><span class="line"></span><br><span class="line">- 将嵌套字典赋值给DataFrame，Pandas会将字典的键作为列，将内部字典的键作为行索引</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  pop = &#123;&#x27;Nevada&#x27;: &#123;2001: 2.4, 2002: 2.9&#125;, &#x27;Ohio&#x27;: &#123;2000: 1.5,2001:1.7,2002:3.6&#125;&#125;</span><br><span class="line">  frame3 = pd.DataFrame(pop)</span><br><span class="line">  frame3</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  	Nevada	Ohio</span><br><span class="line">  2001	2.4	1.7</span><br><span class="line">  2002	2.9	3.6</span><br><span class="line">  2000	NaN	1.5</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  # 使用类似NumPy语法进行转置操作</span><br><span class="line">  frame3.T</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  2001	2002	2000</span><br><span class="line">  Nevada	2.4	2.9	NaN</span><br><span class="line">  Ohio	1.7	3.6	1.5</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  # 显示指明索引，内部字典的键不会排序</span><br><span class="line">  pd.DataFrame(pop,index=[2001,2002,2003])</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  Nevada	Ohio</span><br><span class="line">  2001	2.4	1.7</span><br><span class="line">  2002	2.9	3.6</span><br><span class="line">  2003	NaN	NaN</span><br><span class="line">  &quot;&quot;&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>DataFrame构造函数的有效输入</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_69" alt="img" style="zoom: 50%;" />
</li>
<li><p>DataFrame的索引和列拥有name属性，则这些name属性也会被显示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">frame3.index.name=<span class="string">&#x27;year&#x27;</span></span><br><span class="line">frame3.columns.name = <span class="string">&#x27;state&#x27;</span></span><br><span class="line">frame3</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">state	Nevada	Ohio</span></span><br><span class="line"><span class="string">year		</span></span><br><span class="line"><span class="string">2001	2.4	1.7</span></span><br><span class="line"><span class="string">2002	2.9	3.6</span></span><br><span class="line"><span class="string">2000	NaN	1.5</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>DataFrame的values属性会将包含在DataFrame中的数据以<strong>二维ndarray</strong>的形式返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frame3.values</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[2.4, 1.7],</span></span><br><span class="line"><span class="string">       [2.9, 3.6],</span></span><br><span class="line"><span class="string">       [nan, 1.5]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>DataFrame的列是不同的dtypes，则values的dtype会自动选择适合所有列的类型</p>
</blockquote>
</li>
</ul>
<h3 id="索引对象"><a href="#索引对象" class="headerlink" title="索引对象"></a>索引对象</h3><blockquote>
<p>用于存储轴标签和其他元数据的（例如轴名称或标签）</p>
<p>构造Series或DataFrame时，你所使用的任意数组或标签序列都可以转换为索引对象</p>
</blockquote>
<ul>
<li><p>索引对象不可修改，分享更为安全</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series(<span class="built_in">range</span>(<span class="number">3</span>),index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">index = obj.index</span><br><span class="line">index <span class="comment"># Index([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], dtype=&#x27;object&#x27;)</span></span><br><span class="line">index[<span class="number">1</span>:] <span class="comment"># Index([&#x27;b&#x27;, &#x27;c&#x27;], dtype=&#x27;object&#x27;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>pandas索引对象是一个<strong>固定大小的集合</strong>，但是它可以<strong>包含重复标签</strong></p>
</li>
<li><p>一些索引对象的方法和属性</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_71" alt="img" style="zoom:50%;" /></li>
</ul>
<h2 id="5-2-基本功能"><a href="#5-2-基本功能" class="headerlink" title="5.2 基本功能"></a>5.2 基本功能</h2><h3 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h3><ul>
<li><p>reindex是pandas对象的重要方法，用于创建一个符合新索引的新对象，并进行排列，如果某个索引值之前并不存在，则会引入缺失值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">obj = pd.Series([<span class="number">4.5</span>,<span class="number">7.2</span>,-<span class="number">5.3</span>,<span class="number">3.6</span>],index=[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">obj</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">d    4.5</span></span><br><span class="line"><span class="string">b    7.2</span></span><br><span class="line"><span class="string">a   -5.3</span></span><br><span class="line"><span class="string">c    3.6</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj2 = obj.reindex([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">obj2</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a   -5.3</span></span><br><span class="line"><span class="string">b    7.2</span></span><br><span class="line"><span class="string">c    3.6</span></span><br><span class="line"><span class="string">d    4.5</span></span><br><span class="line"><span class="string">e    NaN #如果某个索引值之前并不存在，则会引入缺失值</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重建顺序数据（时间序列等）索引时可能需要进行插值或填值</p>
<ul>
<li><p>method可选参数可使用ffill等方法在重建索引时插值，向前填充</p>
</li>
<li><p>&#96;&#96;&#96;python<br>obj3 &#x3D; pd.Series([‘blue’,’purple’,’yellow’],index&#x3D;[0,2,4])<br>obj3<br>“””<br>0      blue<br>2    purple<br>4    yellow<br>dtype: object<br>“””<br>obj3.reindex(range(6),method&#x3D;’ffill’)<br>“””<br>0      blue<br>1      blue<br>2    purple<br>3    purple<br>4    yellow<br>5    yellow<br>dtype: object<br>“””</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**DataFrame中的reindex**</span><br><span class="line"></span><br><span class="line">- reindex可以改变行索引、列索引或同时改变二者。当仅传入一个序列时，结果中的行会重建索引</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  frame = pd.DataFrame(np.arange(9).reshape((3,3)),</span><br><span class="line">                      index=[&#x27;a&#x27;,&#x27;c&#x27;,&#x27;d&#x27;],</span><br><span class="line">                      columns=[&#x27;Ohio&#x27;,&#x27;Texas&#x27;,&#x27;California&#x27;])</span><br><span class="line">  frame</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  Ohio	Texas	California</span><br><span class="line">  a	0	1	2</span><br><span class="line">  c	3	4	5</span><br><span class="line">  d	6	7	8</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  frame2 = frame.reindex([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;])</span><br><span class="line">  frame2</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  Ohio	Texas	California</span><br><span class="line">  a	0.0	1.0	2.0</span><br><span class="line">  b	NaN	NaN	NaN</span><br><span class="line">  c	3.0	4.0	5.0</span><br><span class="line">  d	6.0	7.0	8.0</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  # 列可以使用columns关键字重建索引</span><br><span class="line">  states = [&#x27;Texas&#x27;,&#x27;Utah&#x27;,&#x27;Califormia&#x27;]</span><br><span class="line">  frame.reindex(columns=states)</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  	Texas	Utah	Califormia</span><br><span class="line">  a	1	NaN	NaN</span><br><span class="line">  c	4	NaN	NaN</span><br><span class="line">  d	7	NaN	NaN</span><br><span class="line">  &quot;&quot;&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>reindex的<strong>index</strong>参数：新建作为索引的序列，可以是索引实例或任意其他序列型Python数据结构，索引使用时无须复制</p>
</li>
</ul>
<h3 id="轴向上删除条目"><a href="#轴向上删除条目" class="headerlink" title="轴向上删除条目"></a>轴向上删除条目</h3><ul>
<li><p>drop方法会返回一个含有指示值或轴向上删除值的新对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series(np.arange(<span class="number">5.</span>),index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">obj</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    0.0</span></span><br><span class="line"><span class="string">b    1.0</span></span><br><span class="line"><span class="string">c    2.0</span></span><br><span class="line"><span class="string">d    3.0</span></span><br><span class="line"><span class="string">e    4.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj.drop([<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    0.0</span></span><br><span class="line"><span class="string">b    1.0</span></span><br><span class="line"><span class="string">e    4.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>DataFrame中的drop</strong></p>
<ul>
<li><p>调用drop时默认删除行标签（轴0）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),</span><br><span class="line">                    index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>],</span><br><span class="line">                    columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line">data</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	one	two	three	four</span></span><br><span class="line"><span class="string">Ohio	0	1	2	3</span></span><br><span class="line"><span class="string">Colorado	4	5	6	7</span></span><br><span class="line"><span class="string">Utah	8	9	10	11</span></span><br><span class="line"><span class="string">New York	12	13	14	15</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">data.drop([<span class="string">&#x27;Colorado&#x27;</span>,<span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">one	two	three	four</span></span><br><span class="line"><span class="string">Utah	8	9	10	11</span></span><br><span class="line"><span class="string">New York	12	13	14	15</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 传递axis=1或axis=&#x27;columns’来从列中删除值</span></span><br><span class="line">data.drop(<span class="string">&#x27;two&#x27;</span>,axis=<span class="number">1</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">one	three	four</span></span><br><span class="line"><span class="string">Ohio	0	2	3</span></span><br><span class="line"><span class="string">Colorado	4	6	7</span></span><br><span class="line"><span class="string">Utah	8	10	11</span></span><br><span class="line"><span class="string">New York	12	14	15</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>drop，会修改Series或DataFrame的尺寸或形状；直接操作原对象而不是返回新对象</p>
</li>
<li><p>【注意】inplace属性：会清除被删除的数据：<code>obj.drop(‘c’,inplace=True)</code></p>
</li>
</ul>
<h3 id="索引、选择与过滤"><a href="#索引、选择与过滤" class="headerlink" title="索引、选择与过滤"></a>索引、选择与过滤</h3><ul>
<li><p>Series的索引与NumPy数组类似，但是不仅可以索引整数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series(np.arange(<span class="number">4.</span>),index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">obj</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    0.0</span></span><br><span class="line"><span class="string">b    1.0</span></span><br><span class="line"><span class="string">c    2.0</span></span><br><span class="line"><span class="string">d    3.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj[<span class="string">&#x27;b&#x27;</span>] <span class="comment"># 1.0</span></span><br><span class="line">obj[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">c    2.0</span></span><br><span class="line"><span class="string">d    3.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj[[<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b    1.0</span></span><br><span class="line"><span class="string">a    0.0</span></span><br><span class="line"><span class="string">d    3.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj[[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b    1.0</span></span><br><span class="line"><span class="string">d    3.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj[obj&lt;<span class="number">2</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    0.0</span></span><br><span class="line"><span class="string">b    1.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Series切片（不同于Python切片）</p>
<ul>
<li>使用切片修改值会修改Series的相应部分：<code>obj[‘b’ : ‘c’]</code></li>
<li>使用单个值或序列，可以从DataFrame中索引出一个或多个列</li>
<li>可根据布尔值数组切片选择数据<ul>
<li><code>data[:2]</code> # 选前两行</li>
<li><code>data[data[‘three’]&gt;5]</code></li>
</ul>
</li>
</ul>
</li>
<li><p>使用布尔值DataFrame进行索引，可以和标量比较产生</p>
<ul>
<li><code>data &lt; 5</code> (data是DataFrame类型)</li>
<li><code>data[data&lt;5] = 0</code> （小于5的数赋值为0）</li>
</ul>
</li>
</ul>
<p><strong>使用loc和iloc选择数据</strong></p>
<blockquote>
<p>DataFrame允许你使用轴标签（loc）或整数标签（iloc）以NumPy风格的语法从DataFrame中选出数组的行和列的子集</p>
</blockquote>
<ul>
<li><p>示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data.loc[<span class="string">&#x27;Colorado&#x27;</span>,[<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>]]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">two      5</span></span><br><span class="line"><span class="string">three    6</span></span><br><span class="line"><span class="string">Name: Colorado, dtype: int32</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 整数标签iloc进行类似的数据选择</span></span><br><span class="line">data.iloc[<span class="number">2</span>,[<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">four    11</span></span><br><span class="line"><span class="string">one      8</span></span><br><span class="line"><span class="string">two      9</span></span><br><span class="line"><span class="string">Name: Utah, dtype: int32</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>所以用于切片</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data.loc[:<span class="string">&#x27;Utah&#x27;</span>,<span class="string">&#x27;two&#x27;</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Ohio        1</span></span><br><span class="line"><span class="string">Colorado    5</span></span><br><span class="line"><span class="string">Utah        9</span></span><br><span class="line"><span class="string">Name: two, dtype: int32</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">data.iloc[:,:<span class="number">3</span>][data.three &gt;<span class="number">5</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">one	two	three</span></span><br><span class="line"><span class="string">Colorado	4	5	6</span></span><br><span class="line"><span class="string">Utah	8	9	10</span></span><br><span class="line"><span class="string">New York	12	13	14</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>DataFrame索引选项</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_74" alt="epub_22739904_74" style="zoom:50%;" /></li>
</ul>
<h3 id="整数索引"><a href="#整数索引" class="headerlink" title="整数索引"></a>整数索引</h3><ul>
<li><p>在pandas对象上使用整数索引会产生歧义，非整数索引不会有潜在的歧义</p>
</li>
<li><p>使用<strong>loc</strong>（用于标签）或<strong>iloc</strong>（用于整数）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ser = pd.Series(np.arange(<span class="number">3.</span>))</span><br><span class="line">ser</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0    0.0</span></span><br><span class="line"><span class="string">1    1.0</span></span><br><span class="line"><span class="string">2    2.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">ser[:<span class="number">1</span>] </span><br><span class="line"><span class="comment"># 0    0.0</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br><span class="line">ser.loc[:<span class="number">1</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0    0.0</span></span><br><span class="line"><span class="string">1    1.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">ser.iloc[:<span class="number">1</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0    0.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="算术和数据对齐"><a href="#算术和数据对齐" class="headerlink" title="算术和数据对齐"></a>算术和数据对齐</h3><ul>
<li><p>对象相加时，索引对不相同，返回结果的索引将是索引对的<strong>并集</strong>，类似于数据库的<strong>自动外连接（Outer join）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s1 = pd.Series([<span class="number">7.3</span>,-<span class="number">2.5</span>,<span class="number">3.4</span>,<span class="number">1.5</span>],index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">s2 = pd.Series([-<span class="number">2.1</span>,<span class="number">3.6</span>,-<span class="number">1.5</span>,<span class="number">4</span>,<span class="number">3.1</span>],index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>])</span><br><span class="line">s1 +s2</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    5.2</span></span><br><span class="line"><span class="string">c    1.1</span></span><br><span class="line"><span class="string">d    NaN</span></span><br><span class="line"><span class="string">e    0.0</span></span><br><span class="line"><span class="string">f    NaN</span></span><br><span class="line"><span class="string">g    NaN</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将DataFrame对象加在一起，返回一个DataFrame，它的索引、列是每个DataFrame的索引、列的并集。</p>
<ul>
<li>两个行或列完全不同的DataFrame对象相加，结果将全部为空</li>
</ul>
</li>
</ul>
<p><strong>使用填充值的算术方法</strong></p>
<ul>
<li><p>两个DataFrame对象相加时，一些不重叠的位置会出现NA值，举例：填充0：<code>df1.add(df2,fill_value=0)</code></p>
</li>
<li><p>灵活算术方法</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_75" alt="epub_22739904_75" style="zoom:50%;" />

<p>以r开头的副本方法的参数是翻转的，1&#x2F;df1和df1.rdiv(1)等价</p>
</li>
</ul>
<p><strong>DataFrame和Series间的操作</strong></p>
<blockquote>
<p>和NumPy中不同维度数组间的操作类似</p>
</blockquote>
<ul>
<li><p>考虑二维数组和其中一行的区别，<strong>广播机制</strong>：减法在每一行都进行了操作（<strong>对列进行匹配，并广播到各行</strong>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">arr[<span class="number">0</span>] <span class="comment"># array([0., 1., 2., 3.])</span></span><br><span class="line">arr - arr[<span class="number">0</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">       [4., 4., 4., 4.],</span></span><br><span class="line"><span class="string">       [8., 8., 8., 8.]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在列上进行广播，在行上匹配，必须使用算术方法的一种：<code>frame.sub(series3,axis=‘index’)</code>，使用axis&#x3D;‘index’或axis&#x3D;0</p>
</li>
</ul>
<h3 id="函数应用和映射"><a href="#函数应用和映射" class="headerlink" title="函数应用和映射"></a>函数应用和映射</h3><ul>
<li><p>NumPy的通用函数（逐元素数组方法）对pandas对象也有效：<code>np.abs(frame)</code></p>
</li>
<li><p>DataFrame的apply方法将函数应用到<strong>一行或一列（默认）</strong>的一维数组上</p>
<ul>
<li><p>举例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(np.random.randn(<span class="number">4</span>,<span class="number">3</span>),columns=<span class="built_in">list</span>(<span class="string">&#x27;bde&#x27;</span>),</span><br><span class="line">                    index=[<span class="string">&#x27;Utah&#x27;</span>,<span class="string">&#x27;Ohio&#x27;</span>,<span class="string">&#x27;Texas&#x27;</span>,<span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"><span class="comment"># 函数f，可以计算Series最大值和最小值的差，会被frame中的每一列调用一次</span></span><br><span class="line"><span class="comment"># 结果是一个以frame的列作为索引的Series</span></span><br><span class="line">f =  <span class="keyword">lambda</span> x:x.<span class="built_in">max</span>() - x.<span class="built_in">min</span>()</span><br><span class="line">frame.apply(f)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b    3.071398</span></span><br><span class="line"><span class="string">d    2.095664</span></span><br><span class="line"><span class="string">e    2.016091</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 函数每行被调用一次</span></span><br><span class="line">frame.apply(f,axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Utah      2.410035</span></span><br><span class="line"><span class="string">Ohio      0.303477</span></span><br><span class="line"><span class="string">Texas     0.808933</span></span><br><span class="line"><span class="string">Oregon    1.718999</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>大部分最常用的数组统计（sum和mean）都是DataFrame的方法，<strong>apply不是必需的</strong></p>
</li>
<li><p>传递给apply的不一定要返回一个标量值，也可以返回带有多个值的Series</p>
</li>
</ul>
</li>
<li><p>可以使用逐元素的Python函数，举例：根据frame总的每个浮点数计算一个格式化字符串，可以使用<strong>applymap</strong>方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">format</span> = <span class="keyword">lambda</span> x: <span class="string">&#x27;%.2f&#x27;</span> % x</span><br><span class="line">frame.applymap(<span class="built_in">format</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b	d	e</span></span><br><span class="line"><span class="string">Utah	-0.86	1.53	0.19</span></span><br><span class="line"><span class="string">Ohio	0.25	0.46	-1.16</span></span><br><span class="line"><span class="string">Texas	-0.59	-0.60	-1.08</span></span><br><span class="line"><span class="string">Oregon	-1.09	0.36	-0.19</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>用applymap作为函数名是因为Series有map方法</p>
<p>将逐元素应用到Series上：frame[‘e’].map(format)</p>
</blockquote>
</li>
</ul>
<h3 id="排序和排名"><a href="#排序和排名" class="headerlink" title="排序和排名"></a>排序和排名</h3><p><strong>排序</strong></p>
<ul>
<li>按行或列索引进行字典型排序，使用<strong>sort_index</strong>方法，返回一个新的、排序好的对象<ul>
<li>默认升序，也可以降序排序：ascending&#x3D;False</li>
<li>对DataFrame进行排序时，使用一列或多列作为排序键，通过给<strong>sort_values的可选参数by</strong>实现<ul>
<li><code>frame.sort_values(by=‘b’)</code></li>
<li><code>frame.sort_values(by = [‘a’,’b])</code></li>
</ul>
</li>
</ul>
</li>
<li>使用<strong>sort_values</strong>方法根据Series的值进行排序<ul>
<li>默认所有的缺失值都会被排序至Series的尾部</li>
</ul>
</li>
</ul>
<p><strong>排名</strong></p>
<blockquote>
<p>排名是指对数组从1到有效数据点总数分配名次的操作</p>
</blockquote>
<ul>
<li><p>Series和DataFrame的<strong>rank方法</strong>是实现排名的方法。</p>
<ul>
<li><p>默认通过平均排名分配到每个组来打破平级关系。</p>
</li>
<li><p>也可以根据他们在数据中的观察顺序进行分配</p>
<ul>
<li>对条目0和2设置的名次为6和7，而不是之前的平均排名6.5，是因为在数据中标签0在标签2的前面。</li>
</ul>
</li>
<li><p>按降序排名：<code>obj.rank(ascending=False,method=‘max’)</code></p>
</li>
<li><p>排名中的平级关系打破方法</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_76" alt="img" style="zoom:50%;" />
</li>
<li><p>DataFrame可以对行或列计算排名：frame.rank(axis &#x3D; ‘columns’)</p>
</li>
</ul>
</li>
</ul>
<h3 id="含有重复标签的轴索引"><a href="#含有重复标签的轴索引" class="headerlink" title="含有重复标签的轴索引"></a>含有重复标签的轴索引</h3><ul>
<li><p>轴索引并不是强制唯一性，但pandas函数（比如reindex）需要的标签是唯一的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series(<span class="built_in">range</span>(<span class="number">5</span>),index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">obj</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    0</span></span><br><span class="line"><span class="string">a    1</span></span><br><span class="line"><span class="string">b    2</span></span><br><span class="line"><span class="string">b    3</span></span><br><span class="line"><span class="string">c    4</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>索引的is_unique属性：标签是否唯一</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.index.is_unique <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有重复索引时，标签索引多个条目会返回一个<strong>序列</strong>，单个条目会返回<strong>标量值</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    0</span></span><br><span class="line"><span class="string">a    1</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj[<span class="string">&#x27;c&#x27;</span>] <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重复索引会使代码更复杂，因为来自索引的输出类型可能因标签是否重复而有所不同</p>
</li>
</ul>
</li>
</ul>
<h2 id="5-3-描述性统计的概述与计算"><a href="#5-3-描述性统计的概述与计算" class="headerlink" title="5.3 描述性统计的概述与计算"></a>5.3 描述性统计的概述与计算</h2><ul>
<li><p>Pandas对象封装了常用数学、统计学方法的集合，大部分属于<strong>规约或汇总统计</strong>的类别。</p>
<ul>
<li><p>从DataFrame的行或列中抽取一个Series或一系列值的单个值（如总和或平均值）</p>
</li>
<li><p>内建了处理缺失值的功能</p>
</li>
<li><p>传入axis&#x3D;’columns’或axis&#x3D;1，则会将<strong>一行上各个列</strong>的值相加：<code>df.sum(axis=‘columns’)</code></p>
</li>
<li><p>NA值会被自动排除（除非全都是），可以通过禁用skipna来实现不排除NA值</p>
</li>
<li><p>规约方法可选参数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_77" alt="img" style="zoom:50%;" />
</li>
<li><p>有一些方法返回间接统计信息：比如最小值或最大值的索引值：比如idxmin和idxmax</p>
</li>
</ul>
</li>
<li><p>积累型方法：<code>df.cumsum()</code></p>
</li>
<li><p>describe方法：<strong>一次产生多个汇总统计</strong>，既不是规约方法也不是积累型方法。</p>
<ul>
<li>describe方法也可以描述非数值型数据</li>
</ul>
</li>
<li><p>描述性统计和汇总统计方法</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_78" alt="img" style="zoom:50%;" /></li>
</ul>
<h3 id="相关性和协方差"><a href="#相关性和协方差" class="headerlink" title="相关性和协方差"></a>相关性和协方差</h3><ul>
<li>Series的corr方法计算的是两个Series中重叠的、非NA的、按索引对齐的值的相关性。相应地，cov计算的是协方差。<ul>
<li><code>returns[‘MSFT’].corr(returns[‘IBM’])</code></li>
<li><code>returns.MSFT.corr(returns.IBM)</code>，MSFT是一个有效的Python属性</li>
<li>以DataFrame的形式返回相关性和协方差矩阵</li>
</ul>
</li>
<li>DataFrame的<strong>corrwith方法</strong>：DataFrame中的行或列与另一个序列或DataFrame的相关性<ul>
<li>传入一个Series时，会返回一个含有为每列计算相关性值的Series</li>
<li>传入一个DataFrame时，会计算匹配到列名的相关性数值</li>
<li>传入axis&#x3D;’columns’会逐行地进行计算</li>
</ul>
</li>
</ul>
<h3 id="唯一值、计数和成员属性"><a href="#唯一值、计数和成员属性" class="headerlink" title="唯一值、计数和成员属性"></a>唯一值、计数和成员属性</h3><blockquote>
<p>另一类相关的方法可以从一维Series包含的数值中提取信息</p>
</blockquote>
<ul>
<li><p>unique：给出Series中的唯一值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">obj = pd.Series([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">uniques = obj.unique()</span><br><span class="line">uniques <span class="comment"># array([&#x27;c&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;b&#x27;], dtype=object)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>排序：<code>uniques.sort()</code></li>
</ul>
</li>
<li><p>计算Series包含值的个数：<code>value_counts()</code></p>
<ul>
<li>按照数量降序排序：<code>pd.value_counts(obj.values,sort=False)</code></li>
</ul>
</li>
<li><p>isin执行向量化的成员属性检查，将数据集以Series或DataFrame一列的形式过滤为数据集的值子集。</p>
<ul>
<li><p>示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">obj</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0    c</span></span><br><span class="line"><span class="string">1    a</span></span><br><span class="line"><span class="string">2    d</span></span><br><span class="line"><span class="string">3    a</span></span><br><span class="line"><span class="string">4    a</span></span><br><span class="line"><span class="string">5    b</span></span><br><span class="line"><span class="string">6    b</span></span><br><span class="line"><span class="string">7    c</span></span><br><span class="line"><span class="string">8    c</span></span><br><span class="line"><span class="string">dtype: object</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">mask = obj.isin([<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">mask</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0     True</span></span><br><span class="line"><span class="string">1    False</span></span><br><span class="line"><span class="string">2    False</span></span><br><span class="line"><span class="string">3    False</span></span><br><span class="line"><span class="string">4    False</span></span><br><span class="line"><span class="string">5     True</span></span><br><span class="line"><span class="string">6     True</span></span><br><span class="line"><span class="string">7     True</span></span><br><span class="line"><span class="string">8     True</span></span><br><span class="line"><span class="string">dtype: bool</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">obj[mask]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0    c</span></span><br><span class="line"><span class="string">5    b</span></span><br><span class="line"><span class="string">6    b</span></span><br><span class="line"><span class="string">7    c</span></span><br><span class="line"><span class="string">8    c</span></span><br><span class="line"><span class="string">dtype: object</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>isin相关的Index.get_indexer方法：提供一个索引数组可以将可能非唯一值数组转换为另一个唯一值数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">to_match = pd.Series([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">unique_vals = pd.Series([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">pd.Index(unique_vals).get_indexer(to_match)</span><br><span class="line"><span class="comment"># array([0, 2, 1, 1, 0, 2], dtype=int64)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>唯一值、计数和集合成员属性方法</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_80" alt="img" style="zoom:50%;" />
</li>
<li><p>计算DataFrame多个相关列的直方图</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="无标题" style="zoom:50%;" />

<p>这里，结果中的行标签是所有列中出现的不同值，数值则是这些不同值在每个列中出现的次数。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/28/%E4%BA%8C%E3%80%81Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E3%80%81IPython%E5%8F%8AJupytermotebook%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="TT">
      <meta itemprop="description" content="The Journey Is the Reward">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/28/%E4%BA%8C%E3%80%81Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E3%80%81IPython%E5%8F%8AJupytermotebook%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" class="post-title-link" itemprop="url">二、Python语言基础、IPython及Jupytermotebook——《利用Python进行数据分析》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-28 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-28T00:00:00+08:00">2022-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 19:28:38" itemprop="dateModified" datetime="2023-09-13T19:28:38+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">机器学习： 数据分析</span></a>
                </span>
            </span>

          
            <span id="/2022/03/28/%E4%BA%8C%E3%80%81Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E3%80%81IPython%E5%8F%8AJupytermotebook%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" class="post-meta-item leancloud_visitors" data-flag-title="二、Python语言基础、IPython及Jupytermotebook——《利用Python进行数据分析》" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/28/%E4%BA%8C%E3%80%81Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E3%80%81IPython%E5%8F%8AJupytermotebook%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/28/%E4%BA%8C%E3%80%81Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E3%80%81IPython%E5%8F%8AJupytermotebook%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第二章-Python语言基础、IPython及Jupyternotebook"><a href="#第二章-Python语言基础、IPython及Jupyternotebook" class="headerlink" title="第二章 Python语言基础、IPython及Jupyternotebook"></a>第二章 Python语言基础、IPython及Jupyternotebook</h1><p>推荐使用IPython命令行和Jupyter notebook来实验代码示例，以及探索各种类型、函数和方法的文档。</p>
<p>和其他键盘控制的命令行环境一样，练就常用命令的肌肉记忆也是学习曲线的一部分。</p>
<p><strong>优秀Python书籍推荐</strong></p>
<ul>
<li>《Python Cookbook》（第3版），作者为David Beazley和Brian K.Jones（O’Reilly）</li>
<li>《Fluent Python》，作者为Luciano Ramalho（O’Reilly）</li>
<li>《Fluent Python》，作者为Luciano Ramalho（O’Reilly）</li>
</ul>
<h2 id="2-1-Python解释器"><a href="#2-1-Python解释器" class="headerlink" title="2.1 Python解释器"></a>2.1 Python解释器</h2><ul>
<li><p>标准的交互式Python解释器可以通过在命令行输入python命令来启动</p>
</li>
<li><p>在命令行中看到的&gt;&gt;&gt;提示符是你键入代码的地方</p>
</li>
<li><p>退出Python解释器回到命令行提示符，可以输入exit()或者按下Ctrl-D</p>
</li>
<li><p>运行Python文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python hello_world.py</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用%run命令，IPython会在同一个进程内执行指定文件中的代码，可以立即看到结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In[1]:%run hello_world.py</span><br><span class="line">Hello world</span><br><span class="line">In[2]:  #IPython默认提示符用类似In[2]风格，而不是&gt;&gt;&gt;提示符</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-2-IPython基础"><a href="#2-2-IPython基础" class="headerlink" title="2.2 IPython基础"></a>2.2 IPython基础</h2><p><strong>运行IPython命令行</strong></p>
<ul>
<li>输入ipython命令启动IPython命令行</li>
<li>在IPython中仅输入一个变量名，会返回一个表示该对象的字符串</li>
</ul>
<p><strong>运行Jupyter notebook</strong></p>
<ul>
<li><p>Python的Jupyter内核使用IPython系统进行内部活动</p>
</li>
<li><p>启动Jupyter时，在终端中运行jupyter notebook命令</p>
</li>
<li><p>在很多平台上，Jupyter会自动打开你的默认网络浏览器（除非你使用了–no-browser命令），也可以通过http地址来浏览notebook，地址是<a target="_blank" rel="noopener" href="http://localhost:8888/">http://localhost:8888/</a></p>
</li>
<li><p>Jupyter可以部署在服务器远端</p>
</li>
</ul>
<p><strong>Tab补全</strong></p>
<ul>
<li><p>IPython的提升之一就是tab补全功能，当在命令行输入表达式时，按下Tab键即可为任意变量（对象、函数等）搜索命名空间，与你目前已输入的字符进行匹配</p>
</li>
<li><p>在输入英文的句号之后，按下tab，对方法、属性的名称进行补全，模块也可以通过相同的方式补全。</p>
</li>
<li><blockquote>
<p>在Jupyter notebook和新版的IPython（5.0及以上）中，自动补全是在下拉选项中展现，而不是文本输出。</p>
<p>IPython默认情况下隐藏了以下划线开始的方法和属性，诸如魔术方法、内部“私有”方法和属性，以避免杂乱的显示（使新手混淆）。先输入下划线也可以在tab补全时找到它们。想要直接看到，要修改IPython配置。</p>
</blockquote>
</li>
<li><p>当输入任意路径（甚至是Python字符串）时，按下Tab键将补全你的计算机文件系统中匹配你输入内容的值，与%run命令搭配使用，该功能将为你节省大量键盘输入。</p>
</li>
<li><p>tab补全可以在函数的关键字参数（包含&#x3D;号）中节约时间</p>
</li>
</ul>
<p><strong>内省</strong></p>
<ul>
<li><p>在一个变量名的前后使用问号（?）可以显示一些关于该对象的概要信息</p>
</li>
<li><p>如果对象是一个函数或实例方法且文档字符串已经写好，则文档字符串会显示出来。</p>
</li>
<li><p>使用双问号？？可以显示函数的源代码</p>
</li>
<li><p>？的终极用途：把一些字符和通配符（星号*）结合在一起，会显示所有匹配通配符表达式的命名。</p>
<figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">13</span>]:np.*load*?</span><br><span class="line">np.__loader__</span><br><span class="line">np.load</span><br><span class="line">np.loads</span><br><span class="line">np.loadtxt</span><br><span class="line">np.pkgload</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>%run命令</strong></p>
<ul>
<li><p>在IPython会话中使用%run命令运行任意的Python程序文件，这个行为与在命令行中使用python script.py来运行程序相同。文件中定义的所有变量（导入的、函数中的、全局定义的）在运行后，可以在IPython命令行中使用（除非出现某种异常）。</p>
</li>
<li><p>一个Python脚本需要命令行提供参数（通过sys.argv获得）</p>
</li>
<li><blockquote>
<p>如果你想让待运行的脚本使用交互式IPython命名空间中已有的变量，请使用%run -i替代普通的%run命令。</p>
</blockquote>
</li>
<li><p>在Jupyter notebook中，使用%load魔术函数将脚本导入一个代码单元</p>
</li>
</ul>
<p><strong>中断运行中的代码</strong></p>
<ul>
<li><p>在任意代码运行时按下Ctrl-C，都将引起KeyboardInterrupt，Python程序会立即停止运行。</p>
</li>
<li><blockquote>
<p> 当一段Python代码被其他已经编译的扩展模块调用时，按下Ctrl-C并不会让程序立即停止运行。在这些情况下，你需要等到控制流重新返回Python解释器，在更糟糕的情况下可能要强制结束Python进程。</p>
</blockquote>
</li>
</ul>
<p><strong>执行剪贴板中的程序</strong></p>
<ul>
<li>%paste和%cpaste魔术函数<ul>
<li>%paste会获得剪贴板中的所有文本，并在命令行中作为一个代码块去执行</li>
<li>%cpaste与之类似，只不过它会给出一个特殊的提示符，让你粘贴代码</li>
<li>如果你发现粘贴的代码有误，可以按下Ctrl-C来中断%cpaste提示符</li>
</ul>
</li>
</ul>
<p><strong>终端快捷键</strong></p>
<ul>
<li><p>IPython快捷键</p>
<ul>
<li><p>标准IPython快捷键</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220315151517435.png" alt="image-20220315151517435" style="zoom:80%;" />
</li>
<li><p>Ipython命令行的部分快捷键</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220315151539406.png" alt="image-20220315151539406" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>Jupyter Notebook有一个独立的快捷键集合用于导航和编辑，快捷键的更新比IPython更为频繁，可以在菜单栏中的帮助系统进行学习。</p>
</li>
</ul>
<p><strong>关于魔术命令</strong></p>
<ul>
<li><p>IPython的特殊命令（没有内建到Python自身中去）被称为“魔术”命令，前缀符号为%，例如使用%timeit来检查Python语句的执行时间。</p>
</li>
<li><p>魔术命令可以看作是IPython系统内部的命令行程序，大多数魔术命令可以使用？查看额外的“命令行”选项。</p>
</li>
<li><p>魔术函数也可以不加百分号%就使用，只要没有变量被定义为与魔术函数相同的名字即可。这种特性被称为自动魔术，通过%automagic进行启用&#x2F;禁用关。</p>
</li>
<li><p>一些魔术函数也像Python函数一样，其输出可以赋给一个变量。</p>
</li>
<li><p>建议使用%quickref或者%magic探索所有的特殊命令</p>
</li>
<li><p>一些常用的魔术命令</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220315151616242.png" alt="image-20220315151616242" style="zoom:80%;" /></li>
</ul>
<p><strong>matplotlib集成</strong></p>
<ul>
<li><p>%matplotlib魔术函数可以设置matplotlib与IPython命令行或Jupyter notebook的集成。</p>
</li>
<li><p>IPython命令行，运行%matplotlib命令生成多个绘图窗口，而不干扰控制台的会话</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In[26]:%matplotlib</span><br><span class="line">Using matplotlib backend:Qt4Agg</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Jupyter中，命令会有不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In[26]:%matplotlib inline</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-3-Python语言基础"><a href="#2-3-Python语言基础" class="headerlink" title="2.3 Python语言基础"></a>2.3 Python语言基础</h2><h3 id="语言语义"><a href="#语言语义" class="headerlink" title="语言语义"></a>语言语义</h3><p><strong>缩进，而不是大括号</strong></p>
<ul>
<li>一个冒号代表一个缩进代码块的开始，单个代码块要保持相同的缩进，直到代码块结束</li>
<li>使用四个空格来缩进</li>
<li>Python语句不以分号结尾，但可以用于在一行内进行多条语句之间的分隔，但是一行有多条语句，代码可读性会变差</li>
</ul>
<p><strong>一切皆为对象</strong></p>
<ul>
<li>每一个数值、字符串、数据结构、函数、类、模块以及所有存在于Python解释器中的事物，都是Python对象。</li>
</ul>
<p><strong>注释</strong></p>
<ul>
<li>“#”用来注释</li>
</ul>
<p><strong>函数和对象方法的调用</strong></p>
<ul>
<li>几乎所有的Python对象都有内部函数，称为方法，可以访问到对象内部的内容</li>
<li>函数传参既可以是位置参数也可以是关键字参数</li>
</ul>
<p><strong>变量和参数传递</strong></p>
<ul>
<li><p>在Python中对一个变量（或者变量名）赋值时，你就创建了一个指向等号右边对象的引用</p>
</li>
<li><p>&#96;&#96;&#96;python<br>In[8]:a&#x3D;[1,2,3]<br>In[9]:b&#x3D;a   #此时a和b指向同一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &gt; 赋值也被称为绑定，这是因为我们将一个变量名绑定到了一个对象上。已被赋值的变量名有时也会被称为被绑定变量</span><br><span class="line"></span><br><span class="line">- 可以更换可变参数的内部值</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  In[27]:data=[1,2,3]</span><br><span class="line">  In[28]:append_element(data,4)</span><br><span class="line">  In[29]:data</span><br><span class="line">  Out[29]:[1,2,3,4]</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>动态引用，强类型</strong></p>
<ul>
<li><p>变量对于对象来说只是特定命名空间中的名称；类型信息是存储在对象自身之中的</p>
</li>
<li><p>Python被认为是强类型语言，这意味着所有的对象都拥有一个指定的类型（或类），隐式的转换只在某些特定、明显的情况下发生</p>
</li>
<li><p>可以使用isinstance函数来检查一个对象是否是特定类型的实例，它也接受包含一个类型的元组，可以检查对象的类型是否在元组的类型中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">21</span>]:a=<span class="number">5</span></span><br><span class="line">In[<span class="number">22</span>]:<span class="built_in">isinstance</span>(a,<span class="built_in">int</span>)</span><br><span class="line">Out[<span class="number">22</span>]:<span class="literal">True</span></span><br><span class="line">In[<span class="number">23</span>]:a=<span class="number">5</span>;b=<span class="number">4.5</span></span><br><span class="line">In[<span class="number">24</span>]:<span class="built_in">isinstance</span>(a,(<span class="built_in">int</span>,<span class="built_in">float</span>))</span><br><span class="line">Out[<span class="number">24</span>]:<span class="literal">True</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>属性和方法</strong></p>
<ul>
<li><p>属性和方法可以用obj.attribute_name进行调用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: a = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: a.&lt;Press Tab&gt;</span><br><span class="line">a.capitalize  a.<span class="built_in">format</span>      a.isupper     a.rindex      a.strip</span><br><span class="line">a.center      a.index       a.join        a.rjust       a.swapcase</span><br><span class="line">a.count       a.isalnum     a.ljust       a.rpartition  a.title</span><br><span class="line">a.decode      a.isalpha     a.lower       a.rsplit      a.translate</span><br><span class="line">a.encode      a.isdigit     a.lstrip      a.rstrip      a.upper</span><br><span class="line">a.endswith    a.islower     a.partition   a.split       a.zfill</span><br><span class="line">a.expandtabs  a.isspace     a.replace     a.splitlines</span><br><span class="line">a.find        a.istitle     a.rfind       a.startswith</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性和方法也可以通过getattr函数获得</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">27</span>]:<span class="built_in">getattr</span>(a,<span class="string">&#x27;split&#x27;</span>)</span><br><span class="line">Out[<span class="number">28</span>]:&lt;function <span class="built_in">str</span>.split&gt;</span><br></pre></td></tr></table></figure>

<p>在其他的语言中，通过变量名访问对象通常被称为“反射”,它们可以用来高效地编写通用、可复用的代码。</p>
</li>
</ul>
<p><strong>鸭子类型</strong></p>
<ul>
<li><p>“鸭子类型”的说法源于“一个东西走起来像鸭子叫起来像鸭子，那它就是鸭子”。例如，你可以验证一个对象如果实现了迭代器协议，那它一定是可以迭代的。</p>
</li>
<li><p>当一个函数接受多种输入类型时，可以使用isiterable函数。比如：写接受任意序列类型（列表、元组、n维数组），甚至是一个迭代器的函数时使用这项功能。你可以先检查对象是否是一个列表（或者一个NumPy数组），如果不是就把它转换为列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x, <span class="built_in">list</span>) <span class="keyword">and</span> isiterable(x): </span><br><span class="line">	x = <span class="built_in">list</span>(x)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>导入</strong></p>
<ul>
<li>模块：在Python中，模块就是以．py为后缀名并包含Python代码的文件。</li>
</ul>
<p><strong>二元运算符和比较运算</strong></p>
<ul>
<li><p>检查两个引用是否指向同一个对象，可以使用is关键字，不是可以用is not。</p>
</li>
<li><p>is和&#x3D;&#x3D;是不同的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">1</span>]:a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">In[<span class="number">2</span>]:c=<span class="built_in">list</span>(a)</span><br><span class="line">In[<span class="number">3</span>]:a <span class="keyword">is</span> <span class="keyword">not</span> c  <span class="comment"># list函数总是创建一个新的Python列表（即一份拷贝）</span></span><br><span class="line">Out[<span class="number">1</span>]:<span class="literal">True</span></span><br><span class="line">In[<span class="number">4</span>]:a==c</span><br><span class="line">Out[<span class="number">2</span>]:<span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>is和is not的常用之处是检查一个变量是否为None</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">1</span>]:a=<span class="literal">None</span></span><br><span class="line">In[<span class="number">2</span>]:a <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">Out[<span class="number">1</span>]:<span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>二元操作符<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220313170604994.png" alt="image-20220313170604994" style="zoom:50%;" /></p>
</li>
</ul>
<p><strong>可变对象和不可变对象</strong></p>
<ul>
<li>Python中的大部分对象，例如列表、字典、NumPy数组都是可变对象，大多数用户定义的类型（类）也是可变的。可变对象中包含的对象和值是可以被修改的。</li>
<li>字符串和元组是不可变对象。</li>
<li>修改行为会有副作用，建议使用不可变性，尽量不可变对象中也可能包含可变对象。</li>
</ul>
<h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><ul>
<li>Python的标准库中拥有一个小的内建类型集合，用来处理数值数据、字符串、布尔值（True或False）以及日期和时间。这类的“单值”类型有时被称为标量类型，我们在本书中称之为标量。</li>
<li>标准库中含有datetime模块，日期和时间的处理将单独讨论</li>
<li>标准Python标量类型        <img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220313233326774.png" alt="image-20220313233326774"></li>
</ul>
<p><strong>数值类型</strong></p>
<ul>
<li>基础的Python数字类型就是int和float，int可以存储任意大小数字，浮点数是双精度64位数值（可以用科学计数法表示）</li>
<li>整数除法结果会自动转型为浮点数</li>
<li>只保留整数部分，使用“&#x2F;&#x2F;”</li>
</ul>
<p><strong>字符串</strong></p>
<ul>
<li><p>字符串可以用单引号和双引号表示</p>
</li>
<li><p>对于含有换行的多行字符串，你可以使用三个单引号’’’或三个双引号”””</p>
</li>
<li><p>Python中字符串不可变，无法修改</p>
</li>
<li><pre><code class="python">c = &quot;&quot;&quot;
This is a longer string that
spans multiple lines
&quot;&quot;&quot;
# c中有三个回车符
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  c实际上包含了四行文本；&quot;&quot;&quot;后的换行和lines后的换行都是包含在字符串中的</span><br><span class="line"></span><br><span class="line">- Python对象可以通过str函数转成字符串</span><br><span class="line"></span><br><span class="line">- 字符串是Unicode字符的序列，因此可以被看作是除了列表和元组外的另一种序列</span><br><span class="line"></span><br><span class="line">- 转义字符：\</span><br><span class="line"></span><br><span class="line">- 加前缀符号r表示字符是原生字符(r是raw的简写，表示原生的)</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  In[1]:s = r&#x27;this\has\no\special\characters&#x27;</span><br><span class="line">  In[2]:s</span><br><span class="line">  Out[1]:&#x27;this\has\no\special\characters&#x27;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>字符串格式化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">1</span>]:template = <span class="string">&#x27;&#123;0:.2f&#125; &#123;1:s&#125; are worth US$&#123;2:d&#125;&#x27;</span></span><br><span class="line">In[<span class="number">2</span>]:template.<span class="built_in">format</span>(<span class="number">4.5560</span>, <span class="string">&#x27;Argentine Pesos&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">Out[<span class="number">1</span>]:<span class="string">&#x27;4.56 Argentine Pesos are worth US$1&#x27;</span></span><br></pre></td></tr></table></figure>

<p>字符串官方文档：<a target="_blank" rel="noopener" href="https://docs.python.org/3.6/library/string.html">https://docs.python.org/3.6/library/string.html</a></p>
</li>
</ul>
<p><strong>字节与Unicode</strong></p>
<ul>
<li><p>Python 3.0及以上,Unicode成为字符串类型的一等类，用于更好地兼容处理ASCII和非ASCII文本。以前的Unicode编码完全是字节。</p>
</li>
<li><p>使用enocde方法将这个Unicode字符串转换为UTF-8字节，decode方法进行解码。</p>
</li>
<li><p>在字符串前加前缀b来定义字符文本（用法很少）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bytes_val = <span class="string">b&#x27;this is bytes&#x27;</span></span><br><span class="line">bytes_val</span><br><span class="line">decoded = bytes_val.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">decoded  <span class="comment"># this is str (Unicode) now</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>布尔值</strong></p>
<ul>
<li>Python中的布尔值写作True和False，可以与and和or关键字合用。</li>
</ul>
<p><strong>类型转换</strong></p>
<ul>
<li>str、bool、int和float既是数据类型，同时也是可以将其他数据转换为这些类型的函数</li>
</ul>
<p><strong>None</strong></p>
<ul>
<li><p>None是Python的null值类型</p>
</li>
<li><p>如果一个函数没有显式地返回值，则它会隐式地返回None</p>
</li>
<li><p>None还可以作为一个常用的函数参数默认值</p>
</li>
<li><p>从技术角度来说，None不仅是一个关键字，它还是NoneType类型的唯一实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">1</span>]:<span class="built_in">type</span>(<span class="literal">None</span>)</span><br><span class="line">Out[<span class="number">1</span>]:NoneType</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>日期和时间</strong></p>
<ul>
<li><p>datetime模块：提供了datetime、data和time类型，包含日期和时间信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">1</span>]:<span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, date, time</span><br><span class="line">In[<span class="number">2</span>]:dt = datetime(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">21</span>)</span><br><span class="line">In[<span class="number">3</span>]:dt.day</span><br><span class="line">Out[<span class="number">1</span>]:<span class="number">29</span></span><br><span class="line">In[<span class="number">4</span>]:dt.minute</span><br><span class="line">Out[<span class="number">2</span>]:<span class="number">30</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取date和time对象：date和time方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">5</span>]:dt.date()</span><br><span class="line">Out[<span class="number">3</span>]:datetime.date(<span class="number">2011</span>,<span class="number">10</span>,<span class="number">29</span>)</span><br><span class="line">In[<span class="number">6</span>]:dt.time()</span><br><span class="line">Out[<span class="number">4</span>]:datetime.time(<span class="number">20</span>,<span class="number">30</span>,<span class="number">21</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>strftime方法将datetime转换为字符串</p>
</li>
<li><p>字符串可以通过strptime函数转换为datetime对象</p>
</li>
<li><p>使用replace替换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt.replace(minute=<span class="number">0</span>,second=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>datetime.datetime是不可变类型，以上的方法都是产生新的对象</p>
</blockquote>
</li>
<li><p>两个不同的datetime对象会产生一个datatime.timedelta类型的对象，表示时间间隔；将timedelta加到一个datetime上将产生一个新的对象。</p>
</li>
<li><p>Datetime格式化详细说明（ISO C89兼容）</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220314002530605.png" alt="image-20220314002530605" style="zoom:50%;" /></li>
</ul>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p><strong>if、elif和else</strong></p>
<ul>
<li>一个if语句可以接多个elif代码块和一个else代码块，如果所有的elif条件均为False，则执行else代码块。</li>
<li>当使用and和or进行混合条件判断时，条件判断是从左到右的并且在and或or两侧的条件会有“短路”现象</li>
<li>if中允许有链式比较</li>
</ul>
<p><strong>for循环</strong></p>
<ul>
<li>for循环用于遍历一个集合（例如列表或元组）或一个迭代器</li>
<li>使用continue关键字可以跳过conitnue后面的代码进入下一次循环</li>
<li>使用break关键字可以结束一个for循环</li>
</ul>
<blockquote>
<p>​        break关键字只结束最内层的for循环；外层的for循环会继续运行</p>
</blockquote>
<p><strong>while循环</strong></p>
<blockquote>
<ul>
<li>while循环会在条件符合时一直执行代码块，直到条件判断为False或显式地以break结尾时才结束</li>
</ul>
</blockquote>
<p><strong>pass</strong></p>
<ul>
<li>pass在Python中表示什么都不做，可以作为没有实现的代码占位符</li>
</ul>
<p><strong>range</strong></p>
<ul>
<li><p>range函数返回一个迭代器，该迭代器生成一个等差整数序列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">1</span>]:<span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">1</span>]:<span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">In[<span class="number">2</span>]:<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">Out[<span class="number">2</span>]:[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>起始、结尾、步进（可以是负的）可以传参给range函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">1</span>]:<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>,<span class="number">0</span>,-<span class="number">1</span>))</span><br><span class="line">Out[<span class="number">1</span>]:[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>range产生的整数包含起始但不包含结尾，常用于遍历序列</p>
</blockquote>
</li>
</ul>
<p><strong>三元表达式</strong></p>
<ul>
<li><p>将一个if-else代码块联合起来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = true-expr <span class="keyword">if</span> condition <span class="keyword">else</span> false-expr</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以压缩代码量，但是牺牲可读性</p>
</blockquote>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/28/%E5%9B%9B%E3%80%81Numpy%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%8E%E5%90%91%E9%87%8F%E5%8C%96%E8%AE%A1%E7%AE%97%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="TT">
      <meta itemprop="description" content="The Journey Is the Reward">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/28/%E5%9B%9B%E3%80%81Numpy%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%8E%E5%90%91%E9%87%8F%E5%8C%96%E8%AE%A1%E7%AE%97%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" class="post-title-link" itemprop="url">四、Numpy基础：数组与向量化计算——《利用Python进行数据分析》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-28 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-28T00:00:00+08:00">2022-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 19:33:37" itemprop="dateModified" datetime="2023-09-13T19:33:37+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">机器学习： 数据分析</span></a>
                </span>
            </span>

          
            <span id="/2022/03/28/%E5%9B%9B%E3%80%81Numpy%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%8E%E5%90%91%E9%87%8F%E5%8C%96%E8%AE%A1%E7%AE%97%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" class="post-meta-item leancloud_visitors" data-flag-title="四、Numpy基础：数组与向量化计算——《利用Python进行数据分析》" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/28/%E5%9B%9B%E3%80%81Numpy%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%8E%E5%90%91%E9%87%8F%E5%8C%96%E8%AE%A1%E7%AE%97%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/28/%E5%9B%9B%E3%80%81Numpy%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%8E%E5%90%91%E9%87%8F%E5%8C%96%E8%AE%A1%E7%AE%97%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第四章-NumPy基础：数组与向量化计算"><a href="#第四章-NumPy基础：数组与向量化计算" class="headerlink" title="第四章 NumPy基础：数组与向量化计算"></a>第四章 NumPy基础：数组与向量化计算</h1><ul>
<li>NumPy，是Numerical Python的简称，是目前Python数值计算中最重要的基础包，其数组对象作为数据交换的通用语</li>
<li>主要内容<ul>
<li>ndarray，一种高效多维数组，提供了基于数组的便捷算术操作以及灵活的广播功能。</li>
<li>对所有数据进行快速的矩阵计算，而无须编写循环程序。</li>
<li>对硬盘中数组数据进行读写的工具，并对内存映射文件进行操作。</li>
<li>线性代数、随机数生成以及傅里叶变换功能。</li>
<li>用于连接NumPy到C、C++和FORTRAN语言类库的C语言API。</li>
</ul>
</li>
<li>NumPy处理数组数据非常有效<ul>
<li>NumPy在内部将数据存储在连续的内存块上</li>
<li>NumPy可以针对全量数组进行复杂计算而不需要写Python循环</li>
</ul>
</li>
</ul>
<h2 id="4-1-NumPy-ndarray：多维数组对象"><a href="#4-1-NumPy-ndarray：多维数组对象" class="headerlink" title="4.1 NumPy ndarray：多维数组对象"></a>4.1 NumPy ndarray：多维数组对象</h2><ul>
<li>ndarray是一个通用的多维同类数据容器，包含的每一个元素均为相同类型<ul>
<li>shape属性：数组每一维度的数量</li>
<li>dtype属性：数据的类型</li>
</ul>
</li>
</ul>
<p><strong>生成ndarray</strong></p>
<ul>
<li><p>array函数：接收任意的序列型对象，也包括其他数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data1 = [<span class="number">6</span>,<span class="number">7.5</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">arr1 = np.array(data1)</span><br><span class="line">arr1  <span class="comment"># array([6. , 7.5, 8. , 0. , 1. ])</span></span><br><span class="line">data2 = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line">arr2 = np.array(data2)</span><br><span class="line">arr2</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[1, 2, 3, 4],</span></span><br><span class="line"><span class="string">       [5, 6, 7, 8]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">arr2.ndim <span class="comment"># 2</span></span><br><span class="line">arr2.shape <span class="comment"># (2, 4)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>除非显式地指定，np.array会自动推断生成数组的数据类型，数据类型被存储在特殊元数据dtype中</p>
</blockquote>
</li>
<li><p>其他方式创建数组</p>
<ul>
<li>zeros一次性创造全0数组</li>
<li>ones一次性创造全1数组</li>
<li>empty创建一个没有初始化数值的数组<ul>
<li>不要用np.empty来生成一个全0数组，有时候可能会返回未初始化的垃圾数值</li>
</ul>
</li>
<li>创建<strong>高维数组</strong>：为shape传递一个元组</li>
</ul>
</li>
<li><p>arange是Python内建函数range的数组版</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.arange(<span class="number">15</span>)</span><br><span class="line"><span class="comment"># array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>由于NumPy专注于数值计算，默认数据类型是float64</p>
</li>
<li><p>数组生成函数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220321202628260.png" alt="image-20220321202628260" style="zoom:67%;" /></li>
</ul>
<p><strong>ndarray的数据类型</strong></p>
<ul>
<li><p>数据类型<strong>dtype</strong>：元数据（表示数据的数据），一个特殊的对象，表示ndarray为某一种类型数据所申明的内存块信息</p>
</li>
<li><p>NumPy数据类型（需要在内存或硬盘上做更深入探索时需要了解）</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220321203307493.png" alt="image-20220321203307493" style="zoom:67%;" />


</li>
<li><p>使用astype方法转换数据类型</p>
<blockquote>
<p>使用astype会生成一个新的数组，与原来类型相同也会</p>
</blockquote>
<ul>
<li><p>使用astype方法显示转换    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">arr.dtype <span class="comment"># dtype(&#x27;int32&#x27;)</span></span><br><span class="line">float_arr = arr.astype(np.float64)</span><br><span class="line">float_arr.dtype <span class="comment"># dtype(&#x27;float64&#x27;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用另一个数组的dtype属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int_array = np.arange(<span class="number">10</span>)</span><br><span class="line">calibers = np.array([<span class="number">.22</span>,<span class="number">.270</span>,<span class="number">.357</span>,<span class="number">.380</span>,<span class="number">.44</span>,<span class="number">.50</span>],dtype=np.float64)</span><br><span class="line">int_array.astype(calibers.dtype)</span><br><span class="line"><span class="comment"># array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用类型代码传入数据类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">empty_uint32 = np.empty(<span class="number">8</span>,dtype=<span class="string">&#x27;u4&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>NumPy修正numpy.string_类型作字符串的大小或删除输入时，可能不发生警告，<strong>Pandas在处理非数值数据时有更直观的开箱型操作</strong></p>
</li>
</ul>
<p><strong>NumPy数组算术</strong></p>
<ul>
<li><p>NumPy数组具有向量化特性，进行批量操作无须任何for循环。两个等尺寸数组之间的操作都应用元素操作的方式。</p>
</li>
<li><p>同尺寸数组之间比较，不同尺寸间的数组会用到广播机制</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">arr2 = np.array([[<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>],[<span class="number">7</span>,<span class="number">2</span>,<span class="number">12</span>]])</span><br><span class="line">arr2 &gt; arr</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[False,  True, False],</span></span><br><span class="line"><span class="string">       [ True, False,  True]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>基础索引与切片</strong></p>
<ul>
<li><p>传数值给数组的切片，数值会被传递到整个切片</p>
</li>
<li><p>区别于Python的内建列表，<strong>数组的切片是原数组的视图</strong>，数据不是被复制，修改会体现到原数组上。（Numpy被设计处理非常大的数组，如果总是复制会引起很多内存问题）</p>
</li>
<li><p>想要拷贝不是数组视图：使用copy()方法，arr[5:8].copy()</p>
</li>
<li><p>获取元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr2d[<span class="number">0</span>][<span class="number">2</span>] <span class="comment"># 3</span></span><br><span class="line">arr2d[<span class="number">0</span>,<span class="number">2</span>] <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组子集选择返回的都是视图</p>
</li>
<li><p><strong>数组的切片索引</strong></p>
<ul>
<li>多组切片</li>
<li>单独一个冒号表示选择整个轴上的数组</li>
<li>对切片表达式赋值时，整个切片都会重新赋值</li>
<li><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/image-20220321231413702.png" alt="image-20220321231413702" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
<p><strong>布尔索引</strong></p>
<ul>
<li><p>numpy.random中的randn函数生成随机正态分布数据</p>
</li>
<li><p>在索引数组时可以传入布尔值数组data[names &#x3D;&#x3D; ‘Bob’]</p>
<ul>
<li><p>布尔值数组的长度必须和数组轴索引长度一致。你甚至还可以用切片或整数值（或整数值的序列，后续会介绍）对布尔值数组进行混合和匹配</p>
</li>
<li><p>当布尔值数组的长度不正确时，不会报错，使用该特性要小心。</p>
</li>
<li><p>选择name &#x3D;&#x3D; ‘Bob’的行，并索引各列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data[names == <span class="string">&#x27;Bob&#x27;</span>,<span class="number">2</span>:]</span><br><span class="line">data[names == <span class="string">&#x27;Bob&#x27;</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择除了‘Bob’以外的其他数据，可以使用!&#x3D;表达式，或者在表达式前用~取反</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name != <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">data[~(name == <span class="string">&#x27;Bob&#x27;</span>)]</span><br><span class="line"><span class="comment"># ～符号可以在你想要对一个通用条件进行取反时使用</span></span><br><span class="line">cond = names == <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">data[~cond]</span><br></pre></td></tr></table></figure>
</li>
<li><p>对多个布尔值条件进行联合，需要用&amp;和|</p>
</li>
</ul>
</li>
<li><p>用布尔值索引选择数据时，会生成数据的拷贝。</p>
</li>
<li><p>Python的关键字and和or对布尔值数组并没有用，请使用&amp;（and）和|（or）来代替。</p>
</li>
</ul>
<p><strong>神奇索引</strong></p>
<blockquote>
<p>神奇索引：NumPy中用于描述使用整数数组进行数据索引</p>
</blockquote>
<ul>
<li><p>选出符合特定顺序的子集，传递一个包含所需顺序的<strong>列表或数组</strong>来完成；使用负索引会从尾部进行</p>
</li>
<li><p>传递多个索引数组时会根据每个索引元组对应的元素选出一个<strong>一维数组</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line">arr</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">       [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="string">       [ 8,  9, 10, 11],</span></span><br><span class="line"><span class="string">       [12, 13, 14, 15],</span></span><br><span class="line"><span class="string">       [16, 17, 18, 19],</span></span><br><span class="line"><span class="string">       [20, 21, 22, 23],</span></span><br><span class="line"><span class="string">       [24, 25, 26, 27],</span></span><br><span class="line"><span class="string">       [28, 29, 30, 31]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">arr[[<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="comment"># 输出：array([ 4, 23, 29, 10])</span></span><br><span class="line"><span class="comment"># 输出的是(1,0),(5,3),(7,1),(2,2)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>神奇索引的结果总是一维的</p>
<p>神奇索引与切片不同，它会将数据复制一个新的数组</p>
</blockquote>
</li>
<li><p>通过选择矩阵中行列的子集所形成的矩形区域 用下面这种方式来完成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr[[<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>]][:,[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[ 4,  7,  5,  6],</span></span><br><span class="line"><span class="string">       [20, 23, 21, 22],</span></span><br><span class="line"><span class="string">       [28, 31, 29, 30],</span></span><br><span class="line"><span class="string">       [ 8, 11,  9, 10]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>数组转置和换轴</strong></p>
<ul>
<li><p>转置是一种特殊的数据重组形式，返回底层数据视图，无需复制</p>
</li>
<li><p>数组有transpose方法，也有特殊的T属性</p>
<ul>
<li><p>计算矩阵内积np.dot</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">6</span>,<span class="number">3</span>)</span><br><span class="line">arr</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[ 2.87744336,  0.42238688, -0.9002813 ],</span></span><br><span class="line"><span class="string">       [-0.01005598, -0.25550216, -0.44153358],</span></span><br><span class="line"><span class="string">       [-2.12971346,  0.03663679,  1.32297699],</span></span><br><span class="line"><span class="string">       [-0.19629232,  1.71053511,  0.13675151],</span></span><br><span class="line"><span class="string">       [ 1.04189789, -0.46177364,  0.52251651],</span></span><br><span class="line"><span class="string">       [-0.67053805,  0.96864843, -0.41905599]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">np.dot(arr.T,arr)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[ 2.82236803,  1.11445376, -0.67992213],</span></span><br><span class="line"><span class="string">       [ 1.11445376,  4.67568549, -2.74324947],</span></span><br><span class="line"><span class="string">       [-0.67992213, -2.74324947,  9.72932224]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>针对更高维的数组，transpose方法可以接收包含<strong>轴编号</strong>的元组，用于换轴</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">arr</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">        [ 4,  5,  6,  7]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       [[ 8,  9, 10, 11],</span></span><br><span class="line"><span class="string">        [12, 13, 14, 15]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 轴被重新排序</span></span><br><span class="line"><span class="comment"># 原先的第二个轴变为第一个，原先的第一个轴变成了第二个，最后一个轴并没有改变</span></span><br><span class="line">arr.transpose((<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">        [ 8,  9, 10, 11]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       [[ 4,  5,  6,  7],</span></span><br><span class="line"><span class="string">        [12, 13, 14, 15]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>T转置特殊案例：swapaxes方法接收一对轴编号作为参数，对轴进行调整用于重组数据(<strong>该方法返回视图，不复制</strong>)</p>
<blockquote>
<p>a.swapaxes(x,y)，是将n维数组中两个维度进行调换，其中x，y的值为a.shape值（2，3，4）元组中的索引值（下标）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">arr</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">        [ 4,  5,  6,  7]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       [[ 8,  9, 10, 11],</span></span><br><span class="line"><span class="string">        [12, 13, 14, 15]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">arr.shape <span class="comment"># (2,2,4)</span></span><br><span class="line">arr.swapaxes(<span class="number">1</span>,<span class="number">2</span>).shape <span class="comment"># (2, 4, 2)</span></span><br><span class="line">arr.swapaxes(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[[ 0,  4],</span></span><br><span class="line"><span class="string">        [ 1,  5],</span></span><br><span class="line"><span class="string">        [ 2,  6],</span></span><br><span class="line"><span class="string">        [ 3,  7]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       [[ 8, 12],</span></span><br><span class="line"><span class="string">        [ 9, 13],</span></span><br><span class="line"><span class="string">        [10, 14],</span></span><br><span class="line"><span class="string">        [11, 15]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="4-2-通用函数：快速的逐元素数组函数"><a href="#4-2-通用函数：快速的逐元素数组函数" class="headerlink" title="4.2  通用函数：快速的逐元素数组函数"></a>4.2  通用函数：快速的逐元素数组函数</h2><blockquote>
<p>通用函数，ufunc，在ndarray数据中进行逐元素操作的函数，是对简单函数的向量化封装。</p>
</blockquote>
<ul>
<li><p>一元通用函数：sqrt和exp函数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_56" alt="epub_22739904_56" style="zoom:50%;" />
</li>
<li><p>二元通用函数：add和maximum，接收两个数组并返回一个数组作为结果</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_57" alt="epub_22739904_57" style="zoom: 50%;" />
</li>
<li><p>返回多个数组：比如modf，Python内建函数divmod的向量化版本，返回一个浮点值数组的小数部分和整数部分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr = np.random.randn(<span class="number">7</span>) * <span class="number">5</span></span><br><span class="line">arr</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([-1.14629029,  1.38707903, -1.30572811, -4.18866457, -4.95329571,</span></span><br><span class="line"><span class="string">       -3.07819829,  2.87052789])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">remainder,whole_part = np.modf(arr)</span><br><span class="line">remainder</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([ 0.28959604,  0.54493711, -0.52703059,  0.92737401,  0.27334593,</span></span><br><span class="line"><span class="string">        0.22031531, -0.75180789])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">whole_part</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([ 6., -7., -2., -2., -0., -5.,  2.])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-3-使用数组进行面向对象数组编程"><a href="#4-3-使用数组进行面向对象数组编程" class="headerlink" title="4.3 使用数组进行面向对象数组编程"></a>4.3 使用数组进行面向对象数组编程</h2><ul>
<li>np.meshgrid函数接收两个一维数组，并根据两个数组的所有(x, y)对生成一个二维矩阵</li>
</ul>
<p><strong>将条件逻辑作为数组操作</strong></p>
<ul>
<li><p>numpy.where函数是三元表达式x if condition else y的向量化版本，不仅可以避免很多问题，速度更快。</p>
<ul>
<li><p>where的典型用法是根据一个数组来生成一个新的数组</p>
</li>
<li><p>&#96;&#96;&#96;python<br>xarr &#x3D; np.array([1.1,1.2,1.3,1.4,1.5])<br>yarr &#x3D; np.array([2.1,2.2,2.3,2.4,2.5])<br>cond &#x3D; np.array([True,False,True,True,False])<br>result &#x3D; [(x if c else y) for x,y,c in zip(xarr,yarr,cond)]<br>result # [1.1, 2.2, 1.3, 1.4, 2.5]</p>
<h1 id="使用np-where方法"><a href="#使用np-where方法" class="headerlink" title="使用np.where方法"></a>使用np.where方法</h1><p>result &#x3D; np.where(cond,xarr,yarr)<br>result # array([1.1, 2.2, 1.3, 1.4, 2.5])</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 传递给np.where的数组既可以是同等大小的数组，也可以是标量</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  # 将arr中所有正值替换为常数2</span><br><span class="line">  arr = np.random.randn(4,4)</span><br><span class="line">  np.where(arr&gt;2,2,arr)</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  array([[-1.54828495, -0.11515345,  0.64979016, 1.1025353],</span><br><span class="line">         [ 1.26570479, -0.38811792, -0.05638353, -0.23453037],</span><br><span class="line">         [ 0.26468309, -0.33101883, -0.30085075, -1.63699033],</span><br><span class="line">         [-0.5281036 ,  0.9839786 ,  0.64820938,  0.92989919]])</span><br><span class="line">  &quot;&quot;&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>数学和统计学方法</strong></p>
<ul>
<li><p>聚合函数：sum、mean和std</p>
<ul>
<li><p>可选参数axis：计算给定轴向上的统计值，形成下降一维度的数组</p>
<ul>
<li>arr.mean(1)表示“计算每一列的平均值”</li>
<li>arr.sum(0)表示“计算行轴向的累和”</li>
</ul>
</li>
<li><p>cumsum和cumprod不会聚合，产生一个中间结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line">arr</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[0, 1, 2],</span></span><br><span class="line"><span class="string">       [3, 4, 5],</span></span><br><span class="line"><span class="string">       [6, 7, 8]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">arr.cumsum(axis=<span class="number">0</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[ 0,  1,  2],</span></span><br><span class="line"><span class="string">       [ 3,  5,  7],</span></span><br><span class="line"><span class="string">       [ 9, 12, 15]], dtype=int32)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">arr.cumprod(axis=<span class="number">1</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[  0,   0,   0],</span></span><br><span class="line"><span class="string">       [  3,  12,  60],</span></span><br><span class="line"><span class="string">       [  6,  42, 336]], dtype=int32)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>基础数组统计方法</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_59" alt="img" style="zoom:50%;" /></li>
</ul>
<p><strong>布尔值数组的方法</strong></p>
<ul>
<li><p>any和all：any检查数组中是否至少有一个True，all检查是否每个值都是True</p>
<blockquote>
<p>也适用于非布尔值数组，所有的非0元素都是True</p>
</blockquote>
</li>
</ul>
<p><strong>排序</strong></p>
<ul>
<li>和Python内建列表相似，使用sort方法按位置排序<ul>
<li>在多维数组中传递axis值，沿着轴向对一个维度数据进行排序</li>
<li>顶层np.sort方法返回排好序的<strong>数组拷贝</strong></li>
</ul>
</li>
</ul>
<p><strong>唯一值与其他集合逻辑</strong></p>
<ul>
<li><p>NumPy包含一些针对一维ndarray的基础集合操作</p>
<ul>
<li><p>常用方法np.unique：返回数组中唯一值排序后形成的数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = np.array([<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Joe&#x27;</span>,<span class="string">&#x27;Will&#x27;</span>,<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Will&#x27;</span>,<span class="string">&#x27;Joe&#x27;</span>,<span class="string">&#x27;Joe&#x27;</span>])</span><br><span class="line">np.unique(names)</span><br><span class="line"><span class="comment"># array([&#x27;Bob&#x27;, &#x27;Joe&#x27;, &#x27;Will&#x27;], dtype=&#x27;&lt;U4&#x27;)</span></span><br><span class="line"><span class="comment"># 纯Python实现</span></span><br><span class="line"><span class="built_in">sorted</span>(<span class="built_in">set</span>(names)) <span class="comment"># [&#x27;Bob&#x27;, &#x27;Joe&#x27;, &#x27;Will&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>np.in1d：检查一个数组中的值是否在另外一个数组中，返回一个<strong>布尔值数组</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">values = np.array([<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">np.in1d(values,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>])</span><br><span class="line"><span class="comment"># array([ True, False, False,  True,  True, False,  True])</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>NumPy中集合函数的列表</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_60" alt="epub_22739904_60" style="zoom:50%;" /></li>
</ul>
<h2 id="4-4-使用数组进行文件输入和输出"><a href="#4-4-使用数组进行文件输入和输出" class="headerlink" title="4.4 使用数组进行文件输入和输出"></a>4.4 使用数组进行文件输入和输出</h2><ul>
<li><p>读取表格数据更多使用pandas</p>
</li>
<li><p>np.save和np.load是两大工具函数，默认以未压缩格式进行存储，后缀名是.npy</p>
</li>
<li><p>操作代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">np.save(<span class="string">&#x27;some_array&#x27;</span>,arr) <span class="comment"># .npy后缀名会被自动加上</span></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">np.load(<span class="string">&#x27;some_array.npy&#x27;</span>)</span><br><span class="line"><span class="comment"># array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br><span class="line"><span class="comment"># 用np.savez并将数组作为参数传递给该函数，用于在未压缩文件中保存多个数组</span></span><br><span class="line">np.savez(<span class="string">&#x27;array_archive.npz&#x27;</span>,a=arr,b=arr)</span><br><span class="line"><span class="comment"># 载入一个．npy文件，获得字典型对象，可以方便地载入单个数组</span></span><br><span class="line">arch = np.load(<span class="string">&#x27;array_archive.npz&#x27;</span>)</span><br><span class="line">arch[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="comment"># array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br><span class="line"><span class="comment"># 用numpy.savez_compressed将数据存入已经压缩的文件</span></span><br><span class="line">np.savez_compressed(<span class="string">&#x27;arrays_compressed.npz&#x27;</span>, a=arr, b=arr)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-5-线性代数"><a href="#4-5-线性代数" class="headerlink" title="4.5 线性代数"></a>4.5 线性代数</h2><ul>
<li><p>和Matlab等相比，NumPy的*是矩阵的逐元素乘积，而不是矩阵的点乘积</p>
</li>
<li><p>NumPy的数组方法和numpy命名空间中都有一个函数dot，用于矩阵的操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">y = np.array([[<span class="number">6</span>,<span class="number">23</span>],[-<span class="number">1</span>,<span class="number">7</span>],[<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line"><span class="comment"># 下面两个函数结果相同</span></span><br><span class="line">x.dot(y)</span><br><span class="line">np.dot(x,y)</span><br><span class="line"><span class="comment"># 特殊符号@也作为中缀操作符，用于点乘矩阵操作</span></span><br><span class="line">np.ones(<span class="number">3</span>) <span class="comment"># array([1., 1., 1.])</span></span><br><span class="line">x @ np.ones(<span class="number">3</span>) <span class="comment"># array([ 6., 15.])</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>numpy.linalg</strong></p>
<ul>
<li><p>umpy.linalg拥有一个矩阵分解的标准函数集，以及其他常用函数，例如求逆和行列式求解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv,qr</span><br><span class="line">X = np.random.randn(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment"># X和它的转置矩阵X.T的点乘积</span></span><br><span class="line">mat = X.T.dot(X)</span><br><span class="line">inv(mat)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[ 0.68887032, -0.10901956,  1.11151606, -0.34320821, -0.03279823],</span></span><br><span class="line"><span class="string">       [-0.10901956,  0.2706275 ,  0.14261334,  0.00853147,  0.11737419],</span></span><br><span class="line"><span class="string">       [ 1.11151606,  0.14261334,  4.19833265, -1.61815629,  0.41947259],</span></span><br><span class="line"><span class="string">       [-0.34320821,  0.00853147, -1.61815629,  1.06411834, -0.21598402],</span></span><br><span class="line"><span class="string">       [-0.03279823,  0.11737419,  0.41947259, -0.21598402,  0.20790649]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">mat.dot(inv(mat))</span><br><span class="line">q,r = qr(mat)</span><br><span class="line">r</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([[-5.07518215, -1.18301817,  1.8596161 ,  3.73253357,  5.72862095],</span></span><br><span class="line"><span class="string">       [ 0.        , -1.4987164 ,  2.27029981,  0.47419322,  2.88815351],</span></span><br><span class="line"><span class="string">       [ 0.        ,  0.        , -3.40688982, -1.45302848, -4.59955239],</span></span><br><span class="line"><span class="string">       [ 0.        ,  0.        ,  0.        , -0.56543743, -0.04838235],</span></span><br><span class="line"><span class="string">       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.97738804]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>常用的numpy.linalg函数</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_61" alt="img" style="zoom:50%;" /></li>
</ul>
<h2 id="4-6-伪随机数生成"><a href="#4-6-伪随机数生成" class="headerlink" title="4.6 伪随机数生成"></a>4.6 伪随机数生成</h2><ul>
<li><p>Python内建的random模块一次只能生成一个值，numpy.random模块填补了这项不足，可以高效地生成多种概率分布下的完整样本值数组。</p>
<ul>
<li><p>生成的是<strong>伪随机数</strong>：因为它们是由具有确定性行为的算法根据随机数生成器中的随机数种子生成的</p>
</li>
<li><p>np.random.seed更改NumPy的随机数种子：<code>np.random.seed(1234)</code></p>
</li>
<li><p>numpy.random中的数据生成函数公用了一个全局的随机数种子，为了避免全局状态，可以使用<code>numpy.random.RandomState</code>生成一个随机数生成器，独立于其他的随机状态</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">1234</span>)</span><br><span class="line">rng.randn(<span class="number">10</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">array([ 0.47143516, -1.19097569,  1.43270697, -0.3126519 , -0.72058873,</span></span><br><span class="line"><span class="string">        0.88716294,  0.85958841, -0.6365235 ,  0.01569637, -2.24268495])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>numpy.random中的部分函数列表</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/epub_22739904_62" alt="epub_22739904_62" style="zoom:50%;" /></li>
</ul>
<h2 id="4-7-示例：随机漫步"><a href="#4-7-示例：随机漫步" class="headerlink" title="4.7 示例：随机漫步"></a>4.7 示例：随机漫步</h2><ul>
<li><p>使用np.random模块随机漫步</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nsteps = <span class="number">1000</span></span><br><span class="line">draws = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,size=nsteps)</span><br><span class="line">steps = np.where(draws &gt; <span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line">walk = steps.cumsum()</span><br><span class="line"><span class="comment"># 统计漫步数据</span></span><br><span class="line">walk.<span class="built_in">min</span>() <span class="comment"># -28</span></span><br><span class="line"><span class="comment"># walk.max() # 23</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>找到第一次在某个方向连续走了10步的位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.abs(walk) &gt;= 10返回一个布尔值数组，表示是否连续在同一个方向走了10步</span></span><br><span class="line"><span class="comment"># argmax返回布尔值数组中最大值的第一个位置（True就是最大值）</span></span><br><span class="line"><span class="comment"># argmax效率不高，因为它总是完整的扫描整个数组</span></span><br><span class="line">(np.<span class="built_in">abs</span>(walk) &gt;= <span class="number">10</span>).argmax() <span class="comment"># 387</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>一次性模拟多次随机漫步</strong></p>
<ul>
<li><p>二维的抽取数组，一次性地跨行算出全部5,000个随机步的累积和</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nwalks = <span class="number">5000</span></span><br><span class="line">nsteps = <span class="number">1000</span></span><br><span class="line">draws = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,size=(nwalks,nsteps))</span><br><span class="line">steps = np.where(draws&gt;<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line">walks = steps.cumsum(<span class="number">1</span>)</span><br><span class="line">walks</span><br></pre></td></tr></table></figure>
</li>
<li><p>随机步中计算出30或-30的最小穿越时间</p>
<ul>
<li><p>any方法检查</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hits30 = (np.<span class="built_in">abs</span>(walks)&gt;=<span class="number">30</span>).<span class="built_in">any</span>(<span class="number">1</span>)</span><br><span class="line">hits30 <span class="comment"># array([False,  True,  True, ...,  True, False,  True])</span></span><br><span class="line">hits30.<span class="built_in">sum</span>() <span class="comment"># 达到30或-30的数字 3367</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用布尔值数组选出绝对步数超过30步所在的行，使用argmx从轴向1上获取穿越时间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crossing_times = (np.<span class="built_in">abs</span>(walks[hits30])&gt;=<span class="number">30</span>).argmax(<span class="number">1</span>)</span><br><span class="line">crossing_times.mean()</span><br><span class="line"><span class="comment"># 508.3691713691714</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/26/%E4%B8%80%E3%80%81%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="TT">
      <meta itemprop="description" content="The Journey Is the Reward">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/26/%E4%B8%80%E3%80%81%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" class="post-title-link" itemprop="url">一、准备工作——《利用Python进行数据分析》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-26 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-26T00:00:00+08:00">2022-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 19:33:59" itemprop="dateModified" datetime="2023-09-13T19:33:59+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">机器学习： 数据分析</span></a>
                </span>
            </span>

          
            <span id="/2022/03/26/%E4%B8%80%E3%80%81%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" class="post-meta-item leancloud_visitors" data-flag-title="一、准备工作——《利用Python进行数据分析》" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/26/%E4%B8%80%E3%80%81%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/26/%E4%B8%80%E3%80%81%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章-准备工作"><a href="#第一章-准备工作" class="headerlink" title="第一章 准备工作"></a>第一章 准备工作</h1><h2 id="1-1-本书内容"><a href="#1-1-本书内容" class="headerlink" title="1.1 本书内容"></a>1.1 本书内容</h2><p><strong>常见数据形式</strong></p>
<ul>
<li>表格型的数据，每一列可能会包含不同的类型（字符串、数值、日期或其他）。</li>
<li>多维数组（矩阵）。</li>
<li>由键位列关联的多张表数据（对于SQL用户来说就是主键或外键）。</li>
<li>均匀或非均匀的时间序列。</li>
</ul>
<h2 id="1-2-为何利用Python进行数据分析"><a href="#1-2-为何利用Python进行数据分析" class="headerlink" title="1.2 为何利用Python进行数据分析"></a>1.2 为何利用Python进行数据分析</h2><ul>
<li>Python作为胶水，整合C、C++等语言的代码</li>
<li>解决“双语言”难题：使用相同程序工具集来兼顾研究人员和软件工程师的好处越发明显。</li>
<li>当搭建高并发、多线程应用，尤其是多CPU绑定线程时，使用Python则会成为一项挑战。原因在于Python拥有全局解释器锁（GIL），这是一种防止解释器同时执行多个Python指令的机制。当搭建高并发、多线程应用，尤其是多CPU绑定线程时，使用Python则会成为一项挑战。原因在于Python拥有全局解释器锁（GIL），这是一种防止解释器同时执行多个Python指令的机制。</li>
</ul>
<h2 id="1-3-重要的Python库"><a href="#1-3-重要的Python库" class="headerlink" title="1.3 重要的Python库"></a>1.3 重要的Python库</h2>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/03/26/%E4%B8%80%E3%80%81%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%E2%80%94%E2%80%94%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/07/01%20Introduction%E2%80%94%E2%80%94%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2021%E6%98%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="TT">
      <meta itemprop="description" content="The Journey Is the Reward">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/07/01%20Introduction%E2%80%94%E2%80%94%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2021%E6%98%A5/" class="post-title-link" itemprop="url">01 Introduction 简介和回归——李宏毅深度学习2021春</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-07 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-07T00:00:00+08:00">2021-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 19:49:09" itemprop="dateModified" datetime="2023-09-13T19:49:09+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          
            <span id="/2021/11/07/01%20Introduction%E2%80%94%E2%80%94%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2021%E6%98%A5/" class="post-meta-item leancloud_visitors" data-flag-title="01 Introduction 简介和回归——李宏毅深度学习2021春" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/11/07/01%20Introduction%E2%80%94%E2%80%94%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2021%E6%98%A5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/11/07/01%20Introduction%E2%80%94%E2%80%94%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2021%E6%98%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="01-1-Introduction"><a href="#01-1-Introduction" class="headerlink" title="01-1 Introduction"></a>01-1 Introduction</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">课程网址：https://speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.html</span><br></pre></td></tr></table></figure>

<h2 id="1-Prerequisite"><a href="#1-Prerequisite" class="headerlink" title="1. Prerequisite"></a>1. Prerequisite</h2><ul>
<li>Math<ul>
<li>Calculus (微积分)</li>
<li>Linear algebra (线性代数)</li>
<li>Probability (概率)</li>
</ul>
</li>
<li>Programming<ul>
<li>Python</li>
<li>PyTorch</li>
</ul>
</li>
<li>Hardware:不需要硬件设备，在Google Colab上运行</li>
</ul>
<h2 id="2-Assignment"><a href="#2-Assignment" class="headerlink" title="2. Assignment"></a>2. Assignment</h2><ul>
<li><p>multiple-choice questions（多选）：submitted via NTU COOL</p>
</li>
<li><p>Leaderboard（排行榜）：Kaggle or JudgeBoi (our in-house Kaggle  )</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110271932872.png" alt="Assignment Schedule" style="zoom:50%;" align="left" /></li>
</ul>
<h2 id="3-Lecture-Schedule"><a href="#3-Lecture-Schedule" class="headerlink" title="3. Lecture Schedule"></a>3. Lecture Schedule</h2><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110271937805.jpg" alt="Lecture Schedule" style="zoom:40%;" align="left"/>

<h2 id="4-Kaggle-JudgeBoi-is-similar"><a href="#4-Kaggle-JudgeBoi-is-similar" class="headerlink" title="4. Kaggle (JudgeBoi is similar)"></a>4. Kaggle (JudgeBoi is similar)</h2><ul>
<li>Register a Kaggle account by yourself 注册自己账号</li>
<li>select two results for evaluating on the private set before the assignment deadline</li>
<li>limited submission times per day 每天提交有字数限制</li>
</ul>
<h1 id="01-2-Regression"><a href="#01-2-Regression" class="headerlink" title="01-2 Regression"></a>01-2 Regression</h1><blockquote>
<h2 id="Machine-Learning-≈-Looking-for-Function"><a href="#Machine-Learning-≈-Looking-for-Function" class="headerlink" title="Machine Learning  ≈ Looking for Function"></a>Machine Learning  ≈ Looking for Function</h2></blockquote>
<h2 id="1-Different-types-of-Functions"><a href="#1-Different-types-of-Functions" class="headerlink" title="1. Different types of Functions"></a>1. Different types of Functions</h2><ul>
<li><strong>Regression:</strong> The function outputs a scalar （输出固定值）</li>
<li><strong>Classification:</strong> Given options (<strong>classes</strong>), the function outputs the correct one (分类)</li>
<li><strong>Structured Learning:</strong> create something with structure (image, document)</li>
</ul>
<h2 id="2-How-to-find-a-function"><a href="#2-How-to-find-a-function" class="headerlink" title="2. How to find a function?"></a>2. How to find a function?</h2><blockquote>
<p>研究案例：YouTube Channel     （李宏毅老师YouTube频道观看量）</p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/c/HungyiLeeNTU">https://www.youtube.com/c/HungyiLeeNTU</a></p>
</blockquote>
<h3 id="2-1-Function-with-Unknown-Parameters"><a href="#2-1-Function-with-Unknown-Parameters" class="headerlink" title="2.1 Function with Unknown Parameters"></a>2.1 Function with Unknown Parameters</h3><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110272049047.png" alt="YouTube案例" style="zoom:50%;" align="left"/>

<blockquote>
<p>y: 2&#x2F;26日的观看量，x:2&#x2F;25日的观看量</p>
<p>w 和 b是将要从数据中学习的未知参数   W:<strong>weight</strong>  b:<strong>bias</strong></p>
</blockquote>
<h3 id="2-2-Define-Loss-from-Training-Data"><a href="#2-2-Define-Loss-from-Training-Data" class="headerlink" title="2.2 Define Loss from Training Data"></a>2.2 Define Loss from Training Data</h3><p>等高线图：梯度下降的方向与切线方向垂直  </p>
<p>证明：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chekongfu/article/details/85317288">人工智能数学基础04之：梯度等高线_智者之家-CSDN博客_机器学习等高线</a></p>
<p><strong>Loss损失函数</strong>：L(b,w),表示这组值有多好</p>
<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110272055908.png" alt="image-20211027204735464" style="zoom: 50%;" align="left"/> <img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110272055176.png" alt="image-20211027205518090" style="zoom:50%;" align="right"/></p>
<h3 id="2-3-Optimization"><a href="#2-3-Optimization" class="headerlink" title="2.3 Optimization"></a>2.3 Optimization</h3><p>$$<br>\begin{array}{l}<br>w^{<em>}, b^{</em>}&#x3D;\arg \min_{w, b}  L<br>\end{array}<br>$$</p>
<blockquote>
<p>Gradient Descent梯度下降   Local Minima 局部最优 Global Minima 全局最优</p>
</blockquote>
<ul>
<li><p>(Randomly) Pick initial values $w^0, b^0$ 随机初始化</p>
</li>
<li><p>Compute计算</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110272117754.png" alt="image-20211027211733695" style="zoom:50%;" align="left"/>
</li>
<li><p>Update w and b iteratively   交替更新w和b</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[Step 1:&lt;br /&gt;function with unknown] --&gt; B[Step 2: &lt;br /&gt;define loss from training data] </span><br><span class="line">B --&gt; C[Step 3:&lt;br /&gt; optimization ]</span><br></pre></td></tr></table></figure>

<h3 id="2-4-Sigmoid激活函数"><a href="#2-4-Sigmoid激活函数" class="headerlink" title="2.4 Sigmoid激活函数"></a>2.4 Sigmoid激活函数</h3><p>线性模型太简单，不能满足复杂问题的需要，因此我们需要建立更复杂的模型来拟合复杂曲线</p>
<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110272325187.png" alt="image-20211027232521119"></p>
<p>为了更好的拟合现实世界中复杂的曲线，就需要很多这样分段碎片（hard sigmoid），将它们和常数叠加就可以拟合出各种各样的线性折线</p>
<p>然而hard sigmoid需要用分段函数来表示，在分段函数处不可导，针对计算机来说处理分段函数也更加麻烦，因此可以使用更加圆滑的sigmoid函数来代替，如下图所示</p>
<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110272335279.png" alt="image-20211027233500190"></p>
<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110272336167.png" alt="image-20211027233615094"></p>
<blockquote>
<p>i：no. of sigmoid</p>
<p>j：no. of features</p>
</blockquote>
<p>以上是<strong>线性模型</strong>到<strong>非线性模型</strong>的过程，接下来介绍<strong>非线性模型</strong>到<strong>神经网络</strong>的过程</p>
<h2 id="3-Neural-Networks"><a href="#3-Neural-Networks" class="headerlink" title="3.Neural Networks"></a>3.Neural Networks</h2><blockquote>
<p>本部分展示了$y &#x3D; b + \sum_i :c_i sigmoid(b_i + \sum_j w_{ij}x_j)$公式由内到外的形成过程</p>
</blockquote>
<h3 id="3-1-b-i-sum-j-w-ij-x-j-形成过程"><a href="#3-1-b-i-sum-j-w-ij-x-j-形成过程" class="headerlink" title="3.1 $b_i + \sum_j w_{ij}x_j$形成过程"></a>3.1 $b_i + \sum_j w_{ij}x_j$形成过程</h3><img align = "left " src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281252711.png" alt="image-20211028125240578" style="zoom:50%;" />
i:1,2,3 no. of sigmoid
j:1,2,3 no. of features

<p>$w_{ij}$: weight for $x_j$ for i-th sigmoid </p>
<p>将系数抽象成矩阵</p>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281311792.png" alt="image-20211028131110717" style="zoom:60%;" />

<h3 id="3-2-sigmoid-b-i-sum-j-w-ij-x-j-形成过程"><a href="#3-2-sigmoid-b-i-sum-j-w-ij-x-j-形成过程" class="headerlink" title="3.2 $sigmoid(b_i + \sum_j w_{ij}x_j)$形成过程"></a>3.2 $sigmoid(b_i + \sum_j w_{ij}x_j)$形成过程</h3><img align ="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281320585.png" alt="image-20211028132034512" style="zoom:60%;" />

<h3 id="3-3-b-sum-i-c-i-sigmoid-b-i-sum-j-w-ij-x-j-形成过程"><a href="#3-3-b-sum-i-c-i-sigmoid-b-i-sum-j-w-ij-x-j-形成过程" class="headerlink" title="3.3 $b + \sum_i :c_i sigmoid(b_i + \sum_j w_{ij}x_j)$形成过程"></a>3.3 $b + \sum_i :c_i sigmoid(b_i + \sum_j w_{ij}x_j)$形成过程</h3><img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281404694.png" alt="image-20211028140402595" style="zoom:60%;" />

<h3 id="3-4-神经网络处理过程-Back-to-ML-Framework"><a href="#3-4-神经网络处理过程-Back-to-ML-Framework" class="headerlink" title="3.4 神经网络处理过程 Back to ML Framework"></a>3.4 神经网络处理过程 Back to ML Framework</h3><h4 id="3-4-1-Function-with-unknown-parameters"><a href="#3-4-1-Function-with-unknown-parameters" class="headerlink" title="3.4.1 Function with unknown parameters"></a>3.4.1 Function with unknown parameters</h4><p><img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281409777.png" alt="image-20211028140953706" style="zoom:60%;" />w、b、$c_T$、b组成参数矩阵$\theta$</p>
<h4 id="3-4-2-Loss"><a href="#3-4-2-Loss" class="headerlink" title="3.4.2 Loss"></a>3.4.2 Loss</h4><p>$$<br>L &#x3D; 1&#x2F;N \sum_ne_n<br>$$</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281416887.png" alt="image-20211028141604827" style="zoom:67%;" />

<h4 id="3-4-3-Optimization-of-New-Model"><a href="#3-4-3-Optimization-of-New-Model" class="headerlink" title="3.4.3 Optimization of New Model"></a>3.4.3 Optimization of New Model</h4><ul>
<li><p>$$<br>\theta&#x3D;<br>\begin{vmatrix}<br>\theta_1\<br>\theta_2\<br>\theta_3\<br>\vdots<br>\end{vmatrix}<br>\enspace\enspace\enspace\enspace<br>\theta^*&#x3D;\arg \min_\theta L<br>$$</p>
</li>
<li><p>随机初始化$\theta^0$</p>
</li>
</ul>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281431998.png" alt="image-20211028143107939" style="zoom:40%;" />



<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281444043.png" style="zoom:50%;" />

<blockquote>
<table>
<thead>
<tr>
<th>名词</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>Epoch</td>
<td>使用训练集的全部数据对模型进行一次完整训练，被称之为“<strong>一代训练</strong>”</td>
</tr>
<tr>
<td>Batch</td>
<td>使用训练集中的一小部分样本对模型权重进行一次反向传播的参数更新，这一小部分样本被称为“<strong>一批数据</strong>”</td>
</tr>
<tr>
<td>Iteration</td>
<td>使用一个Batch数据对模型进行一次参数更新的过程，被称之为“<strong>一次训练</strong>”</td>
</tr>
</tbody></table>
<p>一个例子说明：</p>
<p>N&#x3D;10000（10000个样本），B&#x3D;10（Batch size为10）</p>
<p>那么可以得出在一个epoch内更新了1000次参数</p>
</blockquote>
<h2 id="4-ReLU"><a href="#4-ReLU" class="headerlink" title="4. ReLU"></a>4. ReLU</h2><ul>
<li><img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281518156.png" alt="image-20211028151847079" style="zoom:50%;" />
两个ReLU合成了一个Hard Sigmoid</li>
</ul>
<p>系数c可以为复数，有负数时依然使用max而不使用min是为了更好的将公式合起来，更好表示</p>
<ul>
<li><img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281521055.png" alt="image-20211028152141997" style="zoom:50%;" />
Activation function**激活函数**
i变成2i是因为两个ReLU才能合成一个sigmoid




</li>
<li><p>激活函数模拟人脑内的神经元，因此这种结构被称为神经网络</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.怎么样才能处理更复杂的模型呢？</span><br><span class="line">	够多的ReLU和Sigmoid就可以模拟出各种复杂的曲线</span><br><span class="line">	现在也会用一层叠一层的方式，向深度发展（具体为什么，接下来的课程会讲），也就是深度学习</span><br><span class="line">	【注】过多的层数会造成过拟合</span><br><span class="line">2.课程将讲述的模型真的应用到了youtube频道的流量预测，每一层有100个ReLu</span><br></pre></td></tr></table></figure>

<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202110281531545.png" alt="image-20211028153132333" style="zoom: 33%;" />
深度学习模型的层数越来越多,预测误差也越来越小

















<h1 id="01-3-深度学习简介（To-Learn-More）"><a href="#01-3-深度学习简介（To-Learn-More）" class="headerlink" title="01-3 深度学习简介（To Learn More）"></a>01-3 深度学习简介（To Learn More）</h1><h2 id="1-深度学习历史"><a href="#1-深度学习历史" class="headerlink" title="1. 深度学习历史"></a>1. 深度学习历史</h2><ul>
<li><p>1958: Perceptron (linear model)</p>
</li>
<li><p>1969: Perceptron has limitation</p>
</li>
<li><p>1980s: Multi layer perceptron</p>
<ul>
<li>Do not have significant difference from DNN today</li>
</ul>
</li>
<li><p>1986: Backpropagation</p>
<ul>
<li>Usually more than 3 hidden layers is not helpful</li>
</ul>
</li>
<li><p>1989: 1 hidden layer is “good enough”, why deep?</p>
</li>
<li><p>2006: RBM initialization (breakthrough)</p>
</li>
<li><p>2009: GPU</p>
</li>
<li><p>2011: Start to be popular in speech recognition 语音辨识</p>
</li>
<li><p>2012: win ILSVRC image competition</p>
</li>
</ul>
<blockquote>
<p>这部分看看就行</p>
</blockquote>
<h2 id="2-神经网络（Neural-Network）"><a href="#2-神经网络（Neural-Network）" class="headerlink" title="2.神经网络（Neural Network）"></a>2.神经网络（Neural Network）</h2><p>把一个逻辑回归函数看作是一个“<strong>Neural</strong>”，这些神经元不同连接方式就构成了不同的神经网络结构。所有神经元的<strong>weights</strong>和<strong>biases</strong>组成了神经网络的参数$\theta$</p>
<h3 id="2-1-全连接前馈网络"><a href="#2-1-全连接前馈网络" class="headerlink" title="2.1 全连接前馈网络"></a>2.1 全连接前馈网络</h3><blockquote>
<p>Fully Connect Feedforward Network</p>
<p>给定一个网络结构，就是定义了一个函数集合</p>
</blockquote>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111040932704.png" alt="image-20211104093219575" style="zoom:50%;" />

<p>deep 就体现在有很多隐藏层</p>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111040935813.png" alt="image-20211104093518738" style="zoom:67%;" />

<p>把神经网络转化成矩阵运算</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111040952391.png" alt="image-20211104095205311" style="zoom:80%;" />

<p>输出层</p>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111040954041.png" alt="image-20211104095452979" style="zoom:67%;" />

<h3 id="2-2-应用举例：识别数字"><a href="#2-2-应用举例：识别数字" class="headerlink" title="2.2 应用举例：识别数字"></a>2.2 应用举例：识别数字</h3><ul>
<li><p>第一步：神经网络</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111040957516.png" alt="image-20211104095718448" style="zoom:67%;" />

<p>输出层分表表示数字是i(0-9)的概率</p>
<p>需要研究人员自己探索到更好的神经网络结构来实现好的函数设计</p>
</li>
<li><p>第二步：寻找好的函数</p>
<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041014018.png" alt="image-20211104101456912"></p>
</li>
<li><p>第三步：优化参数，找到最好的函数</p>
<ul>
<li><p>梯度下降优化参数</p>
</li>
<li><p>反向传播机制计算偏微分可能更有效率</p>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041023474.png" alt="image-20211104102334382" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<h3 id="2-3-FAQ"><a href="#2-3-FAQ" class="headerlink" title="2.3 FAQ"></a>2.3 FAQ</h3><ul>
<li>How many layers? How many neurons for each layer?</li>
<li>Trial and Error  +   Intution</li>
<li>用多层网络的计算减少了特征工程的工作</li>
<li>深度学习在NLP上没有那么好的效果</li>
<li>Can the structure be automatically determined? 自动找到更好的网络结构<ul>
<li>E.g. Evolutionary Artificial Neural Networks</li>
</ul>
</li>
<li>我们可以自己设计网络结构吗？<ul>
<li>当然可以，比如Convolutional Neural Network (CNN)</li>
</ul>
</li>
<li>深度学习一定是层数越多越好吗？  不是</li>
<li>每一层多添加神经元也可以实现同样的输出矩阵？为什么选择让网络结构更深而不是更宽呢？</li>
</ul>
<h3 id="2-4-深度学习扩展资料"><a href="#2-4-深度学习扩展资料" class="headerlink" title="2.4 深度学习扩展资料"></a>2.4 深度学习扩展资料</h3><ul>
<li>My Course: Machine learning and having it deep and structured<ul>
<li><a target="_blank" rel="noopener" href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_MLSD15_2.html">http://speech.ee.ntu.edu.tw/~tlkagk/courses_MLSD15_2.html</a></li>
<li>6 hour version: <a target="_blank" rel="noopener" href="http://www.slideshare.net/tw_dsconf/ss62245351">http://www.slideshare.net/tw_dsconf/ss62245351</a></li>
</ul>
</li>
<li>“Neural Networks and Deep<ul>
<li>written by Michael Nielsen</li>
<li><a target="_blank" rel="noopener" href="http://neuralnetworksanddeeplearning.com/">http://neuralnetworksanddeeplearning.com/</a></li>
</ul>
</li>
<li>“Deep Learning”<ul>
<li>written by Yoshua Bengio , Ian J. Goodfellow and Aaron Courville</li>
<li><a target="_blank" rel="noopener" href="http://www.deeplearningbook.org/">http://www.deeplearningbook.org</a></li>
</ul>
</li>
</ul>
<h1 id="01-4-反向传播（To-Learn-More）"><a href="#01-4-反向传播（To-Learn-More）" class="headerlink" title="01-4 反向传播（To Learn More）"></a>01-4 反向传播（To Learn More）</h1><h2 id="1-梯度下降"><a href="#1-梯度下降" class="headerlink" title="1. 梯度下降"></a>1. 梯度下降</h2><p>神经网络的参数<br>$$<br>\theta &#x3D; \left {  w_1,w_2,…,b_1,b_2,…  \right }<br>$$<br>初始化$\theta_0$之后，逐步计算$\theta_1,\theta_2$…..</p>
<p>一个大的神经网络中有上百万的参数，为了更有效率的计算梯度下降，我们使用<strong>反向传播（backpropagation）</strong></p>
<h2 id="2-链式法则"><a href="#2-链式法则" class="headerlink" title="2. 链式法则"></a>2. 链式法则</h2><img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041053505.png" alt="image-20211104105312441" style="zoom:50%;" />

<p>case1：x变化一点，y就跟着变化一点，z也相应变化一点</p>
<p>case2：s变化一点，x和y就变化一点，z也随之变化；s通过两条路径影响z的变化</p>
<h2 id="3-反向传播"><a href="#3-反向传播" class="headerlink" title="3. 反向传播"></a>3. 反向传播</h2><img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041445343.png" alt="image-20211104144505209" style="zoom:50%;" />

<h3 id="3-1-前向传播"><a href="#3-1-前向传播" class="headerlink" title="3.1 前向传播"></a>3.1 前向传播</h3><blockquote>
<p>Forward pass，针对所有参数计算$\dfrac{\partial z}{\partial w}$</p>
</blockquote>
<p>根据<strong>链式法则</strong>可以将梯度下降中需要求解的<strong>偏微分</strong>分解，根据前文链式法则有如下公式成立<br>$$<br>\dfrac{\partial C}{\partial w}&#x3D; \dfrac{\partial C}{\partial z}    \dfrac{\partial z}{\partial w}<br>$$<br><img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041455924.png" alt="image-20211104145558857" style="zoom:67%;" /></p>
<p>如图，$\dfrac{\partial z}{\partial w}$的值就是weight前对应的输入值：$\dfrac{\partial z}{\partial w_1}&#x3D;x_1$，$\dfrac{\partial z}{\partial w_2}&#x3D;x_2$</p>
<img  align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041500754.png" alt="image-20211104150040687" style="zoom:50%;" />

<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041503239.png" alt="image-20211104150305176" style="zoom:50%;" />
      那么$\dfrac{\partial C}{\partial z}$该如何求呢？ 如下图，依然使用链式法则分解

<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041908378.png" alt="image-20211104151604648"></p>
<h3 id="3-2-反向传播"><a href="#3-2-反向传播" class="headerlink" title="3.2 反向传播"></a>3.2 反向传播</h3><blockquote>
<p>Backward pass</p>
<p>针对所有激活函数的输入$z$计算$\dfrac{\partial C} {\partial z}$</p>
</blockquote>
<p>接上文，想要求解$\dfrac{\partial C} {\partial z}$，必须要知道$\dfrac{\partial C} {\partial z^&#96;}$和$\dfrac{\partial C} {\partial z^{&#96;&#96;}}$，因为$w_3,w_4$,$\sigma^,(z)$是一个常数。</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">关于为什么σ导数的值是确定的？</span><br><span class="line">    在进行参数初始化后，参数的值就固定下来了，每一次前向传播计算时，这些参数的值是不会变化的。参数不变化，由参数计算出来的函数值就不会发生变化，因此每个激活函数结点的σ导数值已经随着参数的确定而确定，并且已知。</span><br></pre></td></tr></table></figure>

<p>换一种视角（从后向前）看神经网络的结构，可以很好地理解偏微分的计算过程</p>
<p>反向传播约等于建立了一个反向的神经网络，用空间换时间</p>
<p>&#x3D;&#x3D;很想知道计算偏微分的式子为啥可以和这个神经网络的结构很好的对应上（可能要对偏微分的数学原理很清楚才能搞明白）&#x3D;&#x3D;</p>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041908248.png" alt="image-20211104161626409" style="zoom:50%;" />

<blockquote>
<p>灰色方块</p>
<p>​    输入：输入层数值和w</p>
<p>​    输出：z</p>
<p>圆形（激活函数）</p>
<p>​    输入：z</p>
<p>​    输出：a</p>
</blockquote>
<p>虽然这样看来，偏微分之间的关系更好理解了，但是$\dfrac{\partial C} {\partial z^&#96;}$和$\dfrac{\partial C} {\partial z^{&#96;&#96;}}$到底要怎么计算呢？</p>
<ul>
<li><p>case 1：之后就是输出层</p>
<p>问题变得简单了，直接计算就可以了</p>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041908388.png" alt="image-20211104163323083" style="zoom:67%;" />
</li>
<li><p>case2：之后连接的不是输出层</p>
<p>后面还有好多层才到达输出层，其实和直接到达输出层原理一样，就是不断的迭代计算，因为总有一个时刻会到达输出层。</p>
</li>
</ul>
<p>这样看来，从输出层着手逐步向前计算$\dfrac{\partial C} {\partial z}$会更简单，这就是&#x3D;&#x3D;后向传播机制&#x3D;&#x3D;</p>
<img align=left src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041908710.png" alt="image-20211104163717385" style="zoom:67%;" />

<h2 id="3-3-反向传播机制总结"><a href="#3-3-反向传播机制总结" class="headerlink" title="3.3 反向传播机制总结"></a>3.3 反向传播机制总结</h2><p>其实每进行一次参数的梯度下降迭代，都要把神经网络【从前往后】【从后往前】计算两遍</p>
<ul>
<li>【从前往后】根据给定的参数计算函数，在计算的过程中，每个激活函数的到数值都被计算出来了，$\dfrac{\partial Z} {\partial w}$也得到了计算。</li>
<li>【从后往前】为了寻找更好的参数，使用梯度下降的方法，要计算每一个参数的偏微分，但是计算偏微分从前往后太难求了，根据【从前往后】计算出的<strong>输出层值</strong>从后向前推更简便，算法效率更高。</li>
</ul>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111041908500.png" alt="image-20211104164618904" style="zoom:67%;" />

<p>为什么要反着算呢？</p>
<p>​    从前往后算偏微分，算一个偏微分就要把后面的偏微分全都算了，倒着算的话只算一遍就好。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/07/02%20Deep%20Learning%E2%80%94%E2%80%94%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2021%E6%98%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="TT">
      <meta itemprop="description" content="The Journey Is the Reward">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/07/02%20Deep%20Learning%E2%80%94%E2%80%94%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2021%E6%98%A5/" class="post-title-link" itemprop="url">02 机器学习任务攻略——李宏毅深度学习2021春</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-07 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-07T00:00:00+08:00">2021-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 19:49:17" itemprop="dateModified" datetime="2023-09-13T19:49:17+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
                </span>
            </span>

          
            <span id="/2021/11/07/02%20Deep%20Learning%E2%80%94%E2%80%94%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2021%E6%98%A5/" class="post-meta-item leancloud_visitors" data-flag-title="02 机器学习任务攻略——李宏毅深度学习2021春" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/11/07/02%20Deep%20Learning%E2%80%94%E2%80%94%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2021%E6%98%A5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/11/07/02%20Deep%20Learning%E2%80%94%E2%80%94%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2021%E6%98%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="02-1-机器学习任务攻略（General-Guidance）"><a href="#02-1-机器学习任务攻略（General-Guidance）" class="headerlink" title="02-1 机器学习任务攻略（General Guidance）"></a>02-1 机器学习任务攻略（General Guidance）</h1><p><strong>机器学习任务框架</strong></p>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111042034399.png" alt="image-20211104203451301" style="zoom:67%;" />

<p>从训练数据中找到最优化的参数$\theta^*$，将$\theta^*$带入到假设函数中预测结果</p>
<p>当机器学习任务预测的结果不满意时，可以按照下图所示方法检查问题出现在哪</p>
<p>发现问题从训练集<strong>loss</strong>值开始</p>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111042040700.png" alt="image-20211104204008635" style="zoom: 67%;" />



<h2 id="1-训练集loss值大"><a href="#1-训练集loss值大" class="headerlink" title="1. 训练集loss值大"></a>1. 训练集loss值大</h2><h3 id="1-1-模型偏差"><a href="#1-1-模型偏差" class="headerlink" title="1.1 模型偏差"></a>1.1 模型偏差</h3><blockquote>
<p>model bias</p>
</blockquote>
<ul>
<li>原因：模型太简单了，不够复杂，弹性不够大，不能拟合很多复杂情况。</li>
<li>解决方法：重新设计更复杂的模型<ul>
<li>增加特征</li>
<li>使用深度学习（更多的神经元和层数）</li>
</ul>
</li>
</ul>
<h3 id="1-2-优化问题"><a href="#1-2-优化问题" class="headerlink" title="1.2 优化问题"></a>1.2 优化问题</h3><blockquote>
<p>Optimization</p>
</blockquote>
<ul>
<li><p>原因：可能陷入<strong>局部最优解</strong>，没有得到参数的最优方案。</p>
</li>
<li><p>解决方法：探寻更好的优化方法</p>
</li>
<li><p>思考：如果在训练集上<strong>损失值很大</strong>，不一定是因为这个模型太复杂导致过拟合，很可能是因为没有做好优化，致使复杂的模型没有表现出更好的效果。</p>
<img align="left" src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111042058554.png" alt="image-20211104205810485" style="zoom: 67%;" />

<p>如图，看到测试集数据，我们很容易认为这是<strong>过拟合</strong>问题，但是检查训练数据后才发现，比【20层模型】更有弹性、更复杂的【56层模型】竟然在训练集数据上表现的没有【20层模型】。</p>
<p>越复杂的模型就越能拟合训练集的数据，出现这种反常情况，就是因为没有做好模型优化，也就是说<strong>参数的优化问题</strong>限制了【56层模型】的发挥。</p>
<p>那如何判断复杂模型性能不好是因为过拟合还是参数优化问题呢？</p>
<ul>
<li>同时从<strong>测试集</strong>和<strong>训练集</strong>的实验结果中分析</li>
<li>从更容易训练的较浅的网络（或其他模型）开始</li>
<li>如果更深的网络在训练数据上没有获得更小的损失，则存在优化问题</li>
</ul>
</li>
</ul>
<h2 id="2-训练集loss值小"><a href="#2-训练集loss值小" class="headerlink" title="2. 训练集loss值小"></a>2. 训练集loss值小</h2><p>训练集loss值小就要去检查<strong>测试集的loss值</strong>了</p>
<h3 id="2-1-训练集loss值小-amp-测试集loss小"><a href="#2-1-训练集loss值小-amp-测试集loss小" class="headerlink" title="2.1 训练集loss值小&amp;测试集loss小"></a>2.1 训练集loss值小&amp;测试集loss小</h3><p>模型很成功</p>
<h3 id="2-2-训练集loss值小-amp-测试集loss大"><a href="#2-2-训练集loss值小-amp-测试集loss大" class="headerlink" title="2.2  训练集loss值小&amp;测试集loss大"></a>2.2  训练集loss值小&amp;测试集loss大</h3><h4 id="2-2-1-过拟合"><a href="#2-2-1-过拟合" class="headerlink" title="2.2.1 过拟合"></a>2.2.1 过拟合</h4><blockquote>
<p>Overfitting</p>
</blockquote>
<ul>
<li><p>原因：在训练集中模型自由发展，过度地拟合了训练集中的数据，不能很好的泛化。</p>
</li>
<li><p>解决方法：</p>
<ul>
<li><p>提供更多的训练数据</p>
<ul>
<li>寻找更多的数据来训练</li>
<li>根据对特定问题的了解<strong>扩充数据</strong></li>
</ul>
</li>
<li><p>给模型一些<strong>限制</strong></p>
<ul>
<li>规定假设函数的形式，就起到了限制模型的作用。比如一个二次函数，怎么更改参数形状也不会随意变化</li>
<li>设置更少数量的参数或共享参数（比如减少神经元的数量）</li>
<li>正则化</li>
<li>Early spotting</li>
<li>Dropout</li>
</ul>
<blockquote>
<p>限制也不能太多哦，如果只是一个一次函数，再怎么训练也不能拟合复杂的数据，这就又回到了<strong>模型偏差</strong>的问题</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-2-mismatch"><a href="#2-2-2-mismatch" class="headerlink" title="2.2.2 mismatch"></a>2.2.2 mismatch</h4><ul>
<li><p>原因：训练集和测试集不匹配，简单地提升训练数据于事无补。</p>
<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111051432295.png" alt="image-20211105143219217"></p>
</li>
</ul>
<h2 id="3-交叉验证"><a href="#3-交叉验证" class="headerlink" title="3. 交叉验证"></a>3. 交叉验证</h2><p>在训练的时候使用交叉验证，比如<strong>N折交叉验证</strong></p>
<h1 id="02-2-临界点"><a href="#02-2-临界点" class="headerlink" title="02-2 临界点"></a>02-2 临界点</h1><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111051625534.png" alt="image-20211105162515443" style="zoom: 33%;" />

<p>如上图所示，在使用梯度下降方法训练时，很有可能出现<strong>loss值不够小</strong>或者<strong>loss值干脆不变化</strong>的情况，到达临界点后再怎么训练也于事无补。</p>
<p>两种可能：<strong>局部最小值（local minima）</strong>和到达<strong>鞍点（saddle point）</strong></p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111051633185.png" alt="image-20211105163301079" style="zoom: 50%;" />

<p>到达局部最优解就意味着随机下降真的无路可走了，但是到达鞍点还可以通过计算识别并逃离。</p>
<h2 id="1-数学知识-泰勒公式"><a href="#1-数学知识-泰勒公式" class="headerlink" title="1. 数学知识-泰勒公式"></a>1. 数学知识-泰勒公式</h2><blockquote>
<p>Tayler Series Approximation </p>
</blockquote>
<p>根据泰勒公式，$\theta^&#96;$周围的公式可以表示成如下形式</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111091745706.png" alt="image-20211109174520587" style="zoom:50%;" />

<p>其中<strong>g</strong>和<strong>H</strong>是两个矩阵</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111091749507.png" alt="image-20211109174922459" style="zoom:60%;" />

<p>在临界点的时候，<strong>g为零向量</strong>，只剩下原式子的第三项，我们可以根据第三项的<strong>正负号</strong>来判断这个点是<strong>局部最优解</strong>还是<strong>鞍点</strong>。</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111091752661.png" alt="image-20211109175258600" style="zoom:67%;" />

<p>如果第三项<strong>一直是正数</strong>，代表$\theta^&#96;$周围的值都比它大，那么它是局部最小值</p>
<p>如果第三项<strong>一直是负数</strong>，代表$\theta^&#96;$周围的值都比它小，那么它是局部最大值</p>
<p>如果第三项<strong>有正有负</strong>，代表$\theta^&#96;$周围既有比它大的值也有比它小的值，那么它是鞍点，还可以找到方式来优化</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111091759702.png" alt="image-20211109175959619" style="zoom: 60%;" />

<h2 id="2-例子-判断是局部最小值还是鞍点"><a href="#2-例子-判断是局部最小值还是鞍点" class="headerlink" title="2. 例子-判断是局部最小值还是鞍点"></a>2. 例子-判断是局部最小值还是鞍点</h2><p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111091813921.png" alt="image-20211109181317865"></p>
<p>$\lambda_1$为正，$\lambda_2$为负，说明这是一个<strong>鞍点</strong>，<strong>矩阵H</strong>会帮助我们计算接下来递归下降的方向。</p>
<p>假设$u$是H的特征向量，$\lambda$是$u$的特征值，如果$\lambda&lt;0$，则有如下推导：</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111091823574.png" alt="image-20211109182307518" style="zoom:67%;" />

<p>当$\lambda&#x3D;-2$时，有特征向量<br>$$<br>u&#x3D;<br>\begin{vmatrix}<br>1  \<br>1<br>\end{vmatrix}<br>$$<br>沿着这个方向更新参数，就可以逃离鞍点，减小损失函数的值</p>
<blockquote>
<p>展望：当有很多参数存在时，局部最小值可能是罕见的。</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111091831368.png" alt="image-20211109183104296" style="zoom:50%;" />
</blockquote>
<h2 id="3-批处理Batch"><a href="#3-批处理Batch" class="headerlink" title="3. 批处理Batch"></a>3. 批处理Batch</h2><p>借用下图回顾一下用批处理方法来做优化的形式</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111092132287.png" alt="image-20211109213204206" style="zoom:50%;" />

<p>1个<strong>epoch</strong> &#x3D; 1次更新所有的batches，在每一个<strong>epoch</strong>之后<strong>Shuffle</strong></p>
<p>接下来比较<strong>Small Batch</strong>和<strong>Large Batch</strong>（small batch就是batch size小）</p>
<p>假设有20个样本，分两种Batch size训练</p>
<blockquote>
<p>左图：Batch size &#x3D; N (Full Batch)   20个样本更新一次，共更新一次</p>
<p>右图：Batch size &#x3D; 1  每个样本更新一次，共更新20次</p>
</blockquote>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111100918927.png" alt="image-20211110091821813" style="zoom:50%;" />

<ul>
<li><p>按照正常的想法，如果batch size越大，<strong>训练时间</strong>就会越长。但是随着<strong>GPU</strong>的发展，计算机并行计算能力加强，除非batch size特别大，不然batch size的大小几乎不会影响训练时间。</p>
</li>
<li><p><strong>batch size太小</strong>每训练一个<strong>epoch</strong>花费时间就更长</p>
</li>
</ul>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111100930768.png" alt="image-20211110093040684" style="zoom:50%;" />

<ul>
<li><strong>small batch</strong>在训练时会体现出更好的<strong>性能</strong></li>
</ul>
<p>​    <img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111100933135.png" alt="image-20211110093327068" style="zoom: 67%;" /></p>
<p>​    为什么会有这样奇怪的现象呢？</p>
<p>​    其实每一个batch内就有一个<strong>新的样本分布形式</strong>，batch数量越多，数据的分布形式就越多，每一次更新时<strong>损    失函数</strong>都有所变化，不容易卡在某个位置。</p>
<p>​    <img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111100938327.png" alt="image-20211110093813280" style="zoom:50%;" /></p>
<p>​    左图Full Batch卡在某一个地方之后，就没办法继续走下去了。但是如果分了很多batch,就有多次更新的机会，在一个batch中卡住不要紧，可能会在下一个batch中继续求出梯度。逐步优化。</p>
<ul>
<li><p>batch数量多有有助于<strong>泛化</strong>，在测试集上表现效果更好。</p>
<blockquote>
<p>引用On Large Batch Training for Deep Learning: Generalization Gap and Sharp Minima(<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1609.04836)%E7%9A%84%E7%BB%93%E6%9E%9C">https://arxiv.org/abs/1609.04836)的结果</a></p>
</blockquote>
<p>实验发现：在训练集上把<strong>大的batch</strong>和<strong>小的batch</strong>训练的差不多好，但是在测试集上<strong>小的batch</strong>表现更好。</p>
<p>如何解释这一现象呢？论文作者有如下猜想。</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111100955858.png" alt="image-20211110095516754" style="zoom:50%;" />

<p>图中<strong>实线</strong>为<strong>训练集</strong>的loss曲线，<strong>虚线</strong>为<strong>测试集</strong>的loss曲线。每一个问题的loss曲线都会遇到各种<strong>局部最小值</strong>，有的较平坦，有的较陡峭，想比较而言，我们更喜欢<strong>较平坦</strong>的局部最小值。</p>
<p>由于样本抽取不同等原因，训练集loss和测试集loss的分布会存在一定偏差，图中是假设测试集loss向右平移。这样一来，在<strong>较陡峭局部最小值</strong>的地方可能在测试集中对应着较大的loss值，导致泛化能力很差</p>
</li>
</ul>
<p><strong>总结</strong></p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111101002845.png" alt="image-20211110100230779" style="zoom:67%;" />

<p>&#x3D;&#x3D;<strong>Batch Size</strong>也是一个需要决定的<strong>参数</strong>哦&#x3D;&#x3D;</p>
<h2 id="4-Momentum"><a href="#4-Momentum" class="headerlink" title="4. Momentum"></a>4. Momentum</h2><blockquote>
<p>解决优化损失函数时，卡在局部最小值时的状况。</p>
</blockquote>
<h3 id="4-1-梯度下降"><a href="#4-1-梯度下降" class="headerlink" title="4.1 梯度下降"></a>4.1 梯度下降</h3><p>每一次梯度下降的方向都是某一点<strong>偏导数的反方向</strong></p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111101017888.png" alt="image-20211110101759828" style="zoom:50%;" />

<h3 id="4-2-梯度下降-动量"><a href="#4-2-梯度下降-动量" class="headerlink" title="4.2 梯度下降+动量"></a>4.2 梯度下降+动量</h3><p>移动方向 &#x3D; 上一步移动方向 - 现在的梯度方向</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111101020945.png" alt="image-20211110102006879" style="zoom:50%;" />

<p>每一次移动的方向都考量了前面所有方向<br>$$ {align*}<br>m^0 &#x3D;0 \<br>m^1 &#x3D; -\eta g^0 \<br>m^2 &#x3D; - \lambda \eta g^0 - \eta g^1\<br>……<br>$$ {align*}<br><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111101030250.png" alt="image-20211110103003184" style="zoom:50%;" /></p>
<p>如图，在局部最小值仍然可以向前移动，这是因为，前边累加了太多的力量，可以让它逃离局部最小值。</p>
<h2 id="5-临界点总结"><a href="#5-临界点总结" class="headerlink" title="5.临界点总结"></a>5.临界点总结</h2><ul>
<li><strong>临界点</strong>的梯度是<strong>0</strong></li>
<li>临界点可能是<strong>鞍点</strong>或<strong>局部最小值</strong><ul>
<li><strong>Hessian矩阵</strong>可以帮助缺点临界点是<strong>鞍点</strong>还是<strong>局部最小值</strong></li>
<li>局部最小值的情况很<strong>罕见</strong></li>
<li>根据<strong>Hessian矩阵特征向量</strong>可以逃离<strong>鞍点</strong></li>
</ul>
</li>
<li><strong>小的Batch Size</strong>和<strong>动量（Momentum）</strong>可以帮助逃离临界点</li>
</ul>
<h1 id="02-3-学习率"><a href="#02-3-学习率" class="headerlink" title="02-3 学习率"></a>02-3 学习率</h1><h2 id="1-Adaptive-Learning-Rate"><a href="#1-Adaptive-Learning-Rate" class="headerlink" title="1. Adaptive Learning Rate"></a>1. Adaptive Learning Rate</h2><p>很多时候训练模型卡住了都不是因为临界点（梯度很小或者无法再下降），因为在loss值几乎稳定的时候，很有可能梯度并不是0，而且在反复横跳。多数训练在还没有走到临界点时就已经停止了。</p>
<p><strong>不同的参数需要不同的学习率</strong>，有一个大致的原则，如果有一个方向很平缓，希望学习率大一点；如果很陡峭，希望学习率小一点。</p>
<p>以一个参数$\theta_i$为例，其他可以推广</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152015703.png" alt="image-20211115201533635" style="zoom:50%;" />

<p>不同的参数有不同的$\sigma$，同一个参数不同的迭代次数$\sigma$的值也不同。</p>
<p>如何计算$\sigma$?有不同的策略</p>
<h3 id="1-1-Root-Mean-Square"><a href="#1-1-Root-Mean-Square" class="headerlink" title="1.1 Root Mean Square"></a>1.1 Root Mean Square</h3><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152018883.png" alt="image-20211115201857815" style="zoom:50%;" />

<p>这种策略在Adagrad中被使用，这一方法为什么奏效呢？设想一下有$\theta_1$和$\theta_2$两种曲线：</p>
<ul>
<li><p>$\theta_1$更平滑，计算得到的g就更小，$\sihma$就更小，相应地学习率就变大</p>
</li>
<li><p>$\theta_2$更陡峭，计算得到的g就更大，$\sihma$就更大，相应地学习率就变小</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152024449.png" alt="image-20211115202409401" style="zoom:50%;" /></li>
</ul>
<p>但是这种方法并不总是有效的，因为很多时候即使在同一个方向我们也希望学习率的大小是有变化的，可以动态调整。于是出现了RMSProp</p>
<h3 id="1-2-RMSProp"><a href="#1-2-RMSProp" class="headerlink" title="1.2 RMSProp"></a>1.2 RMSProp</h3><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152027157.png" alt="image-20211115202703094" style="zoom:50%;" />

<p><strong>$(1-\alpha)$可以动态地调整</strong></p>
<p>现在最常用的策略就是<strong>Adam:RMSProp+Momentum</strong>(pyTorch可以掉包)</p>
<h3 id="1-3-Learning-Rate-Scheduling"><a href="#1-3-Learning-Rate-Scheduling" class="headerlink" title="1.3 Learning Rate Scheduling"></a>1.3 Learning Rate Scheduling</h3><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152039818.png" alt="image-20211115203907761" style="zoom:60%;" />

<p>在梯度下降的过程中为什么会出现横跳的情况呢？因为本来梯度很小，逐渐行走，但是<strong>多个小的梯度累加之后</strong>，$\sigma$就会产生变化，方向也就跟着改变了，但是会逐步调整回来</p>
<p>这个时候可以给学习率加一个<strong>时间</strong>的变化，比如：随着训练的进行，$\eta^t$越来越小；也可以先增大再减小</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152045004.png" alt="image-20211115204504958" style="zoom:50%;" />

<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152046382.png" alt="image-20211115204626330" style="zoom:50%;" />

<p>warm up没有一个有说服力的解释，只是由训练时的经验得到。</p>
<blockquote>
<p>warm up可能的解释：一开始学习率小一点，有助于学到更多关于error surface的知识</p>
</blockquote>
<h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><p>学习率有多种方式去改变它，只不过课上讲解的方式更常用，还可以加<strong>动量</strong>。</p>
<p><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152051866.png" alt="image-20211115205100819"></p>
<p>动量m和$\theta$都是结合了过去所有的梯度，一个在分子一个在分母，会不会抵消掉呢？不会的，一个重点结合过去的方向，一个重点结合过去的大小。</p>
<p>我们还可以有其他方法来解决训练时遇到的问题，比如试试改变<strong>error surface</strong>呢？把它变得更平滑。</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152055323.png" alt="image-20211115205531215" style="zoom:50%;" />

<h1 id="02-4-Batch-Normalization"><a href="#02-4-Batch-Normalization" class="headerlink" title="02-4 Batch Normalization"></a>02-4 Batch Normalization</h1><h2 id="1-改变landscape"><a href="#1-改变landscape" class="headerlink" title="1. 改变landscape"></a>1. 改变landscape</h2><img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111161935633.png" alt="image-20211116193532495" style="zoom: 67%;" />

<p>如图所示，w变化一点，y就会变化一点，相应地L就会变化一点。但是$x1$很小，变化$w_1$对L的影响就很小；$x_2$很大，变化$w_2$对L的影响就很大。这样每个特征对损失函数的影响不同，如果让特征里不同的维度有同样的数值范围，就可以制造比较好的error surface，训练就变得容易一些。</p>
<h2 id="2-Feature-Normalization"><a href="#2-Feature-Normalization" class="headerlink" title="2. Feature Normalization"></a>2. Feature Normalization</h2><blockquote>
<p>有很多方法，只介绍其中几种</p>
</blockquote>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111161944428.png" alt="image-20211116194440336" style="zoom: 60%;" />

<p>考虑深度学习的特征标准化，对<strong>激活函数前的z</strong>和<strong>激活函数后的a</strong>做标准化都可以，如果激活函数是sigmoid，推荐在其之前标准化，因为sigmoid函数在0附近斜率比较大，算出来的gradient也比较大。</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111161952647.png" alt="image-20211116195202506" style="zoom: 33%;" />

<p>以标准化z为例</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111161954557.png" alt="image-20211116195426467" style="zoom: 67%;" />

<p>和以前神经网络不同的是，现在变化$z_1$会对三个输出层都有影响（因为它参与计算了平均数和标准差）。</p>
<p>每一层神经网络都要标准化，这样网络变得更大了，GPU的运算能力可能无法承载。所以要引入<strong>batch</strong>，在每一个batch内部进行标准化，这就是<strong>Batch Normalization</strong>。</p>
<p>为了不让z在0之间活动，对<strong>标准化后的z</strong>，做一些更改<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111162003235.png" alt="image-20211116200315192" style="zoom:67%;" /></p>
<h2 id="3-批处理标准化——测试"><a href="#3-批处理标准化——测试" class="headerlink" title="3. 批处理标准化——测试"></a>3. 批处理标准化——测试</h2><p>如果是线上的应用，模型是要随时预测数据的，不能等到积累了一个batch size大小的数据才开始训练（计算平均值和标准差等）。解决这一困境的方式就是计算<strong>滑动窗口（moving average)</strong></p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111162009766.png" alt="image-20211116200939720" style="zoom:60%;" />

<p>记录下每一个batch的平均值，以便后续计算，p也是参数</p>
<p>其他知名的正则化方式</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111162015783.png" alt="image-20211116201512724" style="zoom:67%;" />

<h1 id="02-5-分类"><a href="#02-5-分类" class="headerlink" title="02-5 分类"></a><strong>02-5 分类</strong></h1><blockquote>
<p>李宏毅老师y表示的是预测值，$\hat{y}$表示真实值</p>
</blockquote>
<p>分类类似于回归，但是输出值如果是1,2,3等数字来代表类别会有一些问题，比如是不是1和2更接近，1和3更远？这些数字可以在数学上区别开来，所以应该换一种方式表示。</p>
<p>想要预测三个类别，我们就可以让神经网络输出三个结果组成矩阵，采用<strong>one-hot编码</strong>来预测类别</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152128746.png" alt="image-20211115212856681" style="zoom:50%;" />

<p>与回归不同的时，在分类时，预测值y通常需要<strong>softmax函数</strong>转换为$y^&#96;$再去和真实值比较</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152130199.png" alt="image-20211115213046150" style="zoom:50%;" />

<p>输出值可能是任何值，但是类别只能用0和1表示，所以要经过转换，变成0,1之间的数字，这样才便于区分类别。举例：如下图所示：</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152132555.png" alt="image-20211115213227488" style="zoom:50%;" />

<p>如果是二分类问题，直接用sigmoid做转换就可以啦，和Soft-max的功能一样</p>
<p>分类时，损失函数也有很多种，比如<strong>Mean Square Error (MSE)<strong>和</strong>交叉熵Cross-entropy</strong>(最小交叉熵等于极大似然)</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152137501.png" alt="image-20211115213702442" style="zoom:50%;" />

<p>最常用的就是交叉熵，常用到pyTorch的包已经将softmax和交叉熵绑定在一起，不需要你自己定义。使用的时候如果你再定义，就是使用了两遍。</p>
<p>为什么交叉熵更常用呢？</p>
<ul>
<li><p>因为使用平方差很可能让训练陷入困境，在损失函数图像中，它有导数的地方占比比较小，会有无法求出梯度的情况，像下面这个例子一样。</p>
<img src="https://justdoit6.oss-cn-zhangjiakou.aliyuncs.com/gitImage/202111152207269.png" alt="image-20211115220719160" style="zoom:50%;" />
</li>
<li><p>如图，$y_3$的值可以忽略不计，损失函数的右下方为最优解位置，MSE会因为没有导数而困在左上方</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="TT"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">TT</p>
  <div class="site-description" itemprop="description">The Journey Is the Reward</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TT</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'TNUpeWIcsOXnq5yrEo6XphL5-gzGzoHsz',
      appKey     : 'HdE2XffT6XTWRYvV2zovg336',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
